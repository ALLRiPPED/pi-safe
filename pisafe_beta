#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021" 

# This script basically 
# 1- copies a media-device with 'dd'
# 2- shrinks the last partition with 'pishrink'
# 3- compresses with 'zip' 

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

# https://jfearn.fedorapeople.org/fdocs/en-US/Documentation/0.1/html/Fedora_Multiboot_Guide/freespace-ntfs.html


SCRIPTNAME="${0##*/}"
SCRIPTVER="1.1.5"   # 2021/11/04 
PRODUCTNAME="PiSafe"
PRODUCTCOMMENT="Raspberry Pi Imaging App"
PRODUCTHOME="https://github.com/RichardMidnight/pi-safe"
CURRENT_DIR=$(pwd)
USER=$(whoami)
CONFIG=/home/$USER/.config/pisafe/pisafe.conf
REQUIRED_TOOLS="pv bc whiptail zip unzip pigz lua pishrink.sh xz "
INTERFACE="cli"
INDEV=
OUTDEV=
INFILE=
OUTFILE=
BACKTITLE="$PRODUCTNAME ver $SCRIPTVER   === $PRODUCTCOMMENT === "
SKIP_FREESPACE=on
LOG=on
LOG_FILE="/home/$USER/.config/pisafe/PiSafe.log"
CHECK_FOR_UPDATES_ON_STARTUP=on

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }


Desktop_environment_notes(){
    # this is just a reference of tested OSs from 2021

    DISTRO                      TERMINAL            TEXT EDITOR         
    RaspberryPiOS-stretch       lxterminal          leafpad?
    RaspberrypiOS-buster        lxterminal          mousepad
    Debian-GNOME                gnome-terminal      gedit
    Debian Xfce                 xfce4-terminal      mousepad
    Debian KDE Plasma           konsole             kwrite
    Debian Cinnamon             xterm / uxterm      gedit
    Debian MATE                 mate-terminal       pluma
    Debian LXDE                 lxterminal          mousepad
    Debian LXQt                 qterminal           featherpad
    ubuntu gnome                gnome-terminal      gedit
    lubuntu LXQt                qterminal           featherpad
    LMDE-4 Cinnamon             gnome-terminal      xed
    mint cinnamon               gnome-terminal      xed
    mint MATE                   mate-terminal       xed
    Mint Xfce                   xfce4-terminal      Xed

    bionic puppy    - ppm       lxterminal          geany 
    arch / manjaro  - pacman -S
    zorin - ubuntu based
    manjaro kde                 konsole             kate
    manjaro xfce                xfce-terminal       mousepad
    
    
    Tested with
    --- ARM ---
    Raspios Buster      good
    Raspbian Stretch    good
    Raspbian Jessy      can work with limitations
    Manjaro             good         
    Ubuntu              good
    Note: overlay filesystem cannot be turned on
    
    --- x86 ---
    debian Strech, Buster         no shrink, last is logical swap.
    RPD Buster                    no shrink, last is logical swap.
    mint  20.1                    no shrink, last is ext logical.
    LMDE 4                        good
    ubuntu                        good
    lubuntu                       good
}


pisafe_help() {
    echo "$PRODUCTNAME v$SCRIPTVER  - Designed for Raspberry Pi"
    echo " - Backup your media (SD card) to an image file"
    echo " - Restore your media (SD card) from an image file"
    echo
    echo "Usage: "
    echo "  $SCRIPTNAME [function] [media/file] [file/media] [-y]"
    echo
    echo "CLI Function is:"
    echo "                               - with no arguments it launches the PiSafe menu (recommended)"
    echo "  list                         - list media and image-files "
    echo "  backup [device] [file]       - backup media to image-file"
    echo "  restore [file] [device] [-y] - restore image-file to media"
    echo "  details [device]             - show media details"
    echo "  erase [device] [-y]          - format media as FAT32"
    echo "  wipe [device] [-y]           - wipe media.  Fill with zeros"
    echo "  test [device] [-y]           - test media.  Write and read ones and zeros"
    echo "  install [-y]                 - install this script"
    echo "  update [-y]                  - update script from website"
    echo "  uninstall [-y]               - uninstall this script"
    echo "  -v                           - display version"
    echo "  help | -h  | --h             - help"
    echo
    echo "Notes: "
    echo " - Supports .img .zip .xz .gz and .iso files.  Appends '.img.$DEFAULT_EXTENSION' if no extension is specified "
    echo " - Specifying an '.img' or '.iso' extension is faster but twice the size because it is not compressed."
    echo " -y automatically answers 'y' to confirmation question."
    echo
    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Examples:"
    echo "$SCRIPTNAME "
    echo "$SCRIPTNAME list"
    echo "$SCRIPTNAME backup sda newimage"
    echo "$SCRIPTNAME backup /dev/sdb newimage.xz"
    echo "$SCRIPTNAME restore newimage.img.zip sda"
    echo "$SCRIPTNAME backup /dev/sda /media/pi/SandiskUSB/backup_\$(date +%Y-%d-%m_%I%M%p).img.gz"
    echo
}


pisafe_about(){
    echo "$PRODUCTNAME was started in 2017 as 'sd' by 'RichardMidnight on github'"\
        "while working on a Raspberry Pi Homebridge project and needing"\
        "to make numerous restore-points.  The image writers available at the"\
        "time did not run on the pi itself and were not able to create a new image file." 
    echo
    echo "It was originally called 'sd' and only had a CLI."
    echo
    echo "Then in 2021, the menu front-end was added to make it more usable by others."\
        "It was then renamed it 'PiSafe'.  PiSafe is a reference to the 'ventilated cupboards for storing"\
        "pies while protecting them from insects and vermin'. "
    echo
    echo "It may work on many debian and arch distros."
    echo 
    echo "It's home is $PRODUCTHOME"
    echo
    echo "Use at your own risk."
    echo
    echo "Hopfully PiSafe is useful to others."
    echo
}


# ---------- Enviroment functions
env_installer(){
    local INSTALLER=

    if [ -f /usr/bin/apt ]; then             # debian
        INSTALLER="apt install -y"
    elif [ -f /usr/bin/pacman ]; then        # arch
        INSTALLER="pacman -S --noconfirm"
    elif [ -f /usr/bin/dnf ]; then            #rpm / fedora
        INSTALLER="dnf install -y"  
    fi

    echo "$INSTALLER"
}


env_terminal(){
    local TERMINAL1=
    
    if [ -f /usr/bin/lxterminal ];then
      TERMINAL1="lxterminal --geometry=110x40 --title='PiSafe' -e bash -c "
    
    elif [ -f /usr/bin/xfce4-terminal ];then
      TERMINAL1="xfce4-terminal --geometry=110x40 --title='PiSafe' -x bash -c "
    elif [ -f /usr/bin/mate-terminal ];then
      TERMINAL1="mate-terminal --geometry=110x40 --title='PiSafe' -x bash -c "
    elif [ -f /usr/bin/gnome-terminal ];then
      TERMINAL1="gnome-terminal --geometry=110x40 --title='PiSafe' -x bash -c "
      
    elif [ -f /usr/bin/xterm ];then
      TERMINAL1="xterm -geometry 110x40 -T 'PiSafe' -e bash -c " 

    elif [ -f /usr/bin/terminator ];then
      TERMINAL1="terminator --geometry=110x40 -T 'PiSafe' -x bash -c "
      
    elif [ -f /usr/bin/konsole ];then
      TERMINAL1="konsole -e bash -c " 
    elif [ -f /usr/bin/qterminal ];then
      TERMINAL1="qterminal -e bash -c "   
      
    elif [ -f /usr/bin/x-terminal-emulator ];then
      TERMINAL1="$(readlink -f /usr/bin/x-terminal-emulator) -e bash -c "
      
    else
      echo "Failed to locate any terminal emulators!!!"
      return 1
    fi

    echo "$TERMINAL1"
}


env_texteditor(){
    TEXT_EDITORS=" leafpad xed gedit featherpad kwrite pluma kate mousepad geany nano "
    
    for TEXT_EDITOR in $TEXT_EDITORS ; do
        if [ -f /usr/bin/$TEXT_EDITOR ]; then
            echo $TEXT_EDITOR
            return
        fi
    done
}
 

env_root_device() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    # new simpler way
    ROOT_PARTITION=$(findmnt -no source /)
    ROOT_MAJ=$(findmnt  -n -e  -o MAJ:MIN / | cut -d: -f1)
    ROOT_DEV=$(lsblk | grep $ROOT_MAJ:0 | cut -d" " -f1)
    echo $ROOT_DEV
}


# ---------- Config_var functions

config_var_init_configfile(){
    if [ ! -d $(file_path $CONFIG) ]; then
        mkdir -p $(file_path $CONFIG)
    fi
    
    if [ ! -f $CONFIG ]; then
        touch $CONFIG
        echo "# $CONFIG" > $CONFIG
        config_var_set_defaults
    fi
}


config_var_set_defaults(){
    config_var_set settings_script_ver $SCRIPTVER $CONFIG
    config_var_set default_path $HOME/Downloads $CONFIG
    config_var_set hide_root_device on $CONFIG
    config_var_set check_for_updates_on_startup on $CONFIG

#backup settings
    config_var_set shrink_fs on $CONFIG
    config_var_set auto_expand_fs on $CONFIG
    config_var_set default_extension zip $CONFIG
    config_var_set compression_level 1 $CONFIG
    config_var_set parallel_compression on $CONFIG
    config_var_set large_device_read_warning 17179869184 $CONFIG
    config_var_set skip_freespace on $CONFIG
    
#restore settings
    config_var_set large_device_write_warning 17179869184 $CONFIG
    config_var_set safety on $CONFIG    

#other    
    config_var_set debug_mode off $CONFIG
    config_var_set sound on $CONFIG
    config_var_set log on $CONFIG
    config_var_set log_file /home/$USER/.config/pisafe/PiSafe.log $CONFIG
    
    config_var_set text_editor $(env_texteditor) $CONFIG
}


config_var_get_settings(){
    SETTINGS_SCRIPT_VER=$(config_var_get settings_script_ver $CONFIG)
    DEFAULT_PATH=$(config_var_get default_path $CONFIG)
    HIDE_ROOT_DEVICE=$(config_var_get hide_root_device $CONFIG)
    CHECK_FOR_UPDATES_ON_STARTUP=$(config_var_get check_for_updates_on_startup $CONFIG)
 
    # backup settings
    SHRINK_FS=$(config_var_get shrink_fs $CONFIG)
    AUTO_EXPAND_FS=$(config_var_get auto_expand_fs $CONFIG)
    DEFAULT_EXTENSION=$(config_var_get default_extension $CONFIG)
    COMPRESSION=$(config_var_get compression_level $CONFIG)
    LARGE_DEVICE_READ_WARNING=$(config_var_get large_device_read_warning $CONFIG) 
    SKIP_FREESPACE=$(config_var_get skip_freespace $CONFIG)
    
    # restore settings
    LARGE_DEVICE_WRITE_WARNING=$(config_var_get large_device_write_warning $CONFIG) 
    SAFETY=$(config_var_get safety $CONFIG)  

    # other    
    DEBUG_MODE=$(config_var_get debug_mode $CONFIG)
    SOUND=$(config_var_get sound $CONFIG)
    LOG=$(config_var_get log $CONFIG)
    LOG_FILE=$(config_var_get log_file $CONFIG)
    VERIFY=off
    TEXT_EDITOR=$(config_var_get text_editor $CONFIG)
    
    mkdir -p "$DEFAULT_PATH"
}


config_var_set() {
    lua - "$1" "$2" "$3" <<EOF > "$3.bak"
local key=assert(arg[1])
local value=assert(arg[2])
local fn=assert(arg[3])
local file=assert(io.open(fn))
local made_change=false
for line in file:lines() do
  if line:match("^#?%s*"..key.."=.*$") then
    line=key.."="..value
    made_change=true
  end
  print(line)
end

if not made_change then
  print(key.."="..value)
end
EOF
mv "$3.bak" "$3"
}


config_var_clear() {
    lua - "$1" "$2" <<EOF > "$2.bak"
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
for line in file:lines() do
  if line:match("^%s*"..key.."=.*$") then
    line="#"..line
  end
  print(line)
end
EOF
mv "$2.bak" "$2"
}


config_var_get() {
    lua - "$1" "$2" <<EOF
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
local found=false
for line in file:lines() do
  local val = line:match("^%s*"..key.."=(.*)$")
  if (val ~= nil) then
    print(val)
    found=true
    break
  end
end
if not found then
   print(0)
end
EOF
}



########################################
###  WHIPTAIL GUI FUNCTIONS ##############
########################################


whiptail_calc_wt_size() {
    # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
    # output from tput. However in this case, tput detects neither stdout or 
    # stderr is a tty and so only gives default 80, 24 values

    WT_HEIGHT=20
    WT_WIDTH=80
    WT_HEIGHT_TALL=$(($(tput lines)-10))
    WT_WIDTH_WIDE=$(($(tput cols)-7))

    if [ -z "$WT_WIDTH" ] || [ "$WT_WIDTH" -lt 60 ]; then
        WT_WIDTH=80
    fi
    if [ "$WT_WIDTH" -gt 178 ]; then
        WT_WIDTH=80
    fi

    WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
    WT_MENU_HEIGHT_TALL=$(($WT_HEIGHT_TALL-7))

    WT_MB_HEIGHT=$WT_HEIGHT
    WT_MB_WIDTH=$WT_WIDTH
}


whiptail_fselect() {

#
#  Arguments
#     1  Dialog title
#     2  Source path to list files and directories
#     3  File mask (by default *)
#     4  "yes" to allow go back in the file system.
#
#  Returns
#     0  if a file was selected and loads the FILE_SELECTED variable 
#        with the selected file.
#     1  if the user cancels.
#
#if whiptail_fselect "Please, select a file" /home/user ; then
#        echo "File Selected: \"$FILE_SELECTED\"."
#else
#        echo "Cancelled!"
#fi
# ----------------------------------------------------------------------

    local TITLE=${1:-$MSG_INFO_TITLE}
    local LOCAL_PATH=${2:-$(pwd)}
    local FILE_MASK=${3:-"*"}
    #local FILE_MASK='( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" )'
    local ALLOW_BACK=${4:-no}
    local FILES=()

    [ "$ALLOW_BACK" != "no" ] && FILES+=(".." "..")

    IFS=$'\t\n'

    FILES=("FILENAME" "     SIZE   (IMAGESIZE)")

    # First add folders      
    for DIR in $(find $LOCAL_PATH -maxdepth 1 -mindepth 1 -name "[!.]*" -type d -printf "%f\t" | sort 2> /dev/null)
    do
        FILES+=($DIR  "     folder")
    done              
                
    # Then add files                                
    for FILE in $(find $LOCAL_PATH -maxdepth 1 \
        \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" -o -name "*.iso" \) \
        -type f \
        -printf "%f\t     %s\n" | sort  2> /dev/null)                                                                  
    do
        FILES+=($FILE)
    done
	unset IFS


    # convert filesizes to human readable and add image size
    num='^[0-9]+$'
    arraylength=${#FILES[@]}
    
    if [ $arraylength = 0 ]; then
        FILES=(no files)
    fi
    
    for (( i=0; i<${arraylength}; i++ )); do
		arrayelement=$(echo "${FILES[$i]}" | sed 's/ *//g')
		if [[ "$arrayelement" =~ $num ]] ; then  
            #FILES[$i]=$(echo "    " $(get_bytes_h $arrayelement -h))
            FILES[$i]=$(echo "    " $(get_bytes $arrayelement -h) \($(file_image_size "$LOCAL_PATH/$PREVIOUS_ELEMENT" -h)\)) 
		else
            PREVIOUS_ELEMENT=$(echo "${FILES[$i]}")
        fi
    done
 
 
    # let user select file
    while true
    do
        FILE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$LOCAL_PATH" \
                                --menu "Choose a file" $WT_HEIGHT_TALL $WT_WIDTH_WIDE $WT_MENU_HEIGHT_TALL "${FILES[@]}"  3>&1 1>&2 2>&3)

        #exit if bad whiptail statement
        FSX=${FILE_SELECTED:0:3}
       # if [ ! -z $FSX ] && [ $FSX = "Box" ]; then
        if [ ~$FSX = "~Box" ]; then
            echo "ERROR in whiptail in whiptail_fselect.  Maybe a space in a filename?"
			echo "${FILES[@]}"
            exit 1
        fi
        
        if [ -z "$FILE_SELECTED" ]; then
            return 1
        else
            if [ "$FILE_SELECTED" = ".." ] && [ "$ALLOW_BACK" != "no" ]; then
                return 0

            elif [ -d "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                if whiptail_fselect "$TITLE" "$LOCAL_PATH/$FILE_SELECTED" "$FILE_MASK" "yes" ; then
                    if [ "$FILE_SELECTED" != ".." ]; then
                        return 0
                    fi
                else
                    return 1
                fi

            elif [ -f "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                FILE_SELECTED="$LOCAL_PATH/$FILE_SELECTED"
                return 0
            fi
        fi
    done
}


whiptail_countdown(){  
    local MAX=${1:-10}
    local TITLE=${2:-"COUNTDOWN... press any key to stop or 'y' to continue now"}
    MSG=${3:-"Countdown for $MAX seconds.\n\n"}

    for ((i=$MAX; i>=0; i--)) ; do
		TERM=vt220 whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --infobox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        read -t 1 -N 1 INPUT
        if [ ! -z $INPUT ]; then
            if [ $INPUT = "y" ]; then
                echo Continuing...
                return 0
            else
              echo $INPUT
              return 2
            fi
        fi 
        MSG=$(echo "$MSG.$i")
    done 
}



# ---------- UI functions

ui_msg() {
    TITLE="$1"
    MSG="$2"
    COLOR=${3:-"white"}
    OK_BUTTON=${4:-"Back"}
    
    if [ $INTERFACE = "cli" ]; then
        #MSG="$PRODUCTNAME: $TITLE: $MSG"
        echo -n "$PRODUCTNAME: $TITLE: "
        if [ $COLOR = "red" ]; then
            echo_red "$MSG"
        else    
            echo -e "$MSG"
        fi
    else
        whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --scrolltext --ok-button "$OK_BUTTON" --msgbox "$MSG" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
    fi
}


ui_yesno(){
    TITLE="$1"
    MSG="$2"
    DEFAULT=${3:-""}   # defaults to Yes.  can specify --defaultno
    COLOR=${4:-"white"}
    
    if [ $INTERFACE = "cli" ]; then
        MSG="$PRODUCTNAME: $TITLE: $MSG  [y/n]?"
        while true; do
            read -n1 -p "$MSG" yn
            echo
            case $yn in
                [Yy]* ) echo y; return 0;;
                [Nn]* ) echo n; return 0;;
                * )     ;;
            esac
        done
    else    
        whiptail --backtitle "$BACKTITLE"  --title "$TITLE" $DEFAULT --yesno "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH 3>&1 1>&2 2>&3
        RC=$?
        if (( $RC )); then
            echo n
        else
            echo y
        fi
        return $RC
    fi
}


ui_countdown(){
    local SECONDS=${1:-10}
    local TITLE=$2
    local MESSAGE=${3:-"Counting down..."}
    if [ "$INTERFACE" = "cli" ]; then
        do_countdown $1
    else
        whiptail_countdown "$SECONDS" "$TITLE" "$MESSAGE"
    fi
}


ui_error() {
    LINE=$1
    shift
    MSG="$@"

    ui_msg "Error in line $LINE" "$MSG" red    
}

# ---------- Misc functions

echo_if_cli (){
    local MSG=$1
    local COLOR=$2
    if [ "$INTERFACE" = "cli" ]; then
        case $COLOR in
            white) echo_white $MSG ;;
            red)    echo_red $MSG ;;
            *) echo $MSG ;;
        esac
    fi
}


do_countdown(){  
    local MAX=${1:-10}
 
    echo "Pausing for $MAX seconds... Ctrl-C to stop, y to continue immediately"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
        read -t 1 -N 1 INPUT
        if [ ! -z "$INPUT" ]; then
            if [ "$INPUT" = "y" ]; then
                echo continuing...
                return 0
            else
                echo $INPUT
                return 2
            fi
        fi 
        MSG=$(echo "$MSG.$i")
    done 
    echo ...
}


do_beep(){
    FREQ=${1:-700}
    TIME=${2:-.5}
    if [ "$SOUND" = on ] ; then
        (speaker-test -t sign -f $FREQ > /dev/null  & sleep $TIME && kill -9 $! ) > /dev/null
      #  sleep .5  # to allow the beep to end
    fi
}

do_beep_up(){
    do_beep 700 .4
    do_beep 900 .6
}

do_beep_down(){
   do_beep 900 .5
   do_beep 700 .5
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


get_ver_to_int() {
	local IFS=.
	parts=($1)
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


get_bytes(){
    # translates from bytes to human readable and vice-verse
    # currently shows 3 significant digits.
    local BYTES=$1
    local OUTPUT=${2:-"-h"};  #human or bytes
    
    local BASE=$(echo $BYTES | tr -cd '[[:digit:]]' )
    local SUFFIX=$(echo $BYTES | tr -cd '[[kmgtbKMGTB]]' )

    
    NUM='^[0-9]+$'
    if ! [[ "$BYTES" =~ $NUM ]] ; then   # not a number   
        return 1
    fi
    

    # if no translation needed... then just echo the input and leave
    if [ $OUTPUT != "-h" ] && [ -z $SUFFIX ] ; then
        echo $BYTES
        return
    fi
    
    if [ $OUTPUT = "-h" ] && [ ! -z $SUFFIX ] ; then
        echo $BYTES
        return
    fi


    if [ $OUTPUT = "-h" ] ; then  # translate to human readable
    
        if [ -z $SUFFIX ]; then
            local LEN=${#BYTES}
            local k_ilo=1024;
            local m_ega=$k_ilo*$k_ilo;
            local g_iga=$m_ega*$k_ilo;
            local t_era=$g_iga*$k_ilo;
            local p_eta=$t_era*$k_ilo;
            
            [ -z "$BYTES" ] && return
            
            NUM='^[0-9]+$'
            if ! [[ "$BYTES" =~ $NUM ]] ; then   # not a number   
                return 1
            fi
            
            case $LEN in
                4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
                5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
                6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
                
                7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
                8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
                9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
                
                10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
                11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
                12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
                
                13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
                14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
                15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
                *)  echo $BYTES ;;
            esac
        else
            echo $BYTES
        fi    

    else  # translate to bytes
    
        case $SUFFIX in

        b|B|"")
            echo $BASE
            ;;
        
        k|K|kb|KB)
            echo $(($BASE*1024))
            ;;

        m|M|mb|MB)
            echo $(($BASE*1024*1024))
            ;;
            
        g|G|gb|GB)
            echo $(($BASE*1024*1024*1024))
            ;;
            
        t|T|tb|TB)
            echo $(($BASE*1024*1024*1024*2014))
            ;;
        *)
            ui_error $LINENO "bad byte suffix 'SUFFIX'"
            ;;
    
        esac
    fi
}


# ---------- file functions


file_path_base(){
    #echo $(file_path "$*")/$(file_base "$*")
    echo "$*" | cut -d. -f1
}


file_path(){
    dirname "$*"
}


file_base() {
    local fullfilename=$*
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo "$fname"
}


file_ext(){
	base=$(basename "$*")
	#look for a period in the basename.  if there is one, there is an extention
	HAS_DOT=$(echo "$base" | grep \\.)
	if [ ! -z "$HAS_DOT" ] ; then
		echo $base | sed 's#.*\.##g'
	else  
		echo ""
		return 1
	fi
}


file_size() {
    local FILE=$1
    local HUMAN=${2:-"no"}
    # $2 can be -h
    
    if [ -f "$FILE" ] ; then
        SIZE_BYTES="$(($(ls -s "$FILE" | cut -d' ' -f1) * 1024))"
        RC=$?
        if (( $RC )); then
            return $RC
        fi
        if [ $HUMAN = "-h" ]; then
            echo $(get_bytes $SIZE_BYTES -h)
        else
            echo $SIZE_BYTES
        fi
    else
        echo 0
    fi
}


file_image_size() {
    local INFILE="$1"
    local HUMAN=${2:-"no"}
    
    file_image_exists "$INFILE" > /dev/null
    if (( $? )) ; then
        # image file not found
        echo 0
        return 1
    fi
    
    case $(file_ext "$INFILE") in
        img | iso)
            SIZE_BYTES=$(echo $((  $(ls -s "$INFILE" | cut -d' ' -f1 ) * 1024 )) )
        ;;
        
        zip)
            SIZE_BYTES=$(zipinfo -t "$INFILE" 2> /dev/null | grep "%" | cut -d, -f2 | cut -d" " -f2  )
        ;;
        
        xz)
            SIZE_BYTES=$(xz -l -v "$INFILE" 2> /dev/null | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1 | sed 's/,//g')
        ;;  
          
        gz)
            SIZE_BYTES=$(pigz -l "$INFILE" 2> /dev/null | grep -v compressed | sed 's/\s\s*/ /g' | sed -e 's/^[ \t]*//' | cut -d' ' -f 2 | sed 's/?/0/g')
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
    
    if [ -z $SIZE_BYTES ] ; then
        echo 0 
        return 0
    fi
    
    if [ $HUMAN = "-h" ]; then
        echo $(get_bytes $SIZE_BYTES -h)
    else
        echo $SIZE_BYTES
    fi
}    


file_image_exists(){
    # returns 0 if there is an imagefile
    # returns 1 if no imagefile

    local INFILE="$*"
    local IMG
    
    if [ ! -f "$INFILE" ] ; then
        #echo_if_cli "ERROR '$INFILE' not found"
        ui_error $LINENO "'$INFILE' not found"
        return 1
    fi
    
    echo -n "Inspecting '$INFILE' for an image file ... "
 
    case $(file_ext "$INFILE") in
        img | iso)
            IMG=$INFILE
        ;;
        
        zip)
            IMG=$(zipinfo -1 "$INFILE" 2> /dev/null | grep .img | cut -d " " -f 11)  
        ;;
        
        xz)
            IMG=$(xz -l "$INFILE" 2> /dev/null | grep .img | sed 's/\s\s*/ /g' | cut -d' ' -f10-)
        ;;   
         
        gz)
            IMG=$(pigz -l "$INFILE" 2> /dev/null | grep .img | sed 's/\s\s*/ /g' | cut -d " " -f4-)
        ;;
         
        *)
            IMG=
        ;;
    esac
    
    if [ ! -z "$IMG" ] ; then
        echo "$IMG" [OK]
        return 0
    else
        ui_error $LINENO "No image found in '$INFILE'"
        return 1
    fi    
}


file_ext_ok(){
    #check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
    OUTFILE_EXT=$(file_ext "$1")

    case $OUTFILE_EXT in
        img | zip | xz | gz | iso | "" )
            echo true
            return 0
            ;;
        
        *)  
            echo ""
            return 1
            ;;
    esac
}


file_list_image_files(){
    FILES="FILE_NAME FILE_SIZE (IMAGE_SIZE) \n"
    CONFIG=/home/$USER/.config/pisafe/pisafe.conf
    IFS=$'\t\n'
    
    for FILE in $(ls *.img *.zip *.xz *.gz *.iso 2>/dev/null) ; do
        FILE_NS=$(echo "$FILE" | sed 's/ /_/g')
        FILES="$FILES $FILE_NS  $(file_size "$FILE" -h)  ($(file_image_size "$FILE" -h)) \n "
        #FILES="$FILES $FILE_NS  $(file_size "$FILE" -h)   \n "
    done

    printf $FILES | column  -t
    unset IFS
}


file_device(){
    MOUNT_POINT=$(df -a "$1" | sed 's/  */ /g' | grep -v Mounted | cut -d ' ' -f 6  )
    BLK_DEV=$(lsblk -n -l -p -o PKNAME,MOUNTPOINT,NAME | sed 's/  */ /g' | grep " $MOUNT_POINT " | cut -d " " -f 1)
    echo $BLK_DEV
}


file_fs_freespace() {
    local FILENAME=${1:-"."}  
    local FORMAT=${2:-"-B1"}   # -B1 for bytes    -h for humanreadable
    local FREESPACE
    
    if [ -d "$FILENAME" ]; then
        FREESPACE=$(df "$FILENAME" $FORMAT --output=avail | grep -v Avail)
        RC=$?
    else
        FREESPACE=$(df $(dirname "$FILENAME") $FORMAT --output=avail | grep -v Avail)
        RC=$?
    fi

    if (( $RC )) ; then
        return $RC
    fi
    
    echo $FREESPACE
}   


file_folder_size() {
    local FOLDER=$*
    # returns human readable
    
    if [ -d "$FOLDER" ] ; then
        sudo du -sh "$FOLDER" | cut -d'/' -f1 | sed 's/\s\s*/ /g'
        RC=$?
        if (( $RC )); then
            return $RC
        fi
    else
        echo 0
    fi
}


file_check_outfile(){
    # uses global variable OUTFILE
    # returns 0 if good
    
    #Quit if outfile is blank
    if [ -z "$OUTFILE" ] ; then
        ui_msg "ERROR 1" "File '$OUTFILE' can't be blank" "red"
        return 1
    fi  
    
    # Quit if path does not exist
    if [ ! -d  "$(file_path $OUTFILE)" ] ; then     
        ui_msg "Error 2" "Directory does not exist '$(file_path $OUTFILE)'" "red"
        return 2
    fi
    
    # add ext if missing
    if [ -z $(file_ext "$OUTFILE") ]; then
        echo "No extension specified.  Adding '.img.$DEFAULT_EXTENSION'"
        OUTFILE=$OUTFILE.img.$DEFAULT_EXTENSION
        #OUTFILE_EXT=$(file_ext $OUTFILE)
        echo "OUT-FILE='$OUTFILE'" 
    fi

    # insert .img if missing
    if [ "$(echo "$OUTFILE" | grep img)" = "" ] && [ "$(echo "$OUTFILE" | grep iso)" = "" ]; then
        echo "inserting .img"
        OUTFILE=$(file_path_base "$OUTFILE").img.$(file_ext "$OUTFILE")
        echo "OUT-FILE='$OUTFILE'" 
    fi

    # quit if unsupported extension
    if [ -z $(file_ext_ok "$OUTFILE") ]; then
        ui_msg "ERROR 3" "Unsupported file extension '$(file_ext $OUTFILE)'" "red"
        return 3 
    fi

    # Quit if outfile exists
    if  [ -f "$OUTFILE" ]  ; then
        ui_msg "ERROR 4" "File '$OUTFILE' already exists" "red"
        return 4
    fi 

    # Quit if OUTFILE_BASE.img exists
    if  [ -f "$(file_path_base $OUTFILE)".img ]  ; then
        ui_msg "ERROR 5" "File '$(file_path_base $OUTFILE).img' already exists" "red"
        return 5
    fi 
    
    # Quit if OUTFILE_BASE.img.ext exists
    if  [ -f "$(file_path_base $OUTFILE)".img.$(file_ext "$OUTFILE") ]  ; then
        ui_msg "ERROR 6" "File '$(file_path_base $OUTFILE).img.$(file_ext "$OUTFILE")' already exists" "red"
        return 6
    fi 
}


file_check_infile(){
    # quit if infile is blank
    if [ -z "$INFILE" ] ; then
        ui_msg "ERROR 1" "File '$INFILE' cannot be blank" "red"
        return 1
    fi 
    
    # quit if infile not found
    if  [ ! -f "$INFILE" ]  ; then
        ui_msg "ERROR 2" "File '$INFILE' not found" "red"
        return 2
    fi 
    
    # quit or warning if no img file found
    file_image_exists "$INFILE"
    if (( $? )); then
        ui_msg "ERROR 3" "No image file found in '$INFILE'" "red"
        return 3
    fi 
}

# -----------------------------------------------



do_list_info() {
    DIR=${1:-$PWD}
    echo "~~~ CURRENT SYSTEM ~~~"
    echo $PRODUCTNAME ver $SCRIPTVER
    echo $(cat /etc/os-release | grep "PRETTY_NAME=" | cut -d '"' -f2) hw=$(uname -m) kernel=$(uname -r)
    echo "Root device = /dev/$(env_root_device)"
    echo "Size      = $(media_size /dev/$(env_root_device) -h )"
    echo "FreeSpace = $(file_fs_freespace . -h)"
    echo "TrashSize = $(file_folder_size /home/$USER/.local/share/Trash)"
    echo "RootTrash = $(file_folder_size /root/.local/share/Trash)"
    echo
    #    echo "Default dir = '$DIR' - $(file_fs_freespace $DIR -h) free"  
    #echo "~~~ PiSafe LOCKED DEVICES ~~~"
    #echo "$(cat $CONFIG | grep "device_lock")"
    #echo
    echo
    echo "~~~ STORAGE MEDIA (hide root device = $HIDE_ROOT_DEVICE) ~~~"
    echo "$(media_list)"
    echo   
    echo
    echo "~~~ IMAGE FILES in '$DIR' ($(file_fs_freespace $DIR -h) free) ~~~"
    SAVED_PWD=$PWD
    cd $DIR  
    file_list_image_files
    cd $SAVED_PWD
}    



# --------------------------------------

do_install_lua(){
    # try to find a version of lua that will install
    # lua.org
    
    # see if lua is installed, fix if needed 
    LUA_VERS="lua lua5.4 lua5.3 lua5.2 lua5.1 lua54 lua53 lua52 lua51"
    for LUA_VER in $LUA_VERS; do
        1>/dev/null 2>/dev/null $LUA_VER -v 
        if [ $? = 0 ]; then  #  LUA_VER found
            #1>/dev/null lua -v
            lua -v 2>/dev/null
            if [ $? = 0 ]; then   # lua works, can return
              return
            else
                #crude patch for arch/manjaro  install is lua54 but goes to /usr/bin/lua5.4
                for LUA_TEST in "lua5.4 lua5.3 lua5.2 lua5.1"; do
                    if [ -f /usr/bin/$LUA_TEST ]; then
                        # this should probably should be an alias...
                        sudo cp /usr/bin/$LUA_TEST /usr/bin/lua
                        return
                    fi
                done
            fi
        fi
     done 
     
     
     # lua not found, try to install and fix   
     for LUA_VER in $LUA_VERS; do
        echo Trying to install $LUA_VER ...
        sudo $INSTALL $LUA_VER
        if (( $? )); then  # no error so LUA_VER installed
          # see if we need to fix lua
          1>/dev/null lua -v
          if (( $? )); then  # lua works, can return
       #     return
       #   else  # error so we need to fix it.
            #crude patch for arch/manjaro  install is lua54 but goes to /usr/bin/lua5.4
            for LUA_TEST in "lua5.4 lua5.3 lua5.2 lua5.1"; do
                if [ -f /usr/bin/$LUA_TEST ]; then
                    # this should probably should be an alias...
                    sudo cp /usr/bin/$LUA_TEST /usr/bin/lua
                    return
                fi
            done
          fi  
        fi
    done
    
    lua -v
}


pisafe_install_tools() {   
    TOOL_MISSING=false
    INSTALL=$(env_installer)  
    
    do_install_lua
    
    for TOOL in $REQUIRED_TOOLS ; do
        #if [ ! -f /usr/bin/$TOOL ]  && [ ! -f /usr/local/bin/$TOOL ] ; then
        if [ -z $(which $TOOL) ] ; then
            case $TOOL in
            
            xz)
                echo_white Instlling xz-utils...
                sudo $INSTALL xz-utils
                if [ ! -f /usr/bin/xz ]; then
                   ui_msg "Error" "xz not installed." "red" 
                fi
                ;;
            
            pishrink.sh)
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                sudo chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                if [ ! -f /usr/local/bin/pishrink.sh ] ; then
                  ui_msg "Error" "pishrink not installed." "red" 
                else
                  ui_msg  pishrink installed.
                fi
                ;;
            
            *)
                echo_white Installing $TOOL ...
                sudo $INSTALL $TOOL
                if (( $? )); then
                    ui_msg "Error" "$TOOL not installed." "red"
                fi
                ;;
            esac    
        fi
    done
}    


pisafe_write_log(){
    INFO=$*
    if [ $LOG = "on" ]; then
        touch $LOG_FILE
        echo "$(date "+%Y-%m-%d %H:%M"), $INFO" >> $LOG_FILE
    fi
}


pisafe_install(){
    SILENT=${1:-"-n"}
    
    if [ $SILENT != "-y" ]; then
        RESULT=$(ui_yesno "INSTALL" "Install $PRODUCTNAME $SCRIPTVER?")
        if [ $RESULT != "y" ]; then
            #echo
            ui_msg "NOTICE" "$PRODUCTNAME not installed"
            return
        fi
    fi
    
    pisafe_write_log "Installing $PRODUCTNAME v $SCRIPTVER"
    
    # Install the CLI script
    sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
    sudo chmod +x /usr/local/bin/$SCRIPTNAME
    echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)


    # download the icon
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/pisafe_icon.png -O pisafe_icon.png
    mv pisafe_icon.png /home/$USER/.config/pisafe/pisafe_icon.png

    
    # create the desktop file    
    TERMINAL1=$(env_terminal)
    echo "\
[Desktop Entry]
Type=Application
Terminal=false
Version=1.0
Name=$PRODUCTNAME
Comment=$PRODUCTCOMMENT
#Icon=rpi-imager
#Icon=media-removable
Icon=/home/$USER/.config/pisafe/pisafe_icon.png
#Exec=lxterminal --geometry=110x40 -e $SCRIPTNAME
Exec=$TERMINAL1 $SCRIPTNAME
Categories=Utility
StartupNotify=false" > "$PRODUCTNAME.desktop"   

    # for lxde, MATE and xfce put it in /usr/share/applications
    sudo mv "$PRODUCTNAME.desktop" "/usr/share/applications"
    # for just this user, put it in $HOME/.local/share/applications/
    #mv "$PRODUCTNAME.desktop" "$HOME/.local/share/applications/"

    if [ -f "/usr/local/bin/$SCRIPTNAME" ]; then 
        MSG="$PRODUCTNAME $SCRIPTVER installed.            
        \nSelect it from the 'Accessories' menu.
        \n\nOr you can execute it from any directory by typing '$SCRIPTNAME'."
        
        if [ $INTERFACE = "cli" ]; then
            MSG="$PRODUCTNAME $SCRIPTVER installed.  Select it from the 'Accessories' menu or you can execute it in a terminal window by typing '$SCRIPTNAME'."
        fi
        
        ui_msg  "INSTALL:" "$MSG" "white" "OK"
    else
        MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
        ui_msg  "INSTALL:" "$MSG" "white" "OK"
    fi
}


pisafe_update() {
    INTERFACE=${1:-"cli"}
    SUMMARY=${2:-"yes"}
    local YES=${3:-"-n"}
      
    local SERVER_VER=
    #rm $SCRIPTNAME.tmp
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/$SCRIPTNAME -O $SCRIPTNAME.tmp 2> /dev/null 
    RC=$?
    if (( $RC ));  then
        echo_if_cli "ERROR: Can't connect to server..."
        return $RC
    fi    

    # did we get the new version from the server?
    if [ -f $SCRIPTNAME.tmp ]; then
        SERVER_VER=$(bash $SCRIPTNAME.tmp -v)
    else
        return 1
    fi

    if [ $(get_ver_to_int $SERVER_VER) -gt $(get_ver_to_int $SCRIPTVER) ]; then
        if [ $YES = "-y" ]; then
            RESULT="y"
        else
            RESULT=$(ui_yesno "UPDATE AVAILABLE" "Update $PRODUCTNAME from '$SCRIPTVER'  to '$SERVER_VER' ")
        fi
        
        if [ $RESULT = "y" ]; then 
            sudo mv $SCRIPTNAME.tmp /usr/local/bin/$SCRIPTNAME
            sudo chmod +x /usr/local/bin/$SCRIPTNAME
            echo "$($SCRIPTNAME -v) installed. Press any key to exit... "
            read -n 1
            exit 0
        fi
    else  
        rm $SCRIPTNAME.tmp
        if [ $SUMMARY = yes ]; then
            ui_msg "UPDATE" "$PRODUCTNAME is up to date.  Server ver is '$SERVER_VER' "
        fi
    fi
}


pisafe_uninstall(){
    SILENT=${1:-"-n"}
    
    if [ $SILENT != "-y" ]; then
        RESULT=$(ui_yesno "UNINSTALL" "Uninstall $PRODUCTNAME")
        if [ $RESULT != "y" ]; then
            ui_msg "UNINSTALL" "$PRODUCTNAME not uninstalled"
            return
        fi
    fi
    
    pisafe_write_log "Uninstalling $PRODUCTNAME $INSTALLED_VER"
    
    # remove from the menu
    sudo rm -f "/usr/share/applications/$PRODUCTNAME.desktop"
    # next line cleans up an old configuration
    rm -f "$HOME/.local/share/applications/$PRODUCTNAME.desktop"
    
    # remove the script and config
    sudo rm -f "/usr/local/bin/$SCRIPTNAME"
    rm -f $CONFIG
    
    if [ ! -z "/usr/local/bin/$SCRIPTNAME" ]; then
        echo $PRODUCTNAME uninstalled
    fi
    
    ui_msg "UNINSTALL" "$LOG_FILE not removed" "white" "OK"
    #rm -f $LOG_FILE
}



# ---------- Media functions

media_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    RC=$?
    if (( $RC )); then
        echo 0
        return $RC
    fi
}


media_size() {
    local DEV=$1
    local HUMAN=${2:-"no"}
   
     # add '/dev/' if missing
    if [ "${DEV:0:5}" != "/dev/" ]; then
        #echo "Device prefix not specified.  Adding '/dev/'"
        DEV="/dev/"$DEV
    fi
   
    SIZE_BYTES=$(lsblk $DEV -d -n -b -o size  2> /dev/null)
    RC=$?
    if (( $RC )); then
        echo 0
        return $RC       
    fi
    
    if [ $HUMAN = "-h" ]; then
        echo $(get_bytes $SIZE_BYTES -h)
    else
        echo $SIZE_BYTES
    fi
    
    # an alternative way:
    # echo $(( $(sudo blockdev --getsize64 /dev/sda) ))
    # echo $(( $(sudo blockdev --getsize64 /dev/sda)/1024/1024 ))mb    
}


media_serialno(){
    local DEVICE=$1
    # currently vendor + SN
    SN=$(lsblk -n -d --output vendor,model,serial "$DEVICE" | sed 's/ /_/g' )
    echo $SN
}


media_check_indev(){
    #returns 0 if good
    # check INDEV
    
    # stop if indev is blank
    if [ -z $INDEV ] ; then
        ui_msg "ERROR 1" "IN-DEV '$INDEV' can't be blank" "red" "OK"
        return 1
    fi 
    
    # add '/dev/' if missing
    if [ "${INDEV:0:5}" != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        INDEV="/dev/"$INDEV
        echo "IN-DEV='$INDEV'"
    fi
    
    # Stop if INDEV does not exists
    if  [ ! -e $INDEV ]  ; then
        ui_msg "ERROR 2" "IN-DEV '$INDEV' not found" "red" "OK"
        return 2
    fi 
    
    # Warning if INDEV is root device
    if [ $INDEV = /dev/$(env_root_device) ]; then
        ui_msg "WARNING 3" "SD-card '$(media_name $INDEV)' is root device '/dev/$(env_root_device)'." "red" "OK"
    fi  
    
    # Warning if device filesystem has an overlay
    OVERLAY=$(media_os $INDEV | grep OVERLAY)
    if [ ! -z "$OVERLAY" ] && [ $AUTO_EXPAND_FS = on ]; then
        if [ $(ui_yesno "WARNING 4" "'$(media_name $INDEV)' filesystem has an overlay and cannot auto-expand. Turn off auto-expand?" ) = "y" ]; then
			AUTO_EXPAND_FS=off
			ui_msg "WARNING 4" "Auto-expand turned off" "red" "OK"
		fi
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(media_size $INDEV) -gt 16000000000 ]; then
        MESG=" '$(media_name $INDEV)' is larger than 16GB.  \
         \n\nUse a smaller SD card if you can.  \
         \nIt will be faster because the entire SD card must be read before it can be compressed.\
         \n\nA good 8gb card with RaspiOS in a Raspberry Pi 4 takes about 10 minutes"
         ui_msg "WARNING 4" "$MESG" "red" "OK"
    fi
    
    # Warning if SD-card is bigger than freespace
    if [ $(media_size $INDEV) -gt $(file_fs_freespace "$DEFAULT_PATH") ]; then
        MSG="Not enough free space on '$DEFAULT_PATH' 
         \n\n'$(media_name  $INDEV)' is $(media_size $INDEV -h)
         \nfreespace on '$DEFAULT_PATH' is $(file_fs_freespace "$DEFAULT_PATH" -h)
         \n\nBe sure to specify a different drive" 
         ui_msg "ERROR 5" "$MSG" "red" "OK"
    fi
    
    # Warning if one and a half times the SD-card is bigger than freespace
    SPACENEEDED=$(( $(media_size $INDEV) + $(( $(media_size $INDEV) / 2 )) ))
    if [ $SPACENEEDED -gt $(file_fs_freespace "$DEFAULT_PATH") ]; then
        MSG="Might not be enough free space on '$DEFAULT_PATH'
            \n\n'$(media_name $INDEV)' is $(media_size $INDEV -h)
            \nfreespace on '$DEFAULT_PATH' is $(file_fs_freespace "$DEFAULT_PATH" -h)
            \nThere is $(file_folder_size /home/$USER/.local/share/Trash) in the Trash" 
        ui_msg "WARNING 6" "$MSG" "red" "OK"
    fi
}


media_check_outdev(){
    # quit if outdev is blank
    if [ -z $OUTDEV ]; then
        ui_msg "ERROR 1" "Device '$OUTDEV' cannot be blank" "red"
        return 1
    fi
    
    # Add '/dev/' if missing
    if [ ${OUTDEV:0:5} != "/dev/" ]; then
        echo_if_cli "Device prefix not specified.  Adding '/dev/'"
        OUTDEV="/dev/"$OUTDEV
        echo_if_cli "OUT-DEV='$OUTDEV'"
    fi
    
    # Quit if OUTDEV is not found
    if  [ ! -e $OUTDEV ]  ; then
        ui_msg "ERROR 2" "Device '$OUTDEV' not found" "red"
        return 2
    fi 
           
        
    VENDOR=$(lsblk -n -d --output vendor /dev/sda)
    SERIAL=$(lsblk -n -d --output serial /dev/sda)
    
    #stop if outdev is piSave-locked
    if [ $(config_var_get device_lock_$(media_serialno $OUTDEV) $CONFIG) = "on" ]; then
        ui_msg "RESTORE ERROR " "Device '$(media_serialno $OUTDEV)' is locked by PiSafe in the config file" "red"
        return 1
    fi
    
    # Stop if outdev is the root device
    if [ $OUTDEV = /dev/$(env_root_device) ]; then
        ui_msg "RESTORE ERROR" "Restore to root device not allowed" "red"
        return 1
    fi
    
    #stop if INFILE is on OUTDEV
    if [ "$(file_device "$INFILE")" = $OUTDEV ]; then
        ui_msg "RESTORE ERROR" "Restore to same device as '$INFILE' not allowed" "red"
        return 1
    fi
    
    # Warning if device is large
    if [ $(media_size $OUTDEV) -gt $LARGE_DEVICE_WRITE_WARNING ]; then
        ui_msg "RESTORE WARNING" "'$(media_name $OUTDEV)' 
        \nis larger than $(get_bytes $LARGE_DEVICE_WRITE_WARNING -h)... 
        \n\nBe sure this is the right device" "red" "OK"
    fi
     
    # Stop if imagefile is larger than device
    if [ $(file_image_size "$INFILE") -gt $(media_size $OUTDEV) ]; then
        ui_msg "RESTORE ERROR" "Not enough room
        \nThe image in '$INFILE' is ' $(file_image_size "$INFILE" -h)' 
        \nand '$OUTDEV' is only '$(media_size $OUTDEV -h)'" "red"
        return 1
    fi
}


media_backup(){
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img
    
    local INDEV=$1
    OUTFILE=$2
    local SAFETY=${3:-on}   # off lets us bypass some of the safety prompts
    INTERFACE=${4:-cli}  #CLI or gui
   
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Backup...
    echo "IN-DEV='$INDEV'"
    echo "OUT-FILE='$OUTFILE'"
    echo  "Compression set to level $COMPRESSION of 9"
    pisafe_write_log "Starting $PRODUCTNAME $SCRIPTVER Backup, '$INDEV' '$(media_name $INDEV)', '$OUTFILE', Compression=$COMPRESSION"
      
    if [ $INTERFACE = "cli" ]; then
        media_check_indev
        RC=$?
        if (( $RC )); then
            return $RC
        fi     
        
        file_check_outfile   
        RC=$?
        if (( $RC )); then
            return $RC
        fi  
    fi    
    
    # should be able to delete this...
    # Final check before writing data
    if [ -z $INDEV ] || [ ! -e $INDEV ] ; then
        echo
        echo_red "ERROR b1: IN-DEV '$INDEV' must exist. "
        return 1
    fi 
    
    if [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] ; then
        echo
        echo_red "ERROR b2: OUT-FILE '$OUTFILE' can't exist. "
        return 2
    fi  

    #################################################
    # this section writes the data
    #################################################
    OUTFILE_BASE=$(file_path_base "$OUTFILE" )

    TIME1=$(date +%s)
    echo_white "Step 1 of 3 - Reading  '$INDEV' to '$OUTFILE_BASE.img' ... "
    date
    
    BS=$(( 4 * 1024 * 1024 ))
    BLOCKS_TO_READ=$(( $(media_size $INDEV) / $BS ))
    
    
	# new section #######  
	if [ $SKIP_FREESPACE = "on" ]; then

		START_OF_FREESPACE=$(sudo parted -ms "$INDEV" unit B print free)
		RC=$?
		if (( $RC )); then
			error $LINENO "parted failed with rc $RC"
			exit 15
		fi
		START_OF_FREESPACE=$(tail -1 <<< "$START_OF_FREESPACE" | grep free | cut -d ':' -f 2 | tr -d 'B')
		if ! (( $START_OF_FREESPACE )); then 
			START_OF_FREESPACE=$(media_size $INDEV)
		fi

		BYTES_TO_READ=$START_OF_FREESPACE
		BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1))

		echo Media size=$(media_size $INDEV -h)
		echo Skipping $(get_bytes $(( $(media_size $INDEV) - $START_OF_FREESPACE )) -h ) of freespace at end.
		echo Reading=$(get_bytes $START_OF_FREESPACE -h)

	else
	  BYTES_TO_READ=$(media_size $INDEV)
	  BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1))

	fi    
	#end of new section    
    
    
    #sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img status=progress conv=fsync 
    MEDIA_SIZE=$(sudo lsblk -ndb $MEDIA -o size)
    if [ ! -z $(which pv) ]; then
		sudo pv $INDEV -s $BYTES_TO_READ $DEVICE | dd bs=$BS of="$OUTFILE_BASE".img count="$BLOCKS_TO_READ" iflag=fullblock conv=fsync 
		RC=$?
    else
      echo "Note: 'pv' is not installed so there is no progress indicator for this step. Please wait..."
      sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img  conv=fsync 
      RC=$?
    fi
    if (( $RC )); then
        return $RC
    fi
    
    sleep 5s
    echo "Done reading device '$INDEV'"
    echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
    TIME2=$(date +%s)  
    echo_white Step 1 took $(get_elapsed_time $TIME1 $TIME2)
    echo
   
   
    if [ ! $(file_ext "$OUTFILE") = "iso" ]; then 
        echo_white "Step 2 of 3 - Shrinking filesystem ..."
        PI_SHRINK_OPTS=

        if [ $AUTO_EXPAND_FS = "off" ] ; then 
            PI_SHRINK_OPTS="-s"
        fi
        if [ $SHRINK_FS != "off" ]; then
            sudo pishrink.sh $PI_SHRINK_OPTS "$OUTFILE_BASE".img
            RC=$?
            if (( $RC )); then
                echo Continuing without shrinking file system
            fi
        else
            echo "Filesystem not shrunk.  Setting is 'off'."
        fi
        # sleep to allow the file size to register with the OS
        sleep 5
        echo Done shrinking filesystem.
        echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
        TIME3=$(date +%s)
        echo_white Step 2 took $(get_elapsed_time $TIME2 $TIME3)
    fi
    
    echo
    echo_white "Step 3 of 3 - Compressing '$OUTFILE_BASE.img' to '$OUTFILE' ... "
    date
    echo Compression set to level $COMPRESSION of 9
    echo "$(file_size $OUTFILE_BASE.img -h) to compress."
    
    case $(file_ext "$OUTFILE") in
        img)
            echo Not compressing .img file ...
            ;;
        
        iso)
            echo Not compressing .iso file ...
            mv $OUTFILE_BASE.img $OUTFILE_BASE.iso
            RC=$?
            ;;
        
        zip)
            local FILESIZE_M=$(( $(file_size "$OUTFILE_BASE".img)/1024/1024 ))
            local DOTSIZE=$(( $FILESIZE_M / 50 ))m
            echo Each dot=$DOTSIZE 
            echo -n "                      $OUTFILE_BASE.img"
            echo "...........25...........50...........75..........100%"
            zip -dbds $DOTSIZE -m -$COMPRESSION "$OUTFILE" "$OUTFILE_BASE".img
            RC=$?
            
            #warning, with progress bar it loses .img in the image name
            #sudo pv "$OUTFILE_BASE".img | sudo zip -$COMPRESSION  > "$OUTFILE"
            #EXIT_CODE=$? 
            #sudo rm -f "$OUTFILE_BASE".img 
            ;;
        
        xz)
            #sudo xz -z -v -T0 -$COMPRESSION "$OUTFILE_BASE".img
            #EXIT_CODE=$?     
            ##OUTFILE="$OUTFILE_BASE".img.xz
            ##sudo mv "$OUTFILE_BASE".img.xz "$OUTFILE"  
            
            # With progress bar
          #  if [ ! -z $(which pv) ]; then
				pv "$OUTFILE_BASE".img | xz -z -c -T0 -$COMPRESSION > "$OUTFILE"
				RC=$? 
		#	else
        #        sudo xz -z -v -T0 -$COMPRESSION "$OUTFILE_BASE".img
        #        RC=$? 
	#		fi	
            rm -f "$OUTFILE_BASE".img
            ;;
        
        gz)
            #echo $(file_size "$OUTFILE_BASE".img -h) to compress.  Sorry, gz has no progress bar.   Please wait...
            #sudo pigz -v -$COMPRESSION "$OUTFILE_BASE".img
            #EXIT_CODE=$?        
            #sudo mv "$OUTFILE_BASE".img.gz "$OUTFILE"
            #OUTFILE="$OUTFILE_BASE".img.gz

            # With progress bar
            pv "$OUTFILE_BASE".img | pigz -$COMPRESSION > "$OUTFILE"
            RC=$? 
            rm -f "$OUTFILE_BASE".img
            ;;
        
        *)
            echo
            #echo_red ERROR... unsupported file extension \'$(file_ext "$OUTFILE")\'.
            ui_error $LINENO "Unsupported file extension '$(file_ext "$OUTFILE")'"
            return 1
            ;;
    esac
    
    if (( $RC )); then
        return $RC
    fi
    
    echo "Done compressing '$OUTFILE_BASE.img' to '$OUTFILE' "
    echo_white $(ls -s -h "$OUTFILE")
    TIME4=$(date +%s)
    echo_white  Step 3 took $(get_elapsed_time $TIME3 $TIME4)
    
    
    # check if "$OUTFILE" was created
    if [ ! -f "$OUTFILE" ]; then
        echo
        echo_red "ERROR: creating '$OUTFILE'"
        return 1
    fi    
    
    
    if [ $RC != 0 ]; then
        echo
        echo_red  "ERROR. $RC"
        pisafe_write_log "FAILED $PRODUCTNAME $SCRIPTVER Backup, IN-DEV='$INDEV',  OUT-FILE='$OUTFILE', Compression set to level $COMPRESSION"
        return $RC
    else
        do_beep
        echo_white "Backup done. '$INDEV' backed up to '$OUTFILE' in $(get_elapsed_time $TIME1 $TIME4)." 
        pisafe_write_log "Finished $PRODUCTNAME $SCRIPTVER Backup,  $(media_size $INDEV -h) to  $(file_size "$OUTFILE" -h) in $(get_elapsed_time $TIME1 $TIME4) " 
    fi
}


media_restore(){
    local INFILE=$1
    local OUTDEV=$2
    local SILENT=${3:-"-n"}   # this lets us bypass some of the safety prompts
    INTERFACE=${4:-cli}  #CLI or gui

    echo_white Starting $PRODUCTNAME $SCRIPTVER Restore...
    echo "IN-FILE='$INFILE'"
    echo "OUT-DEV='$OUTDEV'"
    echo "Safety='$SAFETY'"
    pisafe_write_log "Starting $PRODUCTNAME $SCRIPTVER Restore, '$INFILE', '$OUTDEV' '$(media_name $OUTDEV)'"
 
    if [ $SILENT != "-y" ]; then
        file_check_infile
        RC=$?
        if (( $RC )); then
            return $RC
        fi
    
        media_check_outdev
        RC=$?
        if (( $RC )); then
            return $RC
        fi
    fi

    # Final check before writing data
    # quit if INFILE is not a file
    if [ -z "$INFILE" ] || [ ! -e "$INFILE" ]; then
        echo
        echo_red "ERROR r1: IN-FILE '$INFILE' must exist."
        return 1
    fi 
    
    #quit if OUTDEV is not a device
    if [ -z $OUTDEV ] || [ ! -e $OUTDEV ]; then
        echo
        echo_red "ERROR r2: OUT-DEV '$OUTDEV' must exist."
        return 1
    fi
    
    if [ $SILENT != "-y" ]; then
        echo
        echo "Write '$INFILE' to '$OUTDEV' '$(media_name $OUTDEV)' ?"
        echo_red WARNING... All existing data on \'$OUTDEV\' - will be erased!
        do_beep
        read  -p "You must type 'YES' to continue:" -r RESULT
        echo
    
        if [ -z $RESULT ] || [ $RESULT != "YES" ]; then
            echo "You did not answer 'YES'"
            return 1
        fi
        
        do_beep
        echo_red "WARNING '$OUTDEV' '$(media_name $OUTDEV)' "
        echo_red "Will be overwritten starting in 10 seconds ... Ctrl-C to stop"
        do_countdown 10
    fi
    
    #################################################
    # this section writes the data
    #################################################

    echo_if_cli Unmounting SD-card $OUTDEV ...
    umount $OUTDEV?  2> /dev/null
    
    local INFILEEXT=$(file_ext "$INFILE")
    
    echo_if_cli "Erasing MBR, signature, and partition table from '$OUTDEV'..." "white"
	sudo dd if=/dev/zero of=$OUTDEV bs=512 count=2 > /dev/null
    
    echo        
    echo_white "Writing '$INFILE' to '$OUTDEV' ... "    
    date
    TIME1=$(date +%s)
    echo_if_cli "$(file_image_size "$INFILE" -h) to write"
    
    case $INFILEEXT in
        img | iso)
            if [ $INTERFACE = "cli" ]; then
                #sudo dd if="$INFILE" of=$OUTDEV bs=4M conv=fsync status=progress
                pv "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync
                RC=$?
            else
                (sudo pv -n "$INFILE" | sudo dd of=$OUTDEV bs=4M) 2>&1 | \
                whiptail --backtitle "$BACKTITLE" --title "RESTORE" --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                RC=$?
            fi
            ;;
        
        zip)
            RESTORE_BYTES=$(file_image_size "$INFILE")
             if [ $INTERFACE = "cli" ]; then
                 #unzip -p "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 #pv "$INFILE" | unzip -p | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 unzip -p "$INFILE" | pv -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M conv=fsync
                 RC=$?
            else
                (unzip -p "$INFILE" | pv -n -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M) 2>&1 | \
                whiptail --backtitle "$BACKTITLE" --title "RESTORE" --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                 RC=$?
            fi
            ;;
        
        xz)
            if [ $INTERFACE = "cli" ]; then
                 #xz -v -d -c "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 pv "$INFILE" | xz -d -c | sudo dd of=$OUTDEV bs=4M conv=fsync
                 RC=$?
            else
                (sudo pv -n "$INFILE" | xz -d -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | \
                whiptail --backtitle "$BACKTITLE" --title "RESTORE" --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                RC=$?
            fi
            ;;

        gz)
            if [ $INTERFACE = "cli" ]; then
                #pigz -v -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                pv "$INFILE" | pigz -d -k -c | sudo dd of=$OUTDEV bs=4M conv=fsync
                RC=$?
            else
                (pv -n "$INFILE" | pigz -d -k -c | sudo dd of=$OUTDEV bs=4M conv=fsync) 2>&1 | \
                whiptail --backtitle "$BACKTITLE" --title "RESTORE" --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                RC=$?
            fi    
            ;;

        *)
            echo
            echo_red ERROR.  Unsupported file extension. 
            return  1 
            ;;

    esac        
    TIME2=$(date +%s)
    echo
    
    if (( $RC )); then
        echo
        do_beep_down  
        #echo_red  "ERROR. $RC"
        error $LINENO "Error restoring. RC=$RC"
        pisafe_write_log "Restore failed $RC"
        return $RC
    else
          
        #do_beep
        do_beep_up
        echo_white "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
        pisafe_write_log "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
    fi
}


media_list() {
    HIDE_ROOT_DEVICE_OVERRIDE=$1    # y n or blank
    local DEVICES= 
   
    case $HIDE_ROOT_DEVICE_OVERRIDE in
        y)      ROOT_FILTER=$(env_root_device) ;;
        
        n)      ROOT_FILTER="aspodiausdfpoiasdf" ;;
        
        *)     if [ $(config_var_get hide_root_device $CONFIG) = "on" ]; then
                    ROOT_FILTER=$(env_root_device)
                else    
                    ROOT_FILTER="aspodiausdfpoiasdf"
                fi   
                ;;
    esac
    
       
    DEVICES=$(lsblk -I 8,179 -dnpo NAME,VENDOR,MODEL,SIZE 2> /dev/null | grep -v $ROOT_FILTER)
    RC=$?
    if (( $RC )); then
        return $RC
    fi
    
    echo "${DEVICES[@]}"
}


media_details(){
    local MEDIA=$1
    local MSG=
    MSG="Media: '$(media_name $MEDIA)' \n"
    echo "Serching for OSs..."
    MSG=$MSG"$(media_os $MEDIA)"
    echo "Calculating backup estimates..."
   # MSG="$(media_backup_estimate  $INDEV)"
    MSG="$MSG\n\n$(media_backup_estimate  $MEDIA)"
    MSG="$MSG\n\n===== PARTITION TABLE DETAILS ===== \n$(sudo parted -s $MEDIA print free) \n\n"
    MSG="$MSG$(lsblk $MEDIA -o maj:min,fssize,fsused,fsavail,fsuse%)\n\n"
    
    ui_msg "MEDIA DETAILS" "$MSG"
}


media_partition_info() {
	local MEDIA=$1
	local PARTITION=$2
	
	local PARTED_OUTPUT=
	local PARTSTART=
	local LOOPBACK=
	local MOUNTDIR=
	
	local OS=
	local ARCH=
	local BITS=
	local READONLY=
	local OVERLAY=
 
  
    PARTED_OUTPUT=$(sudo parted -ms "$MEDIA" unit B print)
    if (( $? )); then
      return 1
    fi	

    # mount the filesystem
    PARTSTART="$(echo "$PARTED_OUTPUT" | grep ^$PARTITION: | cut -d ':' -f 2 | tr -d 'B')"
    LOOPBACK="$(sudo losetup -f --show -o "$PARTSTART" "$MEDIA")"
    if (( $? )); then
      echo ...retrying...
      sleep 2
      LOOPBACK="$(sudo losetup -f --show -o "$PARTSTART" "$MEDIA")"
       if (( $? )); then
         return 3
       fi  
    fi
    MOUNTDIR=$(mktemp -d)
    sudo mount "$LOOPBACK" "$MOUNTDIR"
    if (( $? )); then
      sudo losetup -d "$LOOPBACK"
      return 4
    fi

  
    # look for OS name and architecture
    if [ -e $MOUNTDIR/etc/os-release ]; then
      OS="$(cat $MOUNTDIR/etc/os-release | grep PRETTY_NAME | cut -d= -f2)"
      ARCH="$(file $MOUNTDIR/bin/bash | cut -d, -f2)"
      BITS="$(file $MOUNTDIR/bin/bash | cut -d, -f1)"
      if  [ !  -z "$(echo "$BITS" | grep 32 )" ]; then
        BITS=32
      elif [ !  -z "$(echo "$BITS" | grep 64 )" ]; then
        BITS=64
      fi
      if [[ ! "$ARCH" =~  "$BITS" ]]; then
        ARCH=$ARCH"-"$BITS
      fi  
      OS="$OS '$ARCH'" 
    fi
    
    
    # look for windows
    if [ -e $MOUNTDIR/Windows ]; then
      OS="'Windows'"
    fi
    
    
	# look for read-only partition (may not be needed)
	if [ -e $MOUNTDIR/etc/fstab ]; then
      ROOTREADONLY="$(cat $MOUNTDIR/etc/fstab | grep /boot | grep ,ro )"
      if [ ! -z "$ROOTREADONLY" ] ; then
		ROOTREADONLY="(READONLY)"
      fi
    fi
  

	# look for overlay file system
	if [ -e $MOUNTDIR/cmdline.txt ]; then
		# OVERLAY="$(cat $mountdir/config.txt | grep ^dtoverlay=vc4-fkms )"
		OVERLAY="$(cat $MOUNTDIR/cmdline.txt | grep boot=overlay )"
		if [ ! -z "$OVERLAY" ]; then
		    OVERLAY="(OVERLAY)"
		fi
	fi	

	# unmount fs and cleanup
	sudo umount "$MOUNTDIR"	
	sudo losetup -d "$LOOPBACK"

	echo "$OS$OVERLAY$ROOTREADONLY"
}


media_os() {
    local MEDIA=$1
    local MSG=

    PARTED_OUTPUT=$(sudo parted -ms $MEDIA print)  # no freespace
    #  MEDIA_PARTITION_TABLE=$(echo "$PARTED_OUTPUT" | head -n 2 | tail -n 1 | cut -d: -f6)   # msdos, gpt, other
    #  MEDIA_PARTITION_COUNT=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1 | wc -l)
    MEDIA_PARTITIONS=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1)

    # echo Looking for operating systems on partitions...
    for PARTITION in $MEDIA_PARTITIONS; do
        OS=$(media_partition_info $MEDIA $PARTITION)
        RC=$?
        if [ $RC = 0 ] && [ ! "xx$OS" = "xx" ] ; then
            echo " - $OS found on Partition $PARTITION"
        fi
    done
}


media_mount(){
    MEDIA=$1
    PARTED_OUTPUT=$(sudo parted -ms $MEDIA print)  # no freespace
    MEDIA_PARTITIONS=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1)
    
    for PARTITION in $MEDIA_PARTITIONS; do
        udisksctl mount -b $MEDIA$PARTITION
        if (( $? )); then
            echo error mounting $MEDIA$PARTITION
        fi
    done
}


media_power_off(){
    MEDIA=$1
    umount $MEDIA?
    udisksctl power-off $MEDIA
    #sudo eject -s $MEDIA
}


media_backup_estimate() {
    local MEDIA=$1
    local MSG=

    if [ ! -e $MEDIA ]; then
        MSG="Error: Media '$MEDIA' does not exist"
        return 1
    fi

    MEDIA_SIZE=$(sudo lsblk -ndb $MEDIA -o size)
    PARTED_OUTPUT=$(sudo parted -ms $MEDIA print)  # no freespace
    MEDIA_PARTITION_TABLE=$(echo "$PARTED_OUTPUT" | head -n 2 | tail -n 1 | cut -d: -f6)   # msdos, gpt, other
    MEDIA_PARTITION_COUNT=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1 | wc -l)
    MEDIA_PARTITION_LIST=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1)
    MEDIA_LAST_PARTITION_NUMBER=$(echo "$PARTED_OUTPUT" | tail -1 | cut -d: -f1)

    case $MEDIA in
        /dev/sd*)
            MEDIA_LAST_PARTITION_NAME=$MEDIA$MEDIA_LAST_PARTITION_NUMBER
            ;;

        /dev/mmcblk*|/dev/nvme*)
            MEDIA_LAST_PARTITION_NAME=$MEDIA"p"$MEDIA_LAST_PARTITION_NUMBER
            ;;
    esac

    PARTED_OUTPUT=$(sudo parted $MEDIA unit B print free )

    MEDIA_FREESPACE_AT_END=$(echo "$PARTED_OUTPUT" | tail -1 | grep Free | sed 's/[ ]\+/ /g' | cut -d " " -f 4 | tr -d 'B' )
    if [ -z $MEDIA_FREESPACE_AT_END ]; then
        MEDIA_FREESPACE_AT_END=0
    fi


 #   case $MEDIA_PARTITION_TABLE in
 #       msdos)
 #           MEDIA_LAST_PARTITION_TYPE=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f6)
 #           MEDIA_LAST_PARTITION_FS=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f7)
 #           ;;
 #       gpt)
 #           MEDIA_LAST_PARTITION_TYPE=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f7)
 #           MEDIA_LAST_PARTITION_FS=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f6)
 #           ;;
 #       *)
 #           ;;
 #   esac	

    if [ -z "$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | grep primary)" ]; then
        MEDIA_LAST_PARTITION_TYPE=logical
    else
        MEDIA_LAST_PARTITION_TYPE=primary
    fi

    MEDIA_LAST_PARTITION_FS=$(lsblk -no FSTYPE $MEDIA$MEDIA_LAST_PARTITION_NUMBER  )

    MSG=$MSG"\n===== MEDIA BACKUP ESTIMATES ===== \n"
    MSG=$MSG"Media size                         =  $(get_bytes $MEDIA_SIZE -h)\n"


    #1 - free space
    MSG=$MSG$(printf '%-35.34s' "Remove '$(get_bytes $MEDIA_FREESPACE_AT_END -h)' of freespace")
    MSG=$MSG"=> $(get_bytes $(($MEDIA_SIZE - MEDIA_FREESPACE_AT_END )) -h ) \n"


    # 2 - is it a complex file system?
    if [ $MEDIA_PARTITION_COUNT -gt 3 ]; then
        MSG=$MSG"Warning: Partitions=$MEDIA_PARTITION_COUNT.  This looks like a complex partition structure and may not shrink. Pisafe will still work.\n"
    fi

  
    # 3 - ext and not logical?
    SHRINK_BYTES=0
    UNCOMPRESSED_BYTES=0
    case $MEDIA_LAST_PARTITION_FS in
        ext4|ext3|ext2)
        
#ui_msg note "'$MEDIA_PARTITION_TABLE'"
#ui_msg note "'$MEDIA_LAST_PARTITION_TYPE'"  
        
            if [ "$MEDIA_PARTITION_TABLE" = "gpt" ] || ( [ "$MEDIA_PARTITION_TABLE" = "msdos" ] && [ "$MEDIA_LAST_PARTITION_TYPE" = "primary"  ] ) ; then
                SHRINK_BYTES=$(sudo lsblk $MEDIA -lpbo name,fsavail | grep $MEDIA_LAST_PARTITION_NAME | sed 's/^[[:blank:]]*//;s/[ ]\+/ /g'  | cut -d " " -f2)
            else
                MSG=$MSG"Warning: The last partition type is '$MEDIA_LAST_PARTITION_TYPE'. This partition-type will not shrink and cannot be restored to a smaller media. Pisafe will still work.\n"
            fi
            ;;

        *)
            MSG=$MSG"Warning: The last partition fs is '$MEDIA_LAST_PARTITION_FS'. This filesystem will not shrink and cannot be restored to a smaller media. Pisafe will still work.\n"
            ;;
    esac
  
    if [ -z $SHRINK_BYTES ]; then
        SHRINK_BYTES=0
    fi
    

    # 4 Shrink Filesystem  
    UNCOMPRESSED_BYTES=$(( $MEDIA_SIZE - $MEDIA_FREESPACE_AT_END - $SHRINK_BYTES ))
    MSG=$MSG$(printf '%-35.34s' "Shrink filesystem by $(get_bytes $SHRINK_BYTES -h) ")
    MSG=$MSG"=> $(get_bytes $UNCOMPRESSED_BYTES -h) \n"


    # 5 Compression
    MSG=$MSG"Estimated compression 2:1          => $(get_bytes $((UNCOMPRESSED_BYTES / 2 )) -h) \n"

    echo "$MSG"
}


media_checkfilesystem_e2() {
    local PARTITION=$1
	echo "Checking filesystem..."
	e2fsck -pf "$PARTITION"
	(( $? < 4 )) && return

	info "Filesystem error detected!"

	info "Trying to recover corrupted filesystem"
	e2fsck -y "$PARTITION"
	(( $? < 4 )) && return

if [[ $repair == true ]]; then
	info "Trying to recover corrupted filesystem - Phase 2"
	e2fsck -fy -b 32768 "$PARTITION"
	(( $? < 4 )) && return
fi
	error $LINENO "Filesystem recoveries failed. Giving up..."
	exit 9
}


media_format(){
    local DEVICE=$1
    local FORMAT=${2:-"fat32"}    # fat32, ntfs, ext4
    local SILENT=${3:-"-n"}
    
    local ROOT="/dev/$(env_root_device)"
    local TYPE=$(lsblk $DEVICE -dnpo TYPE)
    local NAME="$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE) ($DEVICE)"
    local PART1=$DEVICE\1
    

    if [ -z $1 ] ; then
        echo "Error 1: Device not specified, choose:"
        lsblk -dp
        return 1
    fi

    if [ ! -e $DEVICE ]; then
      echo "Error 2: $DEVICE does not exist"
      return 2
    fi

    if [ $1 = $ROOT ] ; then
        echo "Error 3: Can not format root device"
        return 3
    fi
    
    if  [ $TYPE != disk ]; then
        echo "Error 4: $DEVICE is not a disk"
        return 4
    fi
    
    if [ $SILENT != "-y" ]; then
        RESULT=$(ui_yesno "ERASE" "WARNING!!  \n\nFormat '$DEVICE' to '$FORMAT' \n\nAll existing data on '$NAME' will be erased.  \n\nAre you sure you want to continue? y/n?" "--defaultno")
        if [ $RESULT != "y" ]; then
            ui_msg "ERASE" "$DEVICE not erased"
            return
        fi
    fi
 
    echo_white "Formatting '$DEVICE' to '$FORMAT'..."

    ui_countdown 10 "" "Erasing Media '$(media_name $DEVICE)' in 10 seconds...\n\n"
    if (( $? )); then
        return 2
    fi

    echo "Unmounting '$DEVICE'..."
    #udisksctl unmount -b "$DEVICE"1
    #udisksctl unmount -b "$DEVICE"2
    #udisksctl unmount -b "$DEVICE"3
    umount $DEVICE? 2> /dev/null

    echo "Writing zeros to '$DEVICE'..."
    sudo dd if=/dev/zero of=$DEVICE bs=512 count=4
    if (( $? != 0 )); then
        echo "Error 9: writing zeros failed"
        return 9
    fi

    if [ $FORMAT = "fat32" ]; then
        PART_TABLE=msdos
    else
        PART_TABLE=gpt
    fi
    echo "Writing new '$PART_TABLE' partition table to '$DEVICE'..."
    sudo parted -s $DEVICE mklabel $PART_TABLE
    if (( $? != 0 )); then
        echo "Error 10: mklabel failed"
        return 10
    fi

    echo "Creating '$PART_TYPE' partition on '$DEVICE'..."
    sudo parted -s -a opt $DEVICE mkpart primary $PART_TYPE 4M 100%
    if (( $? != 0 )); then
        echo "Error 11: mkpart failed"
        return 11
    fi

    echo "Formatting the partition to '$FORMAT'..."

    case $FORMAT in
        fat32)
            sudo mkfs.vfat -n FAT32 $PART1
            EC=$?
            ;;
        
        ntfs)
            sudo mkfs.ntfs -f -L NTFS $PART1
            EC=$?
            ;;
        
        ext4)
            sudo mkfs.ext4 -L EXT4 -E root_owner=$UID:$GID -F $PART1
            EC=$?
            ;;
            
        exfat)
            #https://unix.stackexchange.com/questions/61209/create-and-format-exfat-partition-from-linux
            sudo apt-get install exfat-utils exfat-fuse
            sudo modprobe fuse 
            #run_command "sudo mkfs.exfat -n EXFAT $PART1" $LINENO
            sudo mkfs.exfat -n EXFAT $PART1
            EC=$?
   
            ;;        
            
    esac

    if (( $EC != 0 )); then
        echo "Error 12: mkfs failed"
        return 12
    fi

    echo "Mounting the drive..."
    sleep 2
    udisksctl mount -b  "$DEVICE"1
    if (( $? != 0 )); then
        echo "Error 13: mount failed"
        return 13
    fi
    echo

    #echo Partition Table ...
    #sudo parted "$DEVICE" print
    #sleep 5

    ui_msg "ERASE MEDIA" "'$NAME' ($DEVICE) has been erased. \n\nIt has been remounted."
}









########  MENU  FUNCTIONS ######################

menu_set_compression(){
    CHOICE=$(whiptail --title "SETTINGS-COMPRESSION" --radiolist \
    "Choose compression level (your milage may vary)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
    "1" "Fastest time (default)" on \
    "2" "" off \
    "3" "" off \
    "4" "" off \
    "5" "" off \
    "6" "" off \
    "7" "" off \
    "8" "" off \
    "9" "Smallest file (MUCH slower)" off   3>&1 1>&2 2>&3 )
   
    if [ ! -z $CHOICE ]; then
        COMPRESSION=$CHOICE
        config_var_set compression_level $CHOICE $CONFIG
    fi
}

    
menu_settings_default_path(){
    MSG="Enter new default path   '$DEFAULT_PATH'"
    TEMP_PATH="$DEFAULT_PATH"
    while true; do
        NEWPATH=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$TEMP_PATH" 3>&1 1>&2 2>&3)
        RC=$?
        if (( $RC )); then
            return $RC
        fi
        
        if [ ! -z $NEWPATH ]; then
        
            if [ -d $NEWPATH ]; then
                DEFAULT_PATH=$(echo "$NEWPATH" | sed 's/[/\t]*$//')
                config_var_set default_path $DEFAULT_PATH $CONFIG
                return 0
            else
                #whiptail --title ERROR --msgbox "ERROR Directory '$NEWPATH' does not exist" $WT_MB_HEIGHT $WT_MB_WIDTH
                ui_msg "ERROR" "ERROR Directory '$NEWPATH' does not exist"
                TEMP_PATH="$NEWPATH"
            fi
        
        fi
    done
}


menu_settings_default_extension(){
     CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS-EXTENSION" --radiolist \
            "Choose default extension (compression format)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "zip" "Default" on \
            "xz" "~25% smaller, 3x-4x more time" off \
            "gz" "~25% faster, same size as zip" off  \
            "img" "Twice the size, half the time (No compression)" off 3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        DEFAULT_EXTENSION=$CHOICE
        config_var_set default_extension $CHOICE $CONFIG  
    fi
}


menu_settings_options(){
    #"hide_mmc_device" "Hide internal sd card (CAUTION)" "$HIDE_MMC_DEVICE" \
    #echo "starting menu_settings_options"

    ON=$(whiptail --title "SETTINGS-OPTIONS" --checklist "Enable options" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT \
"shrink_fs" "Shrink filesystem on backup" "$SHRINK_FS" \
"auto_expand_fs" "Create shrunk backup that auto-expands" "$AUTO_EXPAND_FS" \
"hide_root_device" "Hide root device (CAUTION)" "$HIDE_ROOT_DEVICE" \
"check_for_updates_on_startup" "" "$CHECK_FOR_UPDATES_ON_STARTUP" \
"sound" "enable sounds" "$SOUND" \
"log"   "log activity" "$LOG" \
"debug_mode" " " "$DEBUG_MODE" \
 3>&1 1>&2 2>&3) 
    
    if [ $? != 0 ] ; then
        return
    fi
    
    # dump the quotes in the string.
    ON=$(echo $ON | sed 's/"//g')
    
    # set all to off
    config_var_set shrink_fs off $CONFIG
    config_var_set auto_expand_fs off $CONFIG
    config_var_set hide_root_device off $CONFIG
    config_var_set sound off $CONFIG
    config_var_set log off $CONFIG
    config_var_set debug_mode off $CONFIG
    config_var_set check_for_updates_on_startup off $CONFIG
    
    for SELECTED in $ON; do
        config_var_set $SELECTED on $CONFIG
    done
    config_var_get_settings
}


menu_settings(){
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --cancel-button "Back" --menu " " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT  \
        "Default directory   " "$DEFAULT_PATH" \
        "Default extension   " "$DEFAULT_EXTENSION" \
        "Compression         " "$COMPRESSION of 9" \
        "Options             " "Several options to turn on/off " \
        "                    " "      " \
        "Edit settings file  " "Edit the settings file manually (pisafe.conf)" \
        "Factory defaults    " "Reset settings to factory defaults" \
        3>&1 1>&2 2>&3)
        
        RC=$?
        if (( $RC )); then
            return $RC
        else
            case "$SELECTION" in
            "Default d"*)       menu_settings_default_path ;;
            "Default e"*)       menu_settings_default_extension ;;
            "Compression"*)     menu_set_compression ;;
            Text*)              ;;
            Options*)           menu_settings_options ;;

            "    "*)            ;;
            Edit*)              $TEXT_EDITOR $CONFIG; config_var_get_settings ;;
            Factory*) 
                                ui_yesno "WARNING" "Are you sure you want to reset the settings to factory defaults?" "--defaultno" 
                                if [ $? = 0 ] ; then
                                    config_var_set_defaults
                                    config_var_get_settings
                                fi ;;
            
             *)                 whiptail --msgbox "Programmer error: unrecognized option" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT ;;
            esac
        fi
    done
}


menu_select_sddevice(){
    TITLE=$1
    HIDE_ROOT_DEVICE_OVERRIDE=$2    # y n or blank
    FIELD_SEPERATOR="|"

    #get this list of sd devices and add a field seperator |    
    IFS=$'\n'
    options=($(media_list $2 | sed 's/ / '$FIELD_SEPERATOR' /'))
    unset IFS
    
    arraylength=${#options[@]}
    if [ $arraylength = 0 ]; then
        #whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No media found." $WT_MB_HEIGHT  $WT_MB_WIDTH
        ui_msg ERROR "No media found." 
        return 1
    fi

    IFS=$FIELD_SEPERATOR
    DEVICE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$TITLE"\
   --menu "Select media (Hide root = $HIDE_ROOT_DEVICE)" $WT_MB_HEIGHT $WT_MB_WIDTH 10 ""${options[@]}"" 3>&1 1>&2 2>&3)
 
    RC=$?
    unset IFS   

    if (( $RC )); then
        return $RC
    fi
    
   # OUTDEV=$DEVICE_SELECTED
   # INDEV=$DEVICE_SELECTED
    echo $DEVICE_SELECTED
}


menu_get_outfile(){
    OUTFILEDEFAULT="$DEFAULT_PATH/$(date +%Y-%m-%d-pisafe)"
    EXT=$DEFAULT_EXTENSION
    OUTFILE=
           
    MEDIA_OS="$(media_os  $INDEV)"       
           
  #  echo "Calculating backup estimates..."
    ESTIMATES=$(media_backup_estimate $INDEV)     
  #  echo "$ESTIMATES"     
  #  echo       
           
     while true; do   
    
        #get filename
        MSG="$MEDIA_OS \
        \n$ESTIMATES\n===== BACKUP FILENAME ===== \
        \nIf you don't include an extension '.img.$DEFAULT_EXTENSION' will be added \
        \n\nSupported extensions are: .img .zip .xz .gz \
        \n.zip is the baseline \n.img is ~2x faster but twice the size (NOT compressed) \n.xz is ~25% smaller but takes 3x-4x longer \n.gz is ~25% faster \
        \n\nRecommended to have NO SPACES in the name \
        \n\nEnter the image filename (eg: 2020-12-15-buster32)"
        NEWFILE=$(whiptail --backtitle "$BACKTITLE" --title "BACKUP '$(media_name $INDEV)'" --inputbox "$MSG" $WT_HEIGHT_TALL $WT_WIDTH_WIDE "$OUTFILEDEFAULT" 3>&1 1>&2 2>&3)
        RC=$?
        if (( $RC )); then
            return $RC
        fi
    
    
        #fill out variables based on selected filename
        OUTFILEDEFAULT="$NEWFILE"
        OUTFILE="$NEWFILE"
        if [ ! -z $(file_ext "$OUTFILE") ]; then
            EXT=$(file_ext "$OUTFILE")
        else    
            EXT=$DEFAULT_EXTENSION
        fi
 
        file_check_outfile
        RC=$?
        if ! (( $RC )); then
            #return $RC
            break  # break out of the while loop
        fi
    done
        
    # add .img.zip if no extension
    if [ ! -z "$OUTFILE" ] && [ -z "$(file_ext $OUTFILE)" ] ; then 
         echo "Adding '.img.$DEFAULT_EXTENSION'"
         OUTFILE=$OUTFILE.img.$DEFAULT_EXTENSION
         #echo "added ext '$OUTFILE'"
    fi
    
    # check and fix outfile name.....
    if [ $(file_ext "$OUTFILE") = "img" ] ; then
        OUTFILE=$(file_path_base "$OUTFILE").$(file_ext "$OUTFILE")
    else
        OUTFILE=$(file_path_base "$OUTFILE").img.$(file_ext "$OUTFILE")
    fi    
}


menu_backup(){
    INDEV=$1  #use global vars  
    OUTFILE=$2   #use global vars
    
    #reset auto-expand from config file in case it was turned off temporarily
    AUTO_EXPAND_FS=$(config_var_get auto_expand_fs $CONFIG)
    
    # get INDEV
    # Set global variables INDEV and OUTDEV
    INDEV=$(menu_select_sddevice "BACKUP")
    RC=$?
    if (( $RC )); then
        return $RC
    fi 
    
    media_check_indev
    RC=$?
    if (( $RC )); then
        return $RC
    fi
    
    # get OUTFILE
    menu_get_outfile
    RC=$?
    if (( $RC )); then
        return $RC
    fi
    

    #confirm to continue
    MSG="Backup '$(media_name $INDEV)' on '$INDEV' 
        \nto '$OUTFILE'.
        \n\nA good 8GB card with RaspiOS on a Pi4 takes about 10 minutes with zip
        \nand about 7 minutes with gz.
        \nThis will switch to the terminal screen to watch the progress ...
        \n\nCreate backup image-file now?"
    ui_yesno "BACKUP : Create Image-file"  "$MSG"  --defaultno
    RC=$?       
    if (( $RC )) ; then
        return $RC
    fi


    ###########################################################
    # this next line actually does the work!!
    media_backup $INDEV "$OUTFILE" "off" "gui"
    
    RC=$?
    if (( $RC )); then
        ui_error $LINENO "Error '$RC' in media_backup"
        return $RC
    fi 
    ###########################################################

    # Display results
    whiptail  --backtitle "$BACKTITLE" --title " BACKUP-DONE "  \
        --msgbox "'$(media_name $INDEV)' backed up to 
        \n'$OUTFILE' 
        \ncompressed from '$(media_size $INDEV -h)' to '$(file_size $OUTFILE -h)' in $(get_elapsed_time $TIME1 $TIME4) 
        \n\nYou can remove '$(media_name $INDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}  


menu_restore() {   
    echo "Getting list of images ready..."
    
    #GET INFILE
    if whiptail_fselect "WRITE : Select an Image-file" "$DEFAULT_PATH" "zip" "no" ; then
    INFILE=$FILE_SELECTED
    else
        return 1
    fi

    file_check_infile
    RC=$?
    if (( $RC )); then
        return $RC
    fi


    
    # GET OUTDEV
    OUTDEV=$(menu_select_sddevice "RESTORE"  y )    # this sets global variable OUTDEV
    RC=$?
    if (( $RC )); then
        return $RC
    fi 

    media_check_outdev
    RC=$?
    if (( $RC )); then
        return $RC
    fi
    
    

    # Confirm to continue
    if (whiptail  --backtitle "$BACKTITLE" --title "RESTORE WARNING" --defaultno \
        --yesno "Restore '$INFILE' 
        \nto '$(media_name $OUTDEV)' on '$OUTDEV' 
        \n\nALL existing data on '$(media_name $OUTDEV)' - WILL BE ERASED!  
        \nRestore now?" $WT_HEIGHT $WT_WIDTH) then
        #echo "User selected Yes, exit status was $?."
        RESULT="YES"
    else
        #echo "User selected No, exit status was $?."
        RESULT="n"
        return 1
    fi

    #Countdown 
    do_beep
    ui_countdown 10 "" "Overwriting '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    RC=$?
    if (( $RC )); then
        whiptail --backtitle "$BACKTITLE" --title "RESTORE" --msgbox "Restore stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
        return $RC
    fi    
              
    MEDIA_NAME=$(media_name $OUTDEV)          
              
    ###################################################       
    # do the restore
    ### # the third parameter turns "SAFETY" to "off".  this is because we already checked with the GUI.
    # the third parameter turns "SILENT" to "-y".  this is because we already checked with the GUI.
    
    media_restore "$INFILE" $OUTDEV -y gui
    RC=$?
    if [ $RC != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$RC
        echo Exit_code=$RC
        read -n 1 -p "Press any key to continue..." 
        if (( $RC )) ; then
            return $RC
        fi   
    fi 
    ###################################################
 

    if [ $(ui_yesno "RESTORE" "Eject the media from the operating system?") = y ]; then
        echo "Ejecting the media..."
        sleep 2
        umount $OUTDEV?  2> /dev/null
        sudo eject -s $OUTDEV
        sleep 2
    elif [ $(ui_yesno "RESTORE" "Mount the media in the operating system?") = y ]; then
        echo "Mounting the media..."
        sleep 2
        media_mount $OUTDEV
        #echo
    fi


    #display the results
    whiptail  --backtitle "$BACKTITLE" --title " RESTORE-DONE " \
        --msgbox "'$INFILE' restored to 
        \n'$MEDIA_NAME'
        \nin $(get_elapsed_time $TIME1 $TIME2)" $WT_MB_HEIGHT $WT_WIDTH
}


menu_tools(){
    local SELECTION
    local DEVICE
    local FORMAT
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "TOOLS" --cancel-button "Back" --menu " Choose " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
        "INSTALL"           "Install $PRODUCTNAME into the menu" \
        "UPDATE"            "Check for updates" \
        "UNINSTALL"          "Uninstall $PRODUCTNAME" \
          "  "               "  " \
          "  "              "=== MEDIA TOOLS ===" \
        "DETAILS"          "Media details" \
        "ERASE"             "Quick format media" \
        "  "               "  " \
        "TERMINAL"          "View the terminal (for debugging)" \
        "LOG"               "View the log file" \
        3>&1 1>&2 2>&3)
        
        RC=$?
        if (( $RC )); then
            return $RC
        else
            case "$SELECTION" in
            INSTALL)    pisafe_install  ;;
            UPDATE)     pisafe_update gui ;;
            UNINSTALL)  pisafe_uninstall ;;
            DETAILS)    
                DEVICE=$(menu_select_sddevice "MEDIA DETAILS")
                if (( $? )); then
                    return 1
                fi  
                media_details $DEVICE
                ;;
                
            ERASE)                  
                DEVICE=$(menu_select_sddevice "ERASE MEDIA" "y")
                if (( $? )); then
                    return 2
                fi
                
                FORMAT=$(whiptail --clear --backtitle "$BACKTITLE" --title "Select format" --ok-button "Select" --cancel-button "Exit" --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                            "fat32"     "     Most universal format" \
                            "ntfs"      "     Native Windows format" \
                            "ext4"      "     Native Linux format" \
                            "exfat"     "     Newer universal format rec for media over 32GB" 3>&1 1>&2 2>&3)
                if (( $? )); then
                    return 2
                fi
                media_format "$DEVICE" "$FORMAT"  
                ;;
                
            WIPE) 
                DEVICE=$(menu_select_sddevice "WIPE MEDIA" "y")
                if (( $? )); then
                    return 1
                fi  
                media_wipe $DEVICE
                ;;
                
            TEST) 
                DEVICE=$(menu_select_sddevice "TEST MEDIA" "y")
                if (( $? )); then
                    RETURN 1
                fi  
                media_test $DEVICE
                ;;
        

            TERMINAL)   read -n 1 -p "Press any key to return"  ;;
            
            LOG)        $TEXT_EDITOR $LOG_FILE ;;
            
            HELP)
                HELP_INFO="$(pisafe_help)"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$HELP_INFO" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;
                
            ABOUT)
                ABOUT_INFO="$(pisafe_about)"
                whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$ABOUT_INFO" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;  
                
            "  ")  ;;     
            
            *)     whiptail --msgbox "Programmer error: unrecognized option" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT ;;
            esac 
        fi
    done
}


menu_splashscreen(){
    INTERFACE="gui"
    
    # install
    if [ -z $(which $SCRIPTNAME) ]; then
        pisafe_install
    fi    
    
    # load factory defaults
    if [ $(get_ver_to_int $SETTINGS_SCRIPT_VER) -lt $(get_ver_to_int $SCRIPTVER) ]; then
    
        whiptail --backtitle "$BACKTITLE" --title "WELCOME" --yes-button "Load Factory Defaults"\
        --yesno "Welcome to $PRODUCTNAME
        \nMany changes have been made to $PRODUCTNAME and to the settings file.
        \nIt is recommended that you load the factory defaults now.
        \nWhile best attempts have been made to make $PRODUCTNAME reliable... use at your own risk. " \
        $WT_MB_HEIGHT $WT_MB_WIDTH
    
        if [ $? = 0 ] ; then
            config_var_factory_reset 
        fi 
    fi
}


menu_gui(){
    INTERFACE="gui"
    while true
    do
        whiptail_calc_wt_size
        MENU_CHOICE=$(whiptail --clear --backtitle "$BACKTITLE" --title "MAIN MENU" --ok-button "Select" --cancel-button "Exit" --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "BACKUP"    "   Backup media (SD-cards) to an image-file" \
                "RESTORE"   "   Restore media (SD-cards) from an image-file" \
                "LIST"      "   List media and image files" \
                "  "        "   " \
                "SETTINGS"  "   Change settings" \
                "TOOLS"     "   Various tools"\
                 "  "        "   " \
                 "HELP"     "   Help"\
                 "ABOUT"    "   About $PRODUCTNAME"\
                3>&1 1>&2 2>&3)
 
        whiptail_calc_wt_size        
        case $MENU_CHOICE in
            BACKUP)         menu_backup   ;;
            
            RESTORE)        menu_restore  ;;
            
            LIST)           echo "Getting list of images ready..."
                            ui_msg "LIST" "$(do_list_info $DEFAULT_PATH)"  ;;
            
            SETTINGS)       menu_settings    ;;
            
            TOOLS)          menu_tools       ;;
            
            HELP)           ui_msg "HELP" "$(pisafe_help)" ;;
            
            ABOUT)          ui_msg "ABOUT" "$(pisafe_about)"  ;;     
             
            "  "*)          ;;
            
            * )             return          ;;
        esac
    done
}


menu_cli(){
INTERFACE="cli"
case $1 in
    
    backup|read)
        pisafe_write_log $1 $2 $3
        media_backup $2 $3
        ;;
    
    restore|write)
        pisafe_write_log $1 $2 $3 $4
        media_restore $2 $3 $4
        ;;
    
    list)
        do_list_info  ;;


    analyze)
        media_details $2  ;;

    erase|format)
        media_format_fat32 $2 $3 ;;
    
    wipe)
        media_wipe $2 $3 ;;
        
    test)
        media_test $2 $3 ;;
    
    
    install)
        pisafe_install $2 ;;
        
    update)
        pisafe_update cli yes $2
        ;;
    
    uninstall)
        pisafe_uninstall $2 ;;
    
    help|-h|--h)
        pisafe_help  ;;
    
    -v)
        echo $SCRIPTVER  ;;
    
    "")
        menu_gui  ;;
    
    *)   
        pisafe_help  ;;
esac
}



##########################################################

# if -v, show version and exit
if  [ ~$1 = ~-v ]; then
    echo $SCRIPTVER
    exit
fi

pisafe_install_tools

config_var_init_configfile
config_var_get_settings

whiptail_calc_wt_size

#test
#INTERFACE=c
#ui_error $LINENO "test of an error msg"
#exit



## check for updates if not uninstalling
if [ ! ~$1 = ~uninstall ]; then
    if  [ $CHECK_FOR_UPDATES_ON_STARTUP = "on" ]; then
        pisafe_update gui no
    fi
fi

menu_cli $1 $2 $3 $4
