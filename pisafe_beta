#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021" 

# This script basically 
# 1- copies a media-device with 'dd'
# 2- shrinks the last partition with 'pishrink'
# 3- compresses with 'zip' 

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

SCRIPTNAME="${0##*/}"
SCRIPTVER="1.1.5"   # 2021/13/11 @ 12P
PRODUCTNAME="PiSafe"
PRODUCTCOMMENT="Raspberry Pi Imaging App"
PRODUCTHOME="https://github.com/RichardMidnight/pi-safe"
CURRENT_DIR=$(pwd)
USER=$(whoami)
CONFIG=/home/$USER/.config/pisafe/pisafe.conf
REQUIRED_TOOLS="pv bc whiptail zip unzip pigz "
REQUIRED_TOOLS_SPECIAL_INSTALL="lua pishrink.sh xz"
INTERFACE="cli"
INDEV=
OUTDEV=
INFILE=
OUTFILE=
BACKTITLE="$PRODUCTNAME ver $SCRIPTVER   === $PRODUCTCOMMENT === "

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }



Desktop_environment_notes(){
    # this is just a reference of tested OSs from 2021


    DISTRO                      TERMINAL            TEXT EDITOR         
    RaspberryPiOS-stretch       lxterminal          leafpad?
    RaspberrypiOS-buster        lxterminal          mousepad
    Debian-GNOME                gnome-terminal      gedit
    Debian Xfce                 xfce4-terminal      mousepad
    Debian KDE Plasma           konsole             kwrite
    Debian Cinnamon             xterm / uxterm      gedit
    Debian MATE                 mate-terminal       pluma
    Debian LXDE                 lxterminal          mousepad
    Debian LXQt                 qterminal           featherpad
    ubuntu gnome                gnome-terminal      gedit
    lubuntu LXQt                qterminal           featherpad
    LMDE-4 Cinnamon             gnome-terminal      xed
    mint cinnamon               gnome-terminal      xed
    mint MATE                   mate-terminal       xed
    Mint Xfce                   xfce4-terminal      Xed

    bionic puppy    - ppm       lxterminal          geany 
    arch / manjaro  - pacman -S
    zorin - ubuntu based
    manjaro kde                 konsole             kate
    manjaro xfce                xfce-terminal       mousepad
    
    
    Tested with
    --- ARM ---
    Raspios Buster      good
    Raspbian Stretch    good
    Raspbian Jessy      can work with limitations
    Manjaro             good         
    Ubuntu              good
    
    --- x86 ---
    debian Strech, Buster         no- last is logical swap.
    RPD Buster                    see debian
    mint  20.1                    no - last is ext logical.
    LMDE 4                        good
    ubuntu                        good
    lubuntu                         good

}


pisafe_help() {
    echo "$PRODUCTNAME v$SCRIPTVER  - Designed for Raspberry Pi"
    echo " - Backup your media (SD card) to an image file"
    echo " - Restore your media (SD card) from an image file"
    echo
    echo "Usage: "
    echo "  $SCRIPTNAME [function] [media/file] [file/media]"
    echo
    echo "CLI Function is:"
    echo "                               - with no arguments it launches the PiSafe menu (recommended)"
    echo "  list                         - list media and image-files "
    echo "  backup [device] [file]       - backup media to image-file"
    echo "  restore [file] [device] [-y] - restore image-file to media"
    echo "  analyze [dvice]              -   "
    echo "  erase [device] [-y]          - format media as FAT32"
    echo "  wipe [device]                - wipe media.  fill with zeros"
    echo "  test [device]                - test media.  write and read ones and zeros"
    echo "  install [-y]                 - install this script"
    echo "  update [-y]                  - update script from website"
    echo "  uninstall [-y]               - uninstall this script"
    echo "  -v                           - display version"
    echo "  help | -h                    - help"
    echo
    echo "Notes: "
    echo " - Supports .img .zip .xz .gz and .iso files.  Appends '.img.$DEFAULT_EXTENSION' if no extension is specified "
    echo " - Specifying an '.img' or '.iso' extension is faster but twice the size because it is not compressed."
    echo
    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Examples:"
    echo "$SCRIPTNAME "
    echo "$SCRIPTNAME list"
    echo "$SCRIPTNAME backup sda newimage"
    echo "$SCRIPTNAME backup /dev/sdb newimage.xz"
    echo "$SCRIPTNAME restore newimage.img.zip sda"
    echo "$SCRIPTNAME backup /dev/sda /media/pi/SandiskUSB/backup_\$(date +%Y-%d-%m_%I%M%p).img.gz"
    echo
}


pisafe_about(){
    echo "$PRODUCTNAME was started in 2017 as 'sd' by 'RichardMidnight on github'"\
        "while working on a Raspberry Pi Homebridge project and needing"\
        "to make numerous restore-points.  The image writers available at the"\
        "time did not run on the pi itself and were not able to create a new image file." 
    echo
    echo "It was originally called 'sd' and only had a CLI."
    echo
    echo "Then in 2021, the menu front-end was added to make it more usable by others."\
        "It was then renamed it 'PiSafe'.  PiSafe is a reference to the 'ventilated cupboards for storing"\
        "pies while protecting them from insects and vermin'. "
    echo
    echo "It may work on many debian and arch distros."
    echo 
    echo "It's home is $PRODUCTHOME"
    echo
    echo "Use at your own risk."
    echo
    echo "Hopfully PiSafe is useful to others."
    echo
}


# ---------- Enviroment functions


env_installer(){
    local INSTALLER=
    
    if [ -f /usr/bin/apt ]; then             # debian
        INSTALLER="apt install -y"
    elif [ -f /usr/bin/pacman ]; then        # arch
        INSTALLER="pacman -S --noconfirm"
    elif [ -f /usr/bin/dnf ]; then            #rpm / fedora
        INSTALLER="dnf install -y"  
    fi
    
    echo "$INSTALLER"
}



env_terminal(){
    local TERMINAL1=
    
    if [ -f /usr/bin/lxterminal ];then
      TERMINAL1="lxterminal --geometry=110x40 --title='PiSafe' -e bash -c "
    
    elif [ -f /usr/bin/xfce4-terminal ];then
      TERMINAL1="xfce4-terminal --geometry=110x40 --title='PiSafe' -x bash -c "
    elif [ -f /usr/bin/mate-terminal ];then
      TERMINAL1="mate-terminal --geometry=110x40 --title='PiSafe' -x bash -c "
    elif [ -f /usr/bin/gnome-terminal ];then
      TERMINAL1="gnome-terminal --geometry=110x40 --title='PiSafe' -x bash -c "
      
    elif [ -f /usr/bin/xterm ];then
      TERMINAL1="xterm -geometry 110x40 -T 'PiSafe' -e bash -c " 

    elif [ -f /usr/bin/terminator ];then
      TERMINAL1="terminator --geometry=110x40 -T 'PiSafe' -x bash -c "
      
    elif [ -f /usr/bin/konsole ];then
      TERMINAL1="konsole -e bash -c " 
    elif [ -f /usr/bin/qterminal ];then
      TERMINAL1="qterminal -e bash -c "   
      
    elif [ -f /usr/bin/x-terminal-emulator ];then
      TERMINAL1="$(readlink -f /usr/bin/x-terminal-emulator) -e bash -c "
      
    else
      echo "Failed to locate any terminal emulators!!!"
      exit 1
    fi

    echo "$TERMINAL1"
}


env_texteditor(){
    TEXT_EDITORS="mousepad leafpad xed gedit featherpad kwrite pluma kate geany, nano "
    
    for TEXT_EDITOR in $TEXT_EDITORS ; do
        #if [ ! -z $(which $TEXT_EDITOR) ]; then
        if [ -f /usr/bin/$TEXT_EDITOR ]; then
            echo $TEXT_EDITOR
            return
        fi
    done
}
 

env_root_device() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    ROOT_PARTITION=$(lsblk -l | grep "/$" | cut -d' ' -f1 2> /dev/null) 
    
    if [ -z $ROOT_PARTITION ]; then
        return 1  # can't find root partition or root device
    fi
    
    if [[ $ROOT_PARTITION =~ "p" ]]; then
        ROOT_DRIVE=$(echo $ROOT_PARTITION | cut -d'p' -f1)
    elif [[ $ROOT_PARTITION =~ "sd" ]]; then
        ROOT_DRIVE=${ROOT_PARTITION:0:3}
    else
        return 2  # can't find root device
    fi    
 #   echo $ROOT_DRIVE
    
    
    # new simpler way
    ROOT_PARTITION=$(findmnt -no source /)
    ROOT_MAJ=$(findmnt  -n -e  -o MAJ:MIN / | cut -d: -f1)
    ROOT_DEV=$(lsblk | grep $ROOT_MAJ:0 | cut -d" " -f1)
    echo $ROOT_DEV
}


# ---------- Config_var functions

config_var_init_configfile(){
    if [ ! -d $(file_path $CONFIG) ]; then
        mkdir -p $(file_path $CONFIG)
    fi
    
    if [ ! -f $CONFIG ]; then
        #echo " " > $CONFIG
        touch $CONFIG
        echo "# $CONFIG" > $CONFIG
        config_var_set_defaults
    fi
}


config_var_set_defaults(){
    config_var_set settings_script_ver $SCRIPTVER $CONFIG
    config_var_set default_path $HOME/Downloads $CONFIG
    config_var_set hide_root_device on $CONFIG
    config_var_set check_for_updates_on_startup on $CONFIG

#backup settings
    config_var_set shrink_fs on $CONFIG
    config_var_set auto_expand_fs on $CONFIG
    config_var_set default_extension zip $CONFIG
    config_var_set compression_level 1 $CONFIG
    config_var_set parallel_compression on $CONFIG
    config_var_set large_device_read_warning 17179869184 $CONFIG
    config_var_set skip_freespace on $CONFIG
    
#restore settings
    config_var_set large_device_write_warning 17179869184 $CONFIG
    config_var_set safety on $CONFIG    

#other    
    config_var_set debug_mode off $CONFIG
    config_var_set sound on $CONFIG
    config_var_set log on $CONFIG
    #config_var_set log_file /home/$USER/PiSafe.log $CONFIG
    config_var_set log_file /home/$USER/.config/pisafe/PiSafe.log $CONFIG
    
    config_var_set text_editor $(env_texteditor) $CONFIG
}


config_var_get_settings(){
    SETTINGS_SCRIPT_VER=$(config_var_get settings_script_ver $CONFIG)
    DEFAULT_PATH=$(config_var_get default_path $CONFIG)
    HIDE_ROOT_DEVICE=$(config_var_get hide_root_device $CONFIG)
    CHECK_FOR_UPDATES_ON_STARTUP=$(config_var_get check_for_updates_on_startup $CONFIG)
 
 # backup settings
    SHRINK_FS=$(config_var_get shrink_fs $CONFIG)
    AUTO_EXPAND_FS=$(config_var_get auto_expand_fs $CONFIG)
    DEFAULT_EXTENSION=$(config_var_get default_extension $CONFIG)
    COMPRESSION=$(config_var_get compression_level $CONFIG)
    LARGE_DEVICE_READ_WARNING=$(config_var_get large_device_read_warning $CONFIG) 
    SKIP_FREESPACE=$(config_var_get skip_freespace $CONFIG)
    
# restore settings
    LARGE_DEVICE_WRITE_WARNING=$(config_var_get large_device_write_warning $CONFIG) 
    SAFETY=$(config_var_get safety $CONFIG)  

# other    
    DEBUG_MODE=$(config_var_get debug_mode $CONFIG)
    SOUND=$(config_var_get sound $CONFIG)
    LOG=$(config_var_get log $CONFIG)
    LOG_FILE=$(config_var_get log_file $CONFIG)
    VERIFY=off
    TEXT_EDITOR=$(config_var_get text_editor $CONFIG)
    
    mkdir -p "$DEFAULT_PATH"
}


config_var_set() {
  lua - "$1" "$2" "$3" <<EOF > "$3.bak"
local key=assert(arg[1])
local value=assert(arg[2])
local fn=assert(arg[3])
local file=assert(io.open(fn))
local made_change=false
for line in file:lines() do
  if line:match("^#?%s*"..key.."=.*$") then
    line=key.."="..value
    made_change=true
  end
  print(line)
end

if not made_change then
  print(key.."="..value)
end
EOF
mv "$3.bak" "$3"
}


config_var_clear() {
  lua - "$1" "$2" <<EOF > "$2.bak"
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
for line in file:lines() do
  if line:match("^%s*"..key.."=.*$") then
    line="#"..line
  end
  print(line)
end
EOF
mv "$2.bak" "$2"
}


config_var_get() {
  lua - "$1" "$2" <<EOF
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
local found=false
for line in file:lines() do
  local val = line:match("^%s*"..key.."=(.*)$")
  if (val ~= nil) then
    print(val)
    found=true
    break
  end
end
if not found then
   print(0)
end
EOF
}


config_var_factory_reset(){
    config_var_set_defaults
    config_var_get_settings
}


# ---------- Dialog functions

dialog_msg() {
    TITLE="$1"
    MSG="$2"
    COLOR=${3:-"white"}
    OK_BUTTON=${4:-"Back"}
    
    if [ $INTERFACE = "cli" ]; then
        MSG="$PRODUCTNAME: $TITLE: \n\n$MSG"
        if [ $COLOR = "red" ]; then
            echo_red -e "$MSG"
        else    
            echo -e "$MSG"
        fi
    else
        whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --scrolltext --ok-button "$OK_BUTTON" --msgbox "$MSG" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE # $WT_MB_HEIGHT $WT_MB_WIDTH
    fi
}


dialog_yesno(){
   
    TITLE="$1"
    MSG="$2"
    DEFAULT=${3:-"yes"}
    COLOR=${4:-"white"}
    
    if [ $INTERFACE = "cli" ]; then
        MSG="$PRODUCTNAME: $TITLE: $MSG  [y/n]?"
        while true; do
            read -n1 -p "$MSG" yn
            echo
            case $yn in
                [Yy]* ) echo y; return 0;;
                [Nn]* ) echo n; return 0;;
                * )     ;;
            esac
        done
        
    else
        whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --defaultno --yesno "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH 3>&1 1>&2 2>&3
        if [ $? = 0 ]; then 
            RESULT=y
        else
            RESULT=n
        fi
        echo $RESULT
        return 0
    fi
}


dialog_countdown(){
     local SECONDS=${1:-10}
     local TITLE=$2
     local MESSAGE=${3:-"Counting down..."}
    if [ $INTERFACE = "cli" ]; then
        do_countdown $1
    else
        whiptail_countdown "$SECONDS" "$TITLE" "$MESSAGE"
    fi
}


# ---------- Misc functions

echo_if_cli (){
    local MSG=$1
    local COLOR=$2
    if [ $INTERFACE = "cli" ]; then
        case $COLOR in
            white) echo_white $MSG ;;
            red)    echo_red $MSG ;;
            *) echo $MSG ;;
        esac
    fi
}


do_write_log(){
    INFO=$*
    if [ $LOG = "on" ]; then
        touch $LOG_FILE
        echo "$(date "+%Y-%m-%d %H:%M"), $INFO" >> $LOG_FILE
    fi
}


is_number() {
  case $1 in
    ''|*[!0-9]*) return 0 ;;
    *) return 1 ;;
  esac
}


do_countdown(){  
    local MAX=${1:-10}
 
    echo "Pausing for $MAX seconds... Ctrl-C to stop"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
		sleep 1
    done 
    echo ...
}


do_beep_if_sound(){
    if [ $SOUND = on ] ; then
        #do_beep
        speaker-test -t sign -f 700 > /dev/null  & sleep .5 && kill -9 $! 
        sleep .5  # to allow the beep to end
    fi
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


get_ver_to_int() {
	local IFS=.
	parts=($1)
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


get_bytes_h(){
    BYTES=$1
    # currently shows 3 significant digits.
    
    NUM='^[0-9]+$'
    if ! [[ "$BYTES" =~ $NUM ]] ; then   # not a number   
        return 1
    fi
    
    [ -z "$BYTES" ] && return
    #need some error checking that it is a number
    
    k_ilo=1024;
    m_ega=$k_ilo*$k_ilo;
    g_iga=$m_ega*$k_ilo;
    t_era=$g_iga*$k_ilo;
    p_eta=$t_era*$k_ilo;
    
    LEN=${#BYTES}
    
    case $LEN in
        4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
        5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
        6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
        
        7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
        8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
        9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
        
        10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
        11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
        12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
        
        13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
        14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
        15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
        *)  echo $BYTES ;;
    esac
}



# ---------- file functions


file_path(){
    dirname "$*"
}


file_base() {
    local fullfilename=$*
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo "$fname"
}


file_path_base(){
    #echo $(file_path "$*")/$(file_base "$*")
    echo "$*" | cut -d. -f1
}


file_ext(){
	base=$(basename "$*")
	
	#look for a period in the basename.  if there is one, there is an extention
	HAS_DOT=$(echo "$base" | grep \\.)
	if [ ! -z "$HAS_DOT" ] ; then
		echo $base | sed 's#.*\.##g'
	else  
		echo ""
		return 1
	fi
}


file_size() {
    local FILE=$1
    local HUMAN=${2:-"no"}
    # $2 can be -h
    
    if [ -f "$FILE" ] ; then
        SIZE_BYTES="$(($(ls -s "$FILE" | cut -d' ' -f1) * 1024))"
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
        if [ $HUMAN = "-h" ]; then
            echo $(get_bytes_h $SIZE_BYTES)
        else
            echo $SIZE_BYTES
        fi
    else
        echo 0
    fi
}


file_image_size() {
    local INFILE="$1"
    local HUMAN=${2:-"no"}
    
    file_check_for_img_file "$INFILE" > /dev/null
    if [ $? != 0 ] ; then
        # image file not found
        echo 0
        return 1
    fi
    
    case $(file_ext "$INFILE") in
        img | iso)
            SIZE_BYTES=$(echo $((  $(ls -s "$INFILE" | cut -d' ' -f1 ) * 1024 )) )
        ;;
        
        zip)
            SIZE_BYTES=$(zipinfo -t "$INFILE" 2> /dev/null | grep "%" | cut -d, -f2 | cut -d" " -f2  )
        ;;
        
        xz)
            SIZE_BYTES=$(xz -l -v "$INFILE" 2> /dev/null | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1 | sed 's/,//g')
        ;;  
          
        gz)
            SIZE_BYTES=$(pigz -l "$INFILE" 2> /dev/null | grep -v compressed | sed 's/\s\s*/ /g' | sed -e 's/^[ \t]*//' | cut -d' ' -f 2 | sed 's/?/0/g')

        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
    
    if [ -z $SIZE_BYTES ] ; then
        echo 0 
        return 0
    fi
    
    if [ $HUMAN = "-h" ]; then
        echo $(get_bytes_h $SIZE_BYTES)
    else
        echo $SIZE_BYTES
    fi
}    


file_check_for_img_file(){
    # returns 0 if there is an imagefile
    # returns 1 if no imagefile

    local INFILE="$*"
    local IMG
    
    if [ ! -f "$INFILE" ] ; then
        echo_if_cli "ERROR '$INFILE' not found"
        return 1
    fi
    
    echo -n "Inspecting '$INFILE' for an image file ... "
 
    case $(file_ext "$INFILE") in
        img | iso)
            IMG=$INFILE
        ;;
        
        zip)
            IMG=$(zipinfo -1 "$INFILE" 2> /dev/null | grep .img | cut -d " " -f 11)  
        ;;
        
        xz)
            IMG=$(xz -l "$INFILE" 2> /dev/null | grep .img | sed 's/\s\s*/ /g' | cut -d' ' -f10-)
         ;;   
         
         gz)
            IMG=$(pigz -l "$INFILE" 2> /dev/null | grep .img | sed 's/\s\s*/ /g' | cut -d " " -f4-)
         ;;
         
         *)
            IMG=
        ;;
    esac
    
    if [ ! -z "$IMG" ] ; then
        echo "$IMG" [OK]
        return 0
    else
        echo "ERROR: No image found in '$INFILE'"
        return 1
    fi    
}


file_ext_ok(){
    #check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
    OUTFILE_EXT=$(file_ext "$1")

    case $OUTFILE_EXT in
        img | zip | xz | gz | iso | "" )
            echo true
            return 0
        ;;
        
        *)  
            echo ""
            return 1
        ;;
    esac
}


file_list_image_files(){
    FILES="FILE_NAME FILE_SIZE (IMAGE_SIZE) \n"
    CONFIG=/home/$USER/.config/pisafe/pisafe.conf
    IFS=$'\t\n'
    
    for FILE in $(ls *.img *.zip *.xz *.gz *.iso 2>/dev/null) ; do
        FILE_NS=$(echo "$FILE" | sed 's/ /_/g')
        FILES="$FILES $FILE_NS  $(file_size "$FILE" -h)  ($(file_image_size "$FILE" -h)) \n "
        #FILES="$FILES $FILE_NS  $(file_size "$FILE" -h)   \n "
    done

    printf $FILES | column  -t
    unset IFS
}


file_device(){
    MOUNT_POINT=$(df -a "$1" | sed 's/  */ /g' | grep -v Mounted | cut -d ' ' -f 6  )
    BLK_DEV=$(lsblk -n -l -p -o PKNAME,MOUNTPOINT,NAME | sed 's/  */ /g' | grep " $MOUNT_POINT " | cut -d " " -f 1)
    echo $BLK_DEV
}


file_fs_freespace() {
    local FILENAME=${1:-"."}  
    local FORMAT=${2:-"-B1"}   # -B1 for bytes    -h for humanreadable
    local FREESPACE
    
    if [ -d "$FILENAME" ]; then
        FREESPACE=$(df "$FILENAME" $FORMAT --output=avail | grep -v Avail)
        EXIT_CODE=$?
    else
        FREESPACE=$(df $(dirname "$FILENAME") $FORMAT --output=avail | grep -v Avail)
        EXIT_CODE=$?
    fi

    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo $FREESPACE
}   


get_folder_size() {
    local FOLDER=$*
    # returns human readable
    
    if [ -d "$FOLDER" ] ; then
        sudo du -sh "$FOLDER" | cut -d'/' -f1 | sed 's/\s\s*/ /g'
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


# ---------------------------------------------------------

check_indev(){
    #returns 0 if good
    # check INDEV
    
    # stop if indev is blank
    if [ -z $INDEV ] ; then
        dialog_msg "ERROR 1" "IN-DEV '$INDEV' can't be blank" "red" "OK"
        return 1
    fi 
    
    # add '/dev/' if missing
    if [ "${INDEV:0:5}" != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        INDEV="/dev/"$INDEV
        echo "IN-DEV='$INDEV'"
    fi
    
    # Stop if INDEV does not exists
    if  [ ! -e $INDEV ]  ; then
        dialog_msg "ERROR 2" "IN-DEV '$INDEV' not found" "red" "OK"
        return 1
    fi 
    
    # warning if INDEV is root device
    if [ $INDEV = /dev/$(env_root_device) ]; then
        dialog_msg "WARNING 3" "SD-card '$(media_name $INDEV)' is root device '/dev/$(env_root_device)'." "red" "OK"
        #return 1
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(media_size $INDEV) -gt 16000000000 ]; then
        MESG=" '$(media_name $INDEV)' is larger than 16GB.  \
         \n\nUse a smaller SD card if you can.  \
         \nIt will be faster because the entire SD card must be read before it can be compressed.\
         \n\nA good 8gb card with RaspiOS in a Raspberry Pi 4 takes about 10 minutes"
        #whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "$MESG" $WT_MB_HEIGHT $WT_MB_WIDTH  
        dialog_msg "WARNING 4" "$MESG" "red" "OK"
    fi
    
    # Warning if SD-card is bigger than freespace
    if [ $(media_size $INDEV) -gt $(file_fs_freespace "$DEFAULT_PATH") ]; then
        MSG="Not enough free space on '$DEFAULT_PATH' 
         \n\n'$(media_name  $INDEV)' is $(media_size $INDEV -h)
         \nfreespace on '$DEFAULT_PATH' is $(file_fs_freespace "$DEFAULT_PATH" -h)
         \n\nBe sure to specify a different drive" 
         dialog_msg "ERROR 5" "$MSG" "red" "OK"
        #return 1
    fi
    
    # Warning if one and a half times the SD-card is bigger than freespace
    SPACENEEDED=$(( $(media_size $INDEV) + $(( $(media_size $INDEV) / 2 )) ))
    if [ $SPACENEEDED -gt $(file_fs_freespace "$DEFAULT_PATH") ]; then
        MSG="Might not be enough free space on '$DEFAULT_PATH'
            \n\n'$(media_name $INDEV)' is $(media_size $INDEV -h)
            \nfreespace on '$DEFAULT_PATH' is $(file_fs_freespace "$DEFAULT_PATH" -h)
            \nThere is $(get_folder_size /home/$USER/.local/share/Trash) in the Trash" 
        dialog_msg "WARNING 6" "$MSG" "red"  "OK"
    fi
    
     # if we got this far, all is good
     return 0
}


check_outfile(){
    # uses global variable OUTFILE
    # returns 0 if good
    
    #Quit if outfile is blank
    if [ -z "$OUTFILE" ] ; then
        dialog_msg "ERROR 1" "File '$OUTFILE' can't be blank" "red"
        return 1
    fi  
    
    # Message if path does not exist
    # Quit if path does not exist
    if [ ! -d  "$(file_path $OUTFILE)" ] ; then     
        dialog_msg "Error 2" "Directory does not exist '$(file_path $OUTFILE)'" "red"
        #continue 
        return 2
    fi
    
    # add ext if missing
    if [ -z $(file_ext "$OUTFILE") ]; then
        echo "No extension specified.  Adding '.img.$DEFAULT_EXTENSION'"
        OUTFILE=$OUTFILE.img.$DEFAULT_EXTENSION
        #OUTFILE_EXT=$(file_ext $OUTFILE)
        echo "OUT-FILE='$OUTFILE'" 
    fi

    # insert .img if missing
    if [ "$(echo "$OUTFILE" | grep img)" = "" ] && [ "$(echo "$OUTFILE" | grep iso)" = "" ]; then
        echo "inserting .img"
        OUTFILE=$(file_path_base "$OUTFILE").img.$(file_ext "$OUTFILE")
        echo "OUT-FILE='$OUTFILE'" 
    fi

    # quit if unsupported extension
    if [ -z $(file_ext_ok "$OUTFILE") ]; then
        dialog_msg "ERROR 3" "Unsupported file extension '$(file_ext $OUTFILE)'" "red"
        return 3 
    fi

    # Quit if outfile exists
    if  [ -f "$OUTFILE" ]  ; then
        dialog_msg "ERROR 4" "File '$OUTFILE' already exists" "red"
        return 4
    fi 

    # Quit if OUTFILE_BASE.img exists
    if  [ -f "$(file_path_base $OUTFILE)".img ]  ; then
        dialog_msg "ERROR 5" "File '$(file_path_base $OUTFILE).img' already exists" "red"
        return 5
    fi 
    
    # Quit if OUTFILE_BASE.img.ext exists
    if  [ -f "$(file_path_base $OUTFILE)".img.$(file_ext "$OUTFILE") ]  ; then
        dialog_msg "ERROR 6" "File '$(file_path_base $OUTFILE).img.$(file_ext "$OUTFILE")' already exists" "red"
        return 6
    fi 
    
    #return 0
}


check_infile(){
    # quit if infile is blank
    if [ -z "$INFILE" ] ; then
        dialog_msg "ERROR 1" "File '$INFILE' cannot be blank" "red"
        return 1
    fi 
    
    # quit if infile not found
    if  [ ! -f "$INFILE" ]  ; then
        dialog_msg "ERROR 2" "File '$INFILE' not found" "red"
        return 2
    fi 
    
    # quit or warning if no img file found
    file_check_for_img_file "$INFILE"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        dialog_msg "ERROR 3" "No image file found in '$INFILE'" "red"
        return 1
    fi 
}


check_outdev(){
    # quit if outdev is blank
    if [ -z $OUTDEV ]; then
        dialog_msg "ERROR 1" "Device '$OUTDEV' cannot be blank" "red"
        return 1
    fi
    
    # Add '/dev/' if missing
    if [ ${OUTDEV:0:5} != "/dev/" ]; then
        echo_if_cli "Device prefix not specified.  Adding '/dev/'"
        OUTDEV="/dev/"$OUTDEV
        echo_if_cli "OUT-DEV='$OUTDEV'"
    fi
    
    # Quit if OUTDEV is not found
    if  [ ! -e $OUTDEV ]  ; then
        dialog_msg "ERROR 2" "Device '$OUTDEV' not found" "red"
        return 2
    fi 
           
           
        
    #stop if drive is pisafe_locked
    #  $(config_var_get safety $CONFIG)
    VENDOR=$(lsblk -n -d --output vendor /dev/sda)
    SERIAL=$(lsblk -n -d --output serial /dev/sda)
    #echo Device Vendor and Serial_number=$VENDOR $SERIAL
    #if [ $(config_var_get device_$VENDOR$SERIAL $CONFIG) = "locked" ]; then
    #  do_beep_if_sound
    #  echo Drive $OUTDEV serial number $VENDOR$SERIAL is $PRODUCTNAME locked.  exiting.
    #  return 1
    #fi
    
    #stop if outdev is piSave-locked
    if [ $(config_var_get device_lock_$(media_serialno $OUTDEV) $CONFIG) = "on" ]; then
        dialog_msg "RESTORE ERROR " "Device '$(media_serialno $OUTDEV)' is locked by PiSafe in the config file" "red"
        return 1
    fi
    
    
    
    # Stop if outdev is the root device
    if [ $OUTDEV = /dev/$(env_root_device) ]; then
        dialog_msg "RESTORE ERROR" "Restore to root device not allowed" "red"
        return 1
    fi
    
    #stop if INFILE is on OUTDEV
    if [ "$(file_device "$INFILE")" = $OUTDEV ]; then
        dialog_msg "RESTORE ERROR" "Restore to same device as '$INFILE' not allowed" "red"
        return 1
    fi
    
    # Warning if device is large
    if [ $(media_size $OUTDEV) -gt $LARGE_DEVICE_WRITE_WARNING ]; then
        dialog_msg "RESTORE WARNING" "'$(media_name $OUTDEV)' 
        \nis larger than $(get_bytes_h $LARGE_DEVICE_WRITE_WARNING)... 
        \n\nBe sure this is the right device" "red" "OK"
    fi
     
    # Stop if imagefile is larger than device
    if [ $(file_image_size "$INFILE") -gt $(media_size $OUTDEV) ]; then
        dialog_msg "RESTORE ERROR" "Not enough room
        \nThe image in '$INFILE' is ' $(file_image_size "$INFILE" -h)' 
        \nand '$OUTDEV' is only '$(media_size $OUTDEV -h)'" "red"
        return 1
    fi
}


# -----------------------------------------------




do_list_info() {
        DIR=${1:-$PWD}
        echo "~~~ CURRENT SYSTEM ~~~"
        echo $PRODUCTNAME ver $SCRIPTVER
        echo $(cat /etc/os-release | grep "PRETTY_NAME=" | cut -d '"' -f2) hw=$(uname -m) kernel=$(uname -r)
        echo "Root device = /dev/$(env_root_device)"
        echo "Size      = $(media_size /dev/$(env_root_device) -h )"
        echo "FreeSpace = $(file_fs_freespace . -h)"
        echo "TrashSize = $(get_folder_size /home/$USER/.local/share/Trash)"
        echo "RootTrash = $(get_folder_size /root/.local/share/Trash)"
        echo
    #    echo "Default dir = '$DIR' - $(file_fs_freespace $DIR -h) free"  
        #echo "~~~ PiSafe LOCKED DEVICES ~~~"
        #echo "$(cat $CONFIG | grep "device_lock")"
        #echo
        echo
        echo "~~~ STORAGE MEDIA (hide root device = $HIDE_ROOT_DEVICE) ~~~"
        echo "$(media_list)"
        echo   
        echo
        echo "~~~ IMAGE FILES in '$DIR' ($(file_fs_freespace $DIR -h) free) ~~~"
        SAVED_PWD=$PWD
        cd $DIR  
        file_list_image_files
        cd $SAVED_PWD
}    



# --------------------------------------



do_install_lua(){
    # try to find a version of lua that will install
    # lua.org
    
    # see if lua is installed, fix if needed 
    LUA_VERS="lua lua5.4 lua5.3 lua5.2 lua5.1 lua54 lua53 lua52 lua51"
    for LUA_VER in $LUA_VERS; do
        1>/dev/null 2>/dev/null $LUA_VER -v 
        if [ $? = 0 ]; then  #  LUA_VER found
            1>/dev/null lua -v
            if [ $? = 0 ]; then   # lua works, can return
              return
            else
            
                #crude patch for arch/manjaro  install is lua54 but goes to /usr/bin/lua5.4
                for LUA_TEST in "lua5.4 lua5.3 lua5.2 lua5.1"; do
                    if [ -f /usr/bin/$LUA_TEST ]; then
                        # this should probably should be an alias...
                        sudo cp /usr/bin/$LUA_TEST /usr/bin/lua
                        return
                    fi
                done

            fi
        fi
     done 
     
     
     # lua not found, try to install and fix   
     for LUA_VER in $LUA_VERS; do
        echo Trying to install $LUA_VER ...
        sudo $INSTALL $LUA_VER
        if [ $? = 0 ] ; then  # no error so LUA_VER installed
          # see if we need to fix lua
          1>/dev/null lua -v
          if [ $? = 0 ]; then  # lua works, can return
            return
          else  # error so we need to fix it.
          
            #crude patch for arch/manjaro  install is lua54 but goes to /usr/bin/lua5.4
            for LUA_TEST in "lua5.4 lua5.3 lua5.2 lua5.1"; do
                if [ -f /usr/bin/$LUA_TEST ]; then
                    # this should probably should be an alias...
                    sudo cp /usr/bin/$LUA_TEST /usr/bin/lua
                    return
                fi
            done
            
          fi  
        fi
    done
    
    lua -v
}


pisafe_install_tools() {   
    TOOL_MISSING=false
    TOOLS=$(echo $REQUIRED_TOOLS $REQUIRED_TOOLS_SPECIAL_INSTALL)
    INSTALL=$(env_installer)
    
    for TOOL in $TOOLS ; do
        #if [ ! $(which $TOOL) ]; then
        if [ ! -f /usr/bin/$TOOL ]  && [ ! -f /usr/local/bin/$TOOL ] ; then
            TOOL_MISSING=true
            #echo $TOOL
        fi
    done
    
    if [ $TOOL_MISSING = "true" ]; then
        echo "Installing required tools ($REQUIRED_TOOLS $REQUIRED_TOOLS_SPECIAL_INSTALL)"
        RESULT=y
        if [ $RESULT != "y" ]; then
            echo
            echo_red   WARNING.  Not all the needed tools are installed.
            return 1
        fi

        for TOOL in $REQUIRED_TOOLS ; do
             if [ ! -f /usr/bin/$TOOL ]; then
                echo_white Installing $TOOL ...
                sudo $INSTALL $TOOL
                EXIT_CODE=$?
                if [ $EXIT_CODE != 0 ]; then
                    dialog_msg "Error" "$TOOL not installed." "red"
                fi
            fi
        done
        
        # special installs ...
        
        # Install PiShrink if needed
        if [ ! -f /usr/local/bin/pishrink.sh ]; then
            echo_white Installing pishrink...
            wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
            sudo chmod +x pishrink.sh
            sudo mv pishrink.sh /usr/local/bin
            if [ ! -f /usr/local/bin/pishrink.sh ] ; then
              dialog_msg "Error" "pishrink not installed." "red" 
            else
              dialog_msg  pishrink installed.
            fi
        fi

        # Install xz if needed
        if [ ! -f /usr/bin/xz ]; then
            echo_white Installing xz-utils...
            sudo $INSTALL xz-utils
            if [ ! -f /usr/bin/xz ]; then
               dialog_msg "Error" "xz not installed." "red" 
            fi
        fi
    
        do_install_lua
    
    fi
}    


pisafe_install(){
    SILENT=${1:-"-n"}
    
    if [ $SILENT != "-y" ]; then
        RESULT=$(dialog_yesno "INSTALL" "Install $PRODUCTNAME $SCRIPTVER?")
        if [ $RESULT != "y" ]; then
            #echo
            dialog_msg "NOTICE" "$PRODUCTNAME not installed"
            return
        fi
    fi
    
    do_write_log "Installing $PRODUCTNAME v $SCRIPTVER"
    #dialog_msg "installing"  "Installing $PRODUCTNAME ..."
    
    # Install the CLI script
    sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
    sudo chmod +x /usr/local/bin/$SCRIPTNAME
    echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)


    # download the icon
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/pisafe_icon.png -O pisafe_icon.png
    mv pisafe_icon.png /home/$USER/.config/pisafe/pisafe_icon.png

    
    # create the desktop file    
    TERMINAL1=$(env_terminal)
    echo "\
[Desktop Entry]
Type=Application
Terminal=false
Version=1.0
Name=$PRODUCTNAME
Comment=$PRODUCTCOMMENT
#Icon=rpi-imager
#Icon=media-removable
Icon=/home/$USER/.config/pisafe/pisafe_icon.png
#Exec=lxterminal --geometry=110x40 -e $SCRIPTNAME
Exec=$TERMINAL1 $SCRIPTNAME
Categories=Utility
StartupNotify=false" > "$PRODUCTNAME.desktop"   

    # for lxde, MATE and xfce put it in /usr/share/applications
    sudo mv "$PRODUCTNAME.desktop" "/usr/share/applications"
    # for just this user, put it in $HOME/.local/share/applications/
    #mv "$PRODUCTNAME.desktop" "$HOME/.local/share/applications/"

    if [ -f "/usr/local/bin/$SCRIPTNAME" ]; then 
        MSG="$PRODUCTNAME $SCRIPTVER installed.            
        \nSelect it from the 'Accessories' menu.
        \n\nOr you can execute it from any directory by typing '$SCRIPTNAME'."
        
        if [ $INTERFACE = "cli" ]; then
            MSG="$PRODUCTNAME $SCRIPTVER installed.  Select it from the 'Accessories' menu or you can execute it in a terminal window by typing '$SCRIPTNAME'."
        fi
        
        #whiptail --backtitle "$BACKTITLE" --title "INSTALLED" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        dialog_msg  "INSTALL:" "$MSG" "white" "OK"
    else
        MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
        #whiptail --backtitle "$BACKTITLE" --title "ERROR" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        dialog_msg  "INSTALL:" "$MSG" "white" "OK"
    fi
}


pisafe_update() {
    INTERFACE=${1:-"cli"}
    SUMMARY=${2:-"yes"}
    local YES=${3:-"-n"}
      
    local SERVER_VER=
    #rm $SCRIPTNAME.tmp
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/$SCRIPTNAME -O $SCRIPTNAME.tmp 2> /dev/null 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ];  then
        echo_if_cli "ERROR: Can't connect to server..."
        return $EXIT_CODE
    fi    

    # did we get the new version from the server?
    if [ -f $SCRIPTNAME.tmp ]; then
        SERVER_VER=$(bash $SCRIPTNAME.tmp -v)
    else
        return 1
    fi

    if [ $(get_ver_to_int $SERVER_VER) -gt $(get_ver_to_int $SCRIPTVER) ]; then
      if [ $YES = "-y" ]; then
        RESULT="y"
      else
        RESULT=$(dialog_yesno "UPDATE AVAILABLE" "Update $PRODUCTNAME from '$SCRIPTVER'  to '$SERVER_VER' ")
      fi
    if [ $RESULT = "y" ]; then 
        sudo mv $SCRIPTNAME.tmp /usr/local/bin/$SCRIPTNAME
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo "$($SCRIPTNAME -v) installed. Press any key to exit... "
        read -n 1
        exit 0
    fi
    else  
        rm $SCRIPTNAME.tmp
       if [ $SUMMARY = yes ]; then
            dialog_msg "UPDATE" "$PRODUCTNAME is up to date.  Server ver is '$SERVER_VER' "
       fi
    fi
}


pisafe_uninstall(){
    SILENT=${1:-"-n"}
    
    if [ $SILENT != "-y" ]; then
        RESULT=$(dialog_yesno "UNINSTALL" "Uninstall $PRODUCTNAME")
        if [ $RESULT != "y" ]; then
            dialog_msg "UNINSTALL" "$PRODUCTNAME not uninstalled"
            return
        fi
    fi
    
    do_write_log "Uninstalling $PRODUCTNAME $INSTALLED_VER"
    
    # remove from the menu
    sudo rm -f "/usr/share/applications/$PRODUCTNAME.desktop"
    # next line cleans up an old configuration
    rm -f "$HOME/.local/share/applications/$PRODUCTNAME.desktop"
    
    # remove the script and config
    sudo rm -f "/usr/local/bin/$SCRIPTNAME"
    rm -f $CONFIG
    
    if [ ! -z "/usr/local/bin/$SCRIPTNAME" ]; then
        echo $PRODUCTNAME uninstalled
    fi
    
    dialog_msg "UNINSTALL" "$LOG_FILE not removed" "white" "OK"
    #rm -f $LOG_FILE
}



# ---------- Media functions
media_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE
    fi
}


media_size() {
    local DEV=$1
    local HUMAN=${2:-"no"}
   
     # add '/dev/' if missing
    if [ "${DEV:0:5}" != "/dev/" ]; then
        #echo "Device prefix not specified.  Adding '/dev/'"
        DEV="/dev/"$DEV
        #echo "IN-DEV='$INDEV'"
    fi
   
    SIZE_BYTES=$(lsblk $DEV -d -n -b -o size  2> /dev/null)
    EXIT_CODE=$?
        
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE       
    fi
    
    if [ $HUMAN = "-h" ]; then
        echo $(get_bytes_h $SIZE_BYTES)
    else
        echo $SIZE_BYTES
    fi
    
# an alternative way:
# echo $(( $(sudo blockdev --getsize64 /dev/sda) ))
# echo $(( $(sudo blockdev --getsize64 /dev/sda)/1024/1024 ))mb    
}


media_serialno(){
    local DEVICE=$1
    # currently vendor + SN
    SN=$(lsblk -n -d --output vendor,model,serial "$DEVICE" | sed 's/ /_/g' )
    echo $SN
}


media_backup(){
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img
    
    local INDEV=$1
    OUTFILE=$2
    local SAFETY=${3:-on}   # off lets us bypass some of the safety prompts
    INTERFACE=${4:-cli}  #CLI or gui
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Backup...
    echo "IN-DEV='$INDEV'"
    echo "OUT-FILE='$OUTFILE'"
    echo  "Compression set to level $COMPRESSION of 9"
    do_write_log "Starting $PRODUCTNAME $SCRIPTVER Backup, '$INDEV' '$(media_name $INDEV)', '$OUTFILE', Compression=$COMPRESSION"
      
    if [ $INTERFACE = "cli" ]; then
        check_indev
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi     
        
        check_outfile   
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi 
    fi    
    
    # should be able to delete this...
    # Final check before writing data
    if [ -z $INDEV ] || [ ! -e $INDEV ] ; then
        echo
        echo_red "ERROR b1: IN-DEV '$INDEV'.  Can't be blank.  Must exist."
        return 1
    fi 
    
    if [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] ; then
        echo
        echo_red "ERROR b2: OUT-FILE '$OUTFILE'. Cant be blank. Can't exist. "
        return 2
    fi  

    #################################################
    # this section writes the data
    #################################################
    OUTFILE_BASE=$(file_path_base "$OUTFILE" )

    TIME1=$(date +%s)
    echo_white "Step 1 of 3 - Reading  '$INDEV' to '$OUTFILE_BASE.img' ... "
    date
    
    BS=$(( 4 * 1024 * 1024 ))
    BLOCKS_TO_READ=$(( $(media_size $INDEV) / $BS ))
    
    
# new section #######  
if [ $SKIP_FREESPACE = "on" ]; then

  #  echo __$PRODUCTNAME will ignore freespace at the end of the device.
    #echo Looking for freespace at end of device to skip...
    START_OF_FREESPACE=$(sudo parted -ms "$INDEV" unit B print free)
    rc=$?
    if (( $rc )); then
        error $LINENO "parted failed with rc $rc"
        exit 15
    fi
    START_OF_FREESPACE=$(tail -1 <<< "$START_OF_FREESPACE" | grep free | cut -d ':' -f 2 | tr -d 'B')
    #echo __start_of_freespace=$START_OF_FREESPACE
    if ! (( $START_OF_FREESPACE )); then 
        #echo No freespace found. 
        START_OF_FREESPACE=$(media_size $INDEV)
    #else     
       # echo Skipping $( get_bytes_h $(( $(media_size $INDEV) - $START_OF_FREESPACE )) ) of freespace at end of media.  
    fi

    BYTES_TO_READ=$START_OF_FREESPACE
    BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1))

    echo Media size=$(media_size $INDEV -h)
    echo Skipping $(get_bytes_h $(( $(media_size $INDEV) - $START_OF_FREESPACE )) ) of freespace found at end.
    echo Reading=$(get_bytes_h $START_OF_FREESPACE)

else
  BYTES_TO_READ=$(media_size $INDEV)
  BLOCKS_TO_READ=$(( $BYTES_TO_READ / $BS + 1))

fi    
#end of new section    
    
    #sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img status=progress conv=fsync 
   MEDIA_SIZE=$(sudo lsblk -ndb $MEDIA -o size)
    if [ ! -z $(which pv) ]; then
		sudo pv $INDEV -s $BYTES_TO_READ $DEVICE | dd bs=$BS of="$OUTFILE_BASE".img count="$BLOCKS_TO_READ" iflag=fullblock conv=fsync 
		EXIT_CODE=$?
    else
      echo "Note: 'pv' is not installed so there is no progress indicator for this step. Please wait..."
      sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img  conv=fsync 
      EXIT_CODE=$?
    fi
    
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    sleep 5s
    echo Done reading SD card
    echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
    TIME2=$(date +%s)  
    echo_white Step 1 took $(get_elapsed_time $TIME1 $TIME2)
    echo
   
   
   if [ ! $(file_ext "$OUTFILE") = "iso" ]; then 
        echo_white "Step 2 of 3 - Shrinking filesystem with PiShrink ..."
        PI_SHRINK_OPTS=

        if [ $AUTO_EXPAND_FS = "off" ] ; then 
            PI_SHRINK_OPTS="-s"
        fi
        if [ $SHRINK_FS != "off" ]; then
            sudo pishrink.sh $PI_SHRINK_OPTS "$OUTFILE_BASE".img
            EXIT_CODE=$?
            if [ $EXIT_CODE != 0 ]; then
                echo Continuing without shrinking file system
            fi
        else
            echo "Filesystem not shrunk.  Setting is 'off'."
        fi
        # sleep to allow the file size to register with the OS
        sleep 5
        echo Done shrinking filesystem.
        echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
        TIME3=$(date +%s)
        echo_white Step 2 took $(get_elapsed_time $TIME2 $TIME3)
    fi
    
    
    echo
    echo_white "Step 3 of 3 - Compressing '$OUTFILE_BASE.img' to '$OUTFILE' ... "
    date
    echo Compression set to level $COMPRESSION of 9
    echo "$(file_size $OUTFILE_BASE.img -h) to compress."
    
   
    case $(file_ext "$OUTFILE") in
        img)
            echo Not compressing .img file ...
        ;;
        
        iso)
            echo Not compressing .iso file ...
            mv $OUTFILE_BASE.img $OUTFILE_BASE.iso
        ;;
        
        zip)
         #   local FILESIZE_M=$(( $(file_size "$OUTFILE_BASE".img)/1024/1024 ))
          #  sleep 5
            # the sleep and second file_size is to let the 
            local FILESIZE_M=$(( $(file_size "$OUTFILE_BASE".img)/1024/1024 ))
            local DOTSIZE=$(( $FILESIZE_M / 50 ))m
            echo Each dot=$DOTSIZE MB
            echo -n "                      $OUTFILE_BASE.img"
            echo "...........25...........50...........75..........100%"
            zip -dbds $DOTSIZE -m -$COMPRESSION "$OUTFILE" "$OUTFILE_BASE".img
            EXIT_CODE=$?
            
            #With progress bar... loses .img in the image
            #sudo pv "$OUTFILE_BASE".img | sudo zip -$COMPRESSION  > "$OUTFILE"
            #EXIT_CODE=$? 
            #sudo rm -f "$OUTFILE_BASE".img 
        ;;
        
        xz)
            #sudo xz -z -v -T0 -$COMPRESSION "$OUTFILE_BASE".img
            #EXIT_CODE=$?     
            ##OUTFILE="$OUTFILE_BASE".img.xz
            ##sudo mv "$OUTFILE_BASE".img.xz "$OUTFILE"  
            
            # With progress bar
            if [ ! -z $(which pv) ]; then
				pv "$OUTFILE_BASE".img | xz -z -c -T0 -$COMPRESSION > "$OUTFILE"
				EXIT_CODE=$? 
			else
			  sudo xz -z -v -T0 -$COMPRESSION "$OUTFILE_BASE".img
			fi	
            rm -f "$OUTFILE_BASE".img
        ;;
        
        gz)
            #echo $(file_size "$OUTFILE_BASE".img -h) to compress.  Sorry, gz has no progress bar.   Please wait...
            #sudo pigz -v -$COMPRESSION "$OUTFILE_BASE".img
            #EXIT_CODE=$?        
            #sudo mv "$OUTFILE_BASE".img.gz "$OUTFILE"
            #OUTFILE="$OUTFILE_BASE".img.gz

            # With progress bar
            pv "$OUTFILE_BASE".img | pigz -$COMPRESSION > "$OUTFILE"
            EXIT_CODE=$? 
            rm -f "$OUTFILE_BASE".img
            
        ;;
        
        *)
            echo
            echo_red ERROR... unsupported file extension \'$(file_ext "$OUTFILE")\'.
            return 1
        ;;
    esac
    
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "Done compressing '$OUTFILE_BASE.img' to '$OUTFILE' "
    echo_white $(ls -s -h "$OUTFILE")
    TIME4=$(date +%s)
    echo_white  Step 3 took $(get_elapsed_time $TIME3 $TIME4)
    
    
    # check if "$OUTFILE" was created
    if [ ! -f "$OUTFILE" ]; then
        echo
        echo_red "ERROR: creating '$OUTFILE'"
        return 1
    fi    
    
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        do_write_log "FAILED $PRODUCTNAME $SCRIPTVER Backup, IN-DEV='$INDEV',  OUT-FILE='$OUTFILE', Compression set to level $COMPRESSION"
        return $EXIT_CODE
    else
        do_beep_if_sound
        echo_white "Backup done. '$INDEV' backed up to '$OUTFILE' in $(get_elapsed_time $TIME1 $TIME4)." 
        do_write_log "Finished $PRODUCTNAME $SCRIPTVER Backup,  $(media_size $INDEV -h) to  $(file_size "$OUTFILE" -h) in $(get_elapsed_time $TIME1 $TIME4) " 
    fi
}


media_restore(){
    local INFILE=$1
    local OUTDEV=$2
    local SILENT=${3:-"-n"}   # this lets us bypass some of the safety prompts
    INTERFACE=${4:-cli}  #CLI or gui


#echo silent=$SILENT $INTERFACE
#exit
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Restore...
    echo "IN-FILE='$INFILE'"
    echo "OUT-DEV='$OUTDEV'"
    echo "Safety='$SAFETY'"
    do_write_log "Starting $PRODUCTNAME $SCRIPTVER Restore, '$INFILE', '$OUTDEV' '$(media_name $OUTDEV)'"
 
    
    if [ $SILENT != "-y" ]; then
        check_infile
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    
        check_outdev
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    fi

    # Final check before writing data
    # quit if INFILE is not a file
    if [ -z "$INFILE" ] || [ ! -e "$INFILE" ]; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank. must exist."
        return 1
    fi 
    
    #quit if OUTDEV is not a device
    if [ -z $OUTDEV ] || [ ! -e $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank.  must exist."
        return 1
    fi
    
    
    if [ $SILENT != "-y" ]; then
        echo
        echo "Write '$INFILE' to '$OUTDEV' '$(media_name $OUTDEV)' ?"
        echo_red WARNING... All existing data on \'$OUTDEV\' - will be erased!
        do_beep_if_sound
        read  -p "You must type 'YES' to continue:" -r RESULT
        echo
    
        if [ -z $RESULT ] || [ $RESULT != "YES" ]; then
            echo "You did not answer 'YES'"
            return 1
        fi
        
        do_beep_if_sound
        echo_red "WARNING '$OUTDEV' '$(media_name $OUTDEV)' "
        echo_red "Will be overwritten starting in 10 seconds ... Ctrl-C to stop"
        do_countdown 10
    fi
    
    #################################################
    # this section writes the data
    #################################################
    
    echo_if_cli Unmounting SD-card $OUTDEV ...
    umount $OUTDEV?  2> /dev/null
    
    local INFILEEXT=$(file_ext "$INFILE")
    
    echo_if_cli "Erasing MBR, signature, and partition table from '$OUTDEV'..." "white"
	sudo dd if=/dev/zero of=$OUTDEV bs=512 count=1 > /dev/null
    
    echo        
    echo_white "Writing '$INFILE' to '$OUTDEV' ... "    
    date
    TIME1=$(date +%s)
    echo_if_cli "$(file_image_size "$INFILE" -h) to write"
    
    case $INFILEEXT in
        img | iso)
            if [ $INTERFACE = "cli" ]; then
                #sudo dd if="$INFILE" of=$OUTDEV bs=4M conv=fsync status=progress
                pv "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync
                EXIT_CODE=$?
            else
                (sudo pv -n "$INFILE" | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                EXIT_CODE=$?
            fi
        ;;
        
        zip)
            RESTORE_BYTES=$(file_image_size "$INFILE")
             if [ $INTERFACE = "cli" ]; then
                 #unzip -p "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 #pv "$INFILE" | unzip -p | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 unzip -p "$INFILE" | pv -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M conv=fsync
                 EXIT_CODE=$?
            else
                (unzip -p "$INFILE" | pv -n -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                 EXIT_CODE=$?
            fi
        ;;
        
        xz)
            if [ $INTERFACE = "cli" ]; then
                 #xz -v -d -c "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 pv "$INFILE" | xz -d -c | sudo dd of=$OUTDEV bs=4M conv=fsync
                 EXIT_CODE=$?
            else
                (sudo pv -n "$INFILE" | xz -d -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                EXIT_CODE=$?
            fi
        ;;

        gz)
            if [ $INTERFACE = "cli" ]; then
                #pigz -v -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                pv "$INFILE" | pigz -d -k -c | sudo dd of=$OUTDEV bs=4M conv=fsync
                EXIT_CODE=$?
            else
                (pv -n "$INFILE" | pigz -d -k -c | sudo dd of=$OUTDEV bs=4M conv=fsync) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(media_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                EXIT_CODE=$?
            fi    
        ;;

        *)
            echo
            echo_red ERROR.  Unsupported file extension. 
            return  1 
        ;;

    esac        
    TIME2=$(date +%s)
    echo
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        do_write_log "Restore failed $EXIT_CODE"
        return $EXIT_CODE
    else
        do_beep_if_sound
        echo_white "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
        do_write_log "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
    fi
}


media_list() {
    local DEVICES= 
    ROOT_FILTER="aspodiausdfpoiasdf"
    if [ $(config_var_get hide_root_device $CONFIG) = "on" ]; then
        ROOT_FILTER=$(env_root_device)
    fi   
    
    if [ -z $ROOT_FILTER ]; then
       ROOT_FILTER="aspodiausdfpoiasdf"
    fi     
       
    DEVICES=$(lsblk -I 8,179 -dnpo NAME,VENDOR,MODEL,SIZE 2> /dev/null | grep -v $ROOT_FILTER)
    EXIT_CODE=$?

    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "${DEVICES[@]}"
  }


media_details(){
    local MEDIA=$1
    local MSG=
    MSG="Media: $(media_name $MEDIA) \n"
    echo "Serching for OSs..."
    MSG=$MSG"$(media_os $MEDIA)"
    echo "Calculating backup estimates..."
   # MSG="$(media_backup_estimate  $INDEV)"
    MSG="$MSG\n$(media_backup_estimate  $MEDIA)"
    MSG="$MSG\n\n===== PARTITION TABLE DETAILS ===== \n$(sudo parted -s $MEDIA print free) \n\n"
    MSG="$MSG$(lsblk $MEDIA -o maj:min,fssize,fsused,fsavail,fsuse%)\n\n"
    
   dialog_msg "MEDIA DETAILS: '$(media_name $MEDIA)'" "$MSG"
}


media_partition_os() {
  MEDIA=$1
  PARTITION=$2
  OS=
  BITS=
  
  PARTED_OUTPUT=$(sudo parted -ms $MEDIA print)
  MEDIA_PARTITION_TABLE=$(echo "$PARTED_OUTPUT" | head -n 2 | tail -n 1 | cut -d: -f6)   # msdos, gpt, other
  case $MEDIA_PARTITION_TABLE in
  msdos)
    MEDIA_PARTITION_FS="$(echo "$PARTED_OUTPUT" | grep ^$PARTITION: | cut -d ':' -f 5)"
    if [ ! "$MEDIA_PARTITION_FS" = "ext4" ]; then
      return 2
    fi
    ;;
  gpt)
    MEDIA_PARTITION_FS="$(echo "$PARTED_OUTPUT" | grep ^$PARTITION: | cut -d ':' -f 4)"
    ;;
  *)
    ;;
  esac	
  
  
  PARTED_OUTPUT=$(sudo parted -ms "$MEDIA" unit B print)
  if (( $? )); then
    return 1
  fi	
  

  # mount filesystem
  PARTSTART="$(echo "$PARTED_OUTPUT" | grep ^$PARTITION: | cut -d ':' -f 2 | tr -d 'B')"
  loopback="$(sudo losetup -f --show -o "$PARTSTART" "$MEDIA")"
  if (( $? )); then
    echo ...retrying...
    sleep 1
    loopback="$(sudo losetup -f --show -o "$PARTSTART" "$MEDIA")"
     if (( $? )); then
       return 3
     fi  
  fi

  mountdir=$(mktemp -d)
  sudo mount "$loopback" "$mountdir"
  if (( $? )); then
    sudo losetup -d "$loopback"
    return 4
  fi
	
  
  # look for OS name
  if [ -e $mountdir/etc/os-release ]; then
    OS="$(cat $mountdir/etc/os-release | grep PRETTY_NAME | cut -d= -f2)"
    ARCH="$(file $mountdir/bin/bash | cut -d, -f2)"
    BITS="$(file $mountdir/bin/bash | cut -d, -f1)"
    if  [ !  -z "$(echo "$BITS" | grep 32 )" ]; then
      BITS=32
    elif [ !  -z "$(echo "$BITS" | grep 64 )" ]; then
      BITS=64
    fi
    if [[ ! "$ARCH" =~  "$BITS" ]]; then
      ARCH=$ARCH"-"$BITS
    fi  
    
    OS="$OS '$ARCH'" 
     
  else
    sudo umount "$mountdir"	
    sudo losetup -d "$loopback"
    return 5
  fi	

  # unmount and cleanup
  sudo umount "$mountdir"	
  sudo losetup -d "$loopback"

  echo $OS
}


media_os() {
  local MEDIA=$1
  local MSG=

 PARTED_OUTPUT=$(sudo parted -ms $MEDIA print)  # no freespace
#  MEDIA_PARTITION_TABLE=$(echo "$PARTED_OUTPUT" | head -n 2 | tail -n 1 | cut -d: -f6)   # msdos, gpt, other
#  MEDIA_PARTITION_COUNT=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1 | wc -l)
  MEDIA_PARTITION_LIST=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1)

 # echo Looking for operating systems on partitions...
  for PARTITION in $MEDIA_PARTITION_LIST; do
    OS=$(media_partition_os $MEDIA $PARTITION)
    RC=$?
     if ! (( $RC )); then
      echo "$OS found on Partition $PARTITION\n"
    fi
  done

}


media_backup_estimate() {
  local MEDIA=$1
  local MSG=
  
  if [ ! -e $MEDIA ]; then
    MSG="Error: Media '$MEDIA' does not exist"
    return 1
  fi
  
  MEDIA_SIZE=$(sudo lsblk -ndb $MEDIA -o size)
  PARTED_OUTPUT=$(sudo parted -ms $MEDIA print)  # no freespace
  MEDIA_PARTITION_TABLE=$(echo "$PARTED_OUTPUT" | head -n 2 | tail -n 1 | cut -d: -f6)   # msdos, gpt, other
  MEDIA_PARTITION_COUNT=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1 | wc -l)
  MEDIA_PARTITION_LIST=$(echo "$PARTED_OUTPUT" | grep ^[1-9]: | grep -v ":::;" | cut -d: -f1)
  MEDIA_LAST_PARTITION_NUMBER=$(echo "$PARTED_OUTPUT" | tail -1 | cut -d: -f1)
  
  case $MEDIA in
      /dev/sd*)
        MEDIA_LAST_PARTITION_NAME=$MEDIA$MEDIA_LAST_PARTITION_NUMBER
      ;;
      
      /dev/mmcblk*|/dev/nvme*)
         MEDIA_LAST_PARTITION_NAME=$MEDIA"p"$MEDIA_LAST_PARTITION_NUMBER
      ;;
  esac
  
  PARTED_OUTPUT=$(sudo parted $MEDIA unit B print free )
  
  MEDIA_FREESPACE_AT_END=$(echo "$PARTED_OUTPUT" | tail -1 | grep Free | sed 's/[ ]\+/ /g' | cut -d " " -f 4 | tr -d 'B' )
  if [ -z $MEDIA_FREESPACE_AT_END ]; then
    MEDIA_FREESPACE_AT_END=0
  fi
 
  case $MEDIA_PARTITION_TABLE in
      msdos)
        MEDIA_LAST_PARTITION_TYPE=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f6)
        MEDIA_LAST_PARTITION_FS=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f7)
        ;;
      gpt)
        MEDIA_LAST_PARTITION_TYPE=
        MEDIA_LAST_PARTITION_FS=$(echo "$PARTED_OUTPUT" | grep -v Free | tail -1 | sed 's/[ ]\+/ /g' | cut -d " " -f6)
        ;;
      *)
        ;;
  esac	


  MSG=$MSG"\n===== MEDIA BACKUP ESTIMATES ===== \n"
  MSG=$MSG"Media size                         =  $(get_bytes_h $MEDIA_SIZE)\n"


  #1 - free space
   MSG=$MSG$(printf '%-35.34s' "Remove '$(get_bytes_h $MEDIA_FREESPACE_AT_END)' of freespace")
   MSG=$MSG"=> $(get_bytes_h $(($MEDIA_SIZE - MEDIA_FREESPACE_AT_END )) ) \n"

  
  # 2 - is it a complex file system?
  if [ $MEDIA_PARTITION_COUNT -gt 3 ]; then
    MSG=$MSG"Warning: Partitions=$MEDIA_PARTITION_COUNT.  This looks like a complex partition structure and may not shrink. Pisafe will still work.\n"
  fi

  
  
  # 3 - ext and not logical?
    SHRINK_BYTES=0
    UNCOMPRESSED_BYTES=0
  case $MEDIA_LAST_PARTITION_FS in
  
      ext4|ext3|ext2)
	  # echo "The filesystem on the last partition ($MEDIA_LAST_PARTITION_NUMBER) is 'ext4' so this filesystem should shrink.  $(media_partition_size $1 $MEDIA_PARTITION_COUNT)"
	  if [ $MEDIA_PARTITION_TABLE = "gpt" ] || ( [ $MEDIA_PARTITION_TABLE = "msdos" ] && [ $MEDIA_LAST_PARTITION_TYPE = "primary"  ] ) ; then
	    #SHRINK_BYTES=$(sudo lsblk $MEDIA -bo maj:min,fsavail | grep :$MEDIA_LAST_PARTITION_NUMBER | sed 's/^[[:blank:]]*//;s/[ ]\+/ /g'  | cut -d " " -f2)
       SHRINK_BYTES=$(sudo lsblk $MEDIA -lpbo name,fsavail | grep $MEDIA_LAST_PARTITION_NAME | sed 's/^[[:blank:]]*//;s/[ ]\+/ /g'  | cut -d " " -f2)
      else
	    MSG=$MSG"Warning: The last partition type is '$MEDIA_LAST_PARTITION_TYPE'. This filesystem will not shrink and cannot be restored to a smaller media. Pisafe will still work.\n"
	  fi
	  ;;
      
      
      *)
	    MSG=$MSG"Warning: The last partition fs is '$MEDIA_LAST_PARTITION_FS'. This filesystem will not shrink and cannot be restored to a smaller media. Pisafe will still work.\n"
	  ;;
  esac
  
    if [ -z $SHRINK_BYTES ]; then
      SHRINK_BYTES=0
    fi
    
  # 4 Shrink Filesystem  
  UNCOMPRESSED_BYTES=$(( $MEDIA_SIZE - $MEDIA_FREESPACE_AT_END - $SHRINK_BYTES ))
  MSG=$MSG$(printf '%-35.34s' "Shrink filesystem by $(get_bytes_h $SHRINK_BYTES)")
  MSG=$MSG"=> $(get_bytes_h $UNCOMPRESSED_BYTES ) \n"
  
  # 5 Compression
  MSG=$MSG"Estimated compression 2:1          => $(get_bytes_h $((UNCOMPRESSED_BYTES / 2 ))) \n"
  
  echo "$MSG"
	
}


media_format_fat32(){
    local DEVICE=$1
    local SILENT=${2:-n}  #-y or -n
    local ROOT="/dev/$(env_root_device)"
    local TYPE=$(lsblk $DEVICE -dnpo TYPE)
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local PART1=$DEVICE\1
    

    if [ -z $1 ] ; then
        echo "Error 1: Device not specified, choose:"
        #lsblk -dp
        return 1
    fi

    #check that DEVICE exists
    if [ ! -e $DEVICE ]; then
      echo "Error 2: $DEVICE does not exist"
      return 2
    fi

    if [ $1 = $ROOT ] ; then
        echo "Error 3: Can not format root device"
        return 3
    fi
    
    if  [ $TYPE != disk ]; then
        echo "Error 4: $DEVICE is not a disk"
        return 4
    fi
    
 
    if [ $SILENT != "-y" ]; then
        RESULT=$(dialog_yesno "ERASE MEDIA" "All existing data on '$NAME' ($DEVICE) will be erased.  Are you sure you want to continue? y/n?")
        if [ $RESULT != "y" ]; then
            echo
            dialog_msg "ERASE MEDIA" "'$DEVICE' not erased"
            return
        fi
    fi
 
 
 
    do_beep_if_sound
    dialog_countdown 10 "" "Erasing Media '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        dialog_msg "ERASE MEDIA" "Erase Media stopped... \n\nA key was pressed. "
        #whiptail --backtitle "$BACKTITLE" --title "ERASE MEDIA" --msgbox "Erase Media stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
        return $EXIT_CODE
    fi    
 

    echo_white Formatting $DEVICE...

    echo Unmounting $DEVICE...
    umount $DEVICE?


    #echo Writing zeros to $DEVICE...
    #sudo dd if=/dev/zero of=$DEVICE bs=512 count=4
    #if (( $? != 0 )); then
    #    echo "Error 9: writing zeros failed"
    #    return 9
    #fi


    #echo label $DEVICE msdos...
    echo Writing new MBR partition table to $DEVICE...
    sudo parted -s $DEVICE mklabel msdos
    if (( $? != 0 )); then
        echo "Error 10: mklabel failed"
        return 10
    fi


    echo Creating fat32 partition on $DEVICE...
    sudo parted -s -a opt $DEVICE mkpart primary fat32 4M 100%
    #sudo parted -s -a opt $DEVICE mkpart primary ext4 0% 100%
    if (( $? != 0 )); then
        echo "Error 11: mkpart failed"
        return 11
    fi


    echo Formatting the partition to fat32...
    #sudo mkfs -t vfat $PART1
    sudo mkfs.vfat $PART1
    #sudo mkfs.ext4 $PART1
    #sudo mkfs.ntfs -f $PART1
    if (( $? != 0 )); then
        echo "Error 12: mkfs failed"
        return 12
    fi


    #echo Mount the drive...
    #mkdir -p "/home/$USER/$NAME"
    #check_exit_code $?
    #sudo mount $PART1 "/home/$USER/$NAME"
    #check_exit_code $?

TEST_RESULTS=Succeeded

echo
dialog_msg "ERASE MEDIA" "'$NAME' ($DEVICE) has been erased \n\nYou can remove the SD card from the reader"

do_write_log "ERASE MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}


media_wipe(){
    local DEVICE=$1
    local SILENT=${2:-n}  #-y or -n
    local ROOT="/dev/$(env_root_device)"
    local TYPE=$(lsblk $DEVICE -dnpo TYPE)
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local PART1=$DEVICE\1    
    
    if [ -z $1 ] ; then
        echo "Error 1: Device not specified, choose:"
        return 1
    fi

    if [ ! -e $DEVICE ]; then
      echo "Error 2: $DEVICE does not exist"
      return 2
    fi
    
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))



    if [ $1 = $ROOT ] ; then
        echo "Error 3: Can not wipe root device"
        return 3
    fi
    
    if  [ $TYPE != disk ]; then
        echo "Error 4: $DEVICE is not a disk"
        return 4
    fi

    
 
    if [ $SILENT != "-y" ]; then
        RESULT=$(dialog_yesno "WIPE MEDIA" "All existing data on '$NAME' ($DEVICE) will be erased.  Are you sure you want to continue? y/n?")
        if [ $RESULT != "y" ]; then
            echo
            dialog_msg "WIPE MMEDIA" "'$DEVICE' not erased"
            return
        fi
    fi
 
    #Countdown 
    do_beep_if_sound
    dialog_countdown 10 "" "Wiping Media '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        #whiptail --backtitle "$BACKTITLE" --title "WIPE MEDIA" --msgbox "Wipe Media stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
        dialog_msg "WIPE MEDIA" "Wipe Media stopped... \n\n a key was pressed. "
        return $EXIT_CODE
    fi    

  
    echo_white Wiping $DEVICE...

    echo Unmounting $DEVICE...
    umount $DEVICE?

    
    MESSAGE="Wiping '$NAME' $DEVICE\n\nWriting zeros to $DEVICE... "  
    if [ $INTERFACE = "cli" ]; then
        echo_white "Writing zeros to $DEVICE... "  
        pv -s $DEVICE_SIZE_BYTES /dev/zero | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT
        EXIT_CODE=$?
    else
        (sudo pv -n -s $DEVICE_SIZE_BYTES /dev/zero | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "WIPE MEDIA" --gauge "\n$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 5
        TEST_RESULTS=Failed
        return 5
    else
        TEST_RESULTS=Succeeded
        
    fi

    echo
    dialog_msg "WIPE MEDIA" "'$NAME' ($DEVICE) has been wiped with zeros \n\nYou can remove the SD card from the reader"   
    
    do_write_log "WIPE MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
    
}


media_test(){
    local DEVICE=$1
    local SKIP=${2:-"0"}
    local NAME=$(lsblk $DEVICE -dnpo VENDOR,MODEL,SIZE)
    local ROOT="/dev/$(env_root_device)"
    local TEMP_FILE=tmpfile.img
    
    if [ -z $1 ] ; then
        echo "Error 1: Device not specified, choose:"
        return 1
    fi

    if [ ! -e $DEVICE ]; then
      echo "Error 2: $DEVICE does not exist"
      return 2
    fi
    
    if [ $1 = $ROOT ] ; then
        echo "Can not format root device"
        return 1
    fi
    
    DEVICE_SIZE=$(lsblk  $DEVICE -dno  size )
    DEVICE_SIZE_BYTES=$(lsblk  $DEVICE -dbno  size )
    
    # block=4M
    BLOCK_SIZE_BYTES=$((1024*1024*4))
    BLOCK_SIZE=$(( $BLOCK_SIZE_BYTES / 1024 / 1024 ))MB
    
    DEVICE_BLOCK_COUNT=$(( $DEVICE_SIZE_BYTES / $BLOCK_SIZE_BYTES ))
    
 #   echo_white Testing $DEVICE $NAME...
 #   echo An 8GB Sandisk industrial microSD card takes 25 min on a raspberry pi 4
 #   echo "'$NAME' ($DEVICE) will be completely erased in testing.  Back it up first if needed.  Are you sure you want to continue? y/n?"
 #   read -n 1 -r RESULT
 #   echo
 
    RESULT=$(dialog_yesno "TEST MEDIA '$NAME' $DEVICE"   "'$NAME' ($DEVICE) will be completely erased in testing.  Back it up first if needed.  Are you sure you want to continue?")
    if [ $RESULT != 'y' ] ; then
      return 3
    fi
    
    
    # countdown
    do_beep_if_sound
    dialog_countdown 10 "" "Overwriting '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA" --msgbox "Test Media stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
        return $EXIT_CODE
    fi    
    
    echo_white Unmounting $DEVICE...
    umount $DEVICE?
    
    # test with Ones
    date 
    TIME1=$(date +%s)
    MESSAGE="\nTESTING ONES\nStep 1 of 6: Writing  ... "
    if [ $INTERFACE = "cli" ]; then
        echo_white "Step 1 of 6: Writing  ..."   
        tr '\000' '\377' </dev/zero | sudo pv -s $DEVICE_SIZE_BYTES | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT 
        EXIT_CODE=$?
    else
        (tr '\000' '\377' </dev/zero | sudo pv -n -s $DEVICE_SIZE_BYTES | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT  ) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 2
        return 2
    fi
    
    
    date
    TIME2=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME1 $TIME2))\nStep 2 of 6: Reading  ... "
     if [ $INTERFACE = "cli" ]; then
        echo_white "Step 2 of 6: Reading  ..."
        sudo pv -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT iflag=fullblock 
        EXIT_CODE=$?
     else
        (sudo pv -n -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT iflag=fullblock ) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
     fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 2
        return 2
    fi
    
    
    
    date
    TIME3=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME2 $TIME3))\nStep 3 of 6: Comparing... "
    if [ $INTERFACE = "cli" ]; then
        echo_white "Step 3 of 6: Compare Ones..."
        pv -s $DEVICE_SIZE_BYTES <(tr -dc '\377' <$TEMP_FILE) | cmp $TEMP_FILE
        EXIT_CODE=$?
    else
        (pv -n -s $DEVICE_SIZE_BYTES <(tr -dc '\377' <$TEMP_FILE) | cmp $TEMP_FILE ) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE = 0 ]; then
        echo Files are the same
        ONES_COMPARE=0
        rm $TEMP_FILE -f
    else
        echo_red "Files are different 3   ******  "
        ONES_COMPARE=1
        date
        return 3
    fi
    

    
    # test with zeros
    date
    TIME4=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME3 $TIME4))"
    if [ $ONES_COMPARE = 0 ]; then
        MESSAGE="$MESSAGE\nPASSED "
    else
        MESSAGE="$MESSAGE\nFAILED "   
    fi  
    MESSAGE="$MESSAGE \n\nTESTING ZEROS\nStep 4 of 6: Writing  ... "
    
    
  
    if [ $INTERFACE = "cli" ]; then
        echo_white "Step 4 of 6: Writing zeros to $DEVICE... "  
        pv -s $DEVICE_SIZE_BYTES /dev/zero | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT
        EXIT_CODE=$?
    else
        (sudo pv -n -s $DEVICE_SIZE_BYTES /dev/zero | sudo dd iflag=fullblock of=$DEVICE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 4
        return 4
    fi

    
    
    date
    TIME5=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME4 $TIME5))\nStep 5 of 6: Reading  ... "
     if [ $INTERFACE = "cli" ]; then
        echo_white "Step 5 of 6: Reading zeros from $DEVICE..."
        #sudo dd if=$DEVICE of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT status=progress
        sudo pv -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd iflag=fullblock of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT 
        EXIT_CODE=$?
    else
        (sudo pv -n -s $DEVICE_SIZE_BYTES $DEVICE | sudo dd iflag=fullblock of=$TEMP_FILE bs=$BLOCK_SIZE_BYTES count=$DEVICE_BLOCK_COUNT ) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
         EXIT_CODE=$?
    fi    
    if [ $EXIT_CODE != 0 ]; then
        echo_red ERROR 5
        return 5
    fi
    
    
    
    date
    TIME6=$(date +%s)
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME5 $TIME6))\nStep 6 of 6: Comparing... "
     if [ $INTERFACE = "cli" ]; then
        echo_white "Step 6 of 6:  Compare zeros... "
        #cmp $TEMP_FILE <(tr -dc '\000' <$TEMP_FILE)
        pv -s $DEVICE_SIZE_BYTES <(tr -dc '\000' <$TEMP_FILE) | cmp $TEMP_FILE
        EXIT_CODE=$?
     else
        (pv -n -s $DEVICE_SIZE_BYTES <(tr -dc '\000' <$TEMP_FILE) | cmp $TEMP_FILE ) 2>&1 \
        | whiptail --backtitle "$BACKTITLE" --title "TEST MEDIA '$NAME' $DEVICE" --gauge "$MESSAGE" $WT_HEIGHT $WT_WIDTH 0
         EXIT_CODE=$?
     fi   
    if [ $EXIT_CODE = 0 ]; then
        echo Files are the same
        ZEROS_COMPARE=0
        rm $TEMP_FILE -f
    else
        echo_red "Files are different 6   ******  "
        ZEROS_COMPARE=1
        date
        return 6
    fi
    
    MESSAGE="$MESSAGE (DONE $(get_elapsed_time $TIME5 $TIME6))"
    
    
    if [ $ZEROS_COMPARE = 0 ] && [ $ONES_COMPARE = 0 ]; then
       TEST_RESULTS="PASSED"
       # MESSAGE="$MESSAGE\nPASSED \n"
        
    else
        TEST_RESULTS="FAILED"
      #  MESSAGE="$MESSAGE\nFAILED \n"   
    fi  
    
    
    
    date
    TIME7=$(date +%s)
    echo
    echo ONES_COMPARE=$ONES_COMPARE
    echo ZEROS_COMPARE=$ZEROS_COMPARE
    echo Total time=$(get_elapsed_time Time1 Time7)
    echo
    echo "'$NAME' ($DEVICE) has been tested with zeros and ones.\n\nYou can remove the SD card from the reader"   
    
    MESSAGE="$MESSAGE\n$TEST_RESULTS\n\n$(get_elapsed_time $TIME1 $TIME6)"
    dialog_msg "TEST MEDIA '$NAME' $DEVICE"  "$MESSAGE"
    
    do_write_log "TEST MEDIA '$NAME' on $DEVICE...  $TEST_RESULTS"   
}




########################################
###  WHIPTAIL GUI FUNCTIONS ##############
########################################


whiptail_calc_wt_size() {
    # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
    # output from tput. However in this case, tput detects neither stdout or 
    # stderr is a tty and so only gives default 80, 24 values

    WT_HEIGHT=20
    WT_WIDTH=80
    WT_HEIGHT_TALL=$(($(tput lines)-10))
    WT_WIDTH_WIDE=$(($(tput cols)-7))

    #WT_HEIGHT=$(($(tput lines)-10))
    #WT_WIDTH=$(tput cols)
    #WT_WIDTH=$(($(tput cols)-10))


    if [ -z "$WT_WIDTH" ] || [ "$WT_WIDTH" -lt 60 ]; then
        WT_WIDTH=80
    fi
    if [ "$WT_WIDTH" -gt 178 ]; then
        WT_WIDTH=80
    fi

    #WT_WIDTH=$(($WT_WIDTH-7))
    WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
    WT_MENU_HEIGHT_TALL=$(($WT_HEIGHT_TALL-7))

    #WT_MB_HEIGHT=18
    #WT_MB_WIDTH=70

    WT_MB_HEIGHT=$WT_HEIGHT
    WT_MB_WIDTH=$WT_WIDTH
}


whiptail_fselect() {

#
#  Arguments
#     1  Dialog title
#     2  Source path to list files and directories
#     3  File mask (by default *)
#     4  "yes" to allow go back in the file system.
#
#  Returns
#     0  if a file was selected and loads the FILE_SELECTED variable 
#        with the selected file.
#     1  if the user cancels.
#
#if whiptail_fselect "Please, select a file" /home/user ; then
#        echo "File Selected: \"$FILE_SELECTED\"."
#else
#        echo "Cancelled!"
#fi
# ----------------------------------------------------------------------

    local TITLE=${1:-$MSG_INFO_TITLE}
    local LOCAL_PATH=${2:-$(pwd)}
    local FILE_MASK=${3:-"*"}
    #local FILE_MASK='( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" )'
    local ALLOW_BACK=${4:-no}
    local FILES=()

    [ "$ALLOW_BACK" != "no" ] && FILES+=(".." "..")

    IFS=$'\t\n'

    FILES=("FILENAME" "     SIZE   (IMAGESIZE)")

    # First add folders      
    for DIR in $(find $LOCAL_PATH -maxdepth 1 -mindepth 1 -name "[!.]*" -type d -printf "%f\t" | sort 2> /dev/null)
    do
        FILES+=($DIR  "     folder")
    done              
                
    # Then add files                                
    for FILE in $(find $LOCAL_PATH -maxdepth 1 \
                                     \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" -o -name "*.iso" \) \
                                    -type f \
                                    -printf "%f\t     %s\n" | sort  2> /dev/null)                                                                  
    do
        FILES+=($FILE)
    done
	unset IFS


    # convert filesizes to human readable and add image size
    num='^[0-9]+$'
    arraylength=${#FILES[@]}
    
    if [ $arraylength = 0 ]; then
        FILES=(no files)
    fi
    
    for (( i=0; i<${arraylength}; i++ )); do
		arrayelement=$(echo "${FILES[$i]}" | sed 's/ *//g')
		if [[ "$arrayelement" =~ $num ]] ; then  
            #FILES[$i]=$(echo "    " $(get_bytes_h $arrayelement -h))
            FILES[$i]=$(echo "    " $(get_bytes_h $arrayelement -h) \($(file_image_size "$LOCAL_PATH/$PREVIOUS_ELEMENT" -h)\)) 
		else
            PREVIOUS_ELEMENT=$(echo "${FILES[$i]}")
        fi
    done
 
 
    # let user select file
    while true
    do
        FILE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$LOCAL_PATH" \
                                --menu "Choose a file" $WT_HEIGHT_TALL $WT_WIDTH_WIDE $WT_MENU_HEIGHT_TALL "${FILES[@]}"  3>&1 1>&2 2>&3)

        #exit if bad whiptail statement
        FSX=${FILE_SELECTED:0:3}
        if [ ! -z $FSX ] && [ $FSX = "Box" ]; then
            echo "ERROR in whiptail in whiptail_fselect.  Maybe a space in a filename?"
			echo "${FILES[@]}"
            exit 1
        fi
        
        if [ -z "$FILE_SELECTED" ]; then
            return 1
        else
            if [ "$FILE_SELECTED" = ".." ] && [ "$ALLOW_BACK" != "no" ]; then
                return 0

            elif [ -d "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                if whiptail_fselect "$TITLE" "$LOCAL_PATH/$FILE_SELECTED" "$FILE_MASK" "yes" ; then
                    if [ "$FILE_SELECTED" != ".." ]; then
                        return 0
                    fi
                else
                    return 1
                fi

            elif [ -f "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                FILE_SELECTED="$LOCAL_PATH/$FILE_SELECTED"
                return 0
            fi
        fi
    done
}


whiptail_countdown(){  
    local MAX=${1:-10}
    local TITLE=${2:-"COUNTDOWN... press any key to stop or 'y' to continue now"}
    MSG=${3:-"Countdown for $MAX seconds.\n\n"}

    for ((i=$MAX; i>=0; i--)) ; do
		TERM=vt220 whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --infobox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
		#sleep .75
        read -t 1 -N 1 INPUT
        if [ ! -z $INPUT ]; then
            if [ $INPUT = "y" ]; then
                echo continuing...
                return 0
            else
              echo $INPUT
              return 2
            fi
        fi 
        MSG=$(echo "$MSG.$i")
    done 
}


##############################


menu_set_compression(){
    CHOICE=$(whiptail --title "SETTINGS-COMPRESSION" --radiolist \
    "Choose compression level (your milage may vary)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
    "1" "Fastest time (default)" on \
    "2" "" off \
    "3" "" off \
    "4" "" off \
    "5" "" off \
    "6" "" off \
    "7" "" off \
    "8" "" off \
    "9" "Smallest file (MUCH slower)" off   3>&1 1>&2 2>&3 )
   
    if [ ! -z $CHOICE ]; then
        COMPRESSION=$CHOICE
        config_var_set compression_level $CHOICE $CONFIG
    fi
}

    
menu_default_path(){
    MSG="Enter new default path   '$DEFAULT_PATH'"
    TEMP_PATH="$DEFAULT_PATH"
    while true; do
        NEWPATH=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$TEMP_PATH" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then 
            return $EXIT_CODE
        fi
        
        if [ ! -z $NEWPATH ]; then
        
            if [ -d $NEWPATH ]; then
                DEFAULT_PATH=$(echo "$NEWPATH" | sed 's/[/\t]*$//')
                config_var_set default_path $DEFAULT_PATH $CONFIG
                return 0
            else
                whiptail --title ERROR --msgbox "ERROR Directory '$NEWPATH' does not exist" $WT_MB_HEIGHT $WT_MB_WIDTH
                TEMP_PATH="$NEWPATH"
            fi
        
        fi
    done
}


menu_set_default_extension(){
     CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS-EXTENSION" --radiolist \
            "Choose default extension (compression format)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "zip" "Default" on \
            "xz" "~25% smaller, 3x-4x more time" off \
            "gz" "~25% faster, same size as zip" off  \
            "img" "Twice the size, half the time (No compression)" off 3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        DEFAULT_EXTENSION=$CHOICE
        config_var_set default_extension $CHOICE $CONFIG  
    fi
}


menu_options(){
    #"hide_mmc_device" "Hide internal sd card (CAUTION)" "$HIDE_MMC_DEVICE" \
    #echo "starting menu_options"

    ON=$(whiptail --title "SETTINGS-OPTIONS" --checklist "Enable options" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT \
"shrink_fs" "Shrink filesystem on backup" "$SHRINK_FS" \
"auto_expand_fs" "Create shrunk backup that auto-expands" "$AUTO_EXPAND_FS" \
"hide_root_device" "Hide root device (CAUTION)" "$HIDE_ROOT_DEVICE" \
"check_for_updates_on_startup" "" "$CHECK_FOR_UPDATES_ON_STARTUP" \
"sound" "enable sounds" "$SOUND" \
"log"   "log activity" "$LOG" \
"debug_mode" " " "$DEBUG_MODE" \
 3>&1 1>&2 2>&3) 
    
    if [ $? != 0 ] ; then
        return
    fi
    
    # dump the quotes in the string.
    ON=$(echo $ON | sed 's/"//g')
    
    # set all to off
    config_var_set shrink_fs off $CONFIG
    config_var_set auto_expand_fs off $CONFIG
    config_var_set hide_root_device off $CONFIG
    config_var_set sound off $CONFIG
    config_var_set log off $CONFIG
    config_var_set debug_mode off $CONFIG
    config_var_set check_for_updates_on_startup off $CONFIG
    
    for SELECTED in $ON; do
        config_var_set $SELECTED on $CONFIG
    done
    config_var_get_settings
    }


menu_settings(){
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --cancel-button "Back" --menu " " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT  \
        "Default directory   " "$DEFAULT_PATH" \
        "Default extension   " "$DEFAULT_EXTENSION" \
        "Compression         " "$COMPRESSION of 9" \
        "Options             " "Several options to turn on/off " \
        "                    " "      " \
        "Edit config file    " "Edit the settings file manually (pisafe.conf)" \
        "Factory defaults    " "Reset settings to factory defaults" \
        3>&1 1>&2 2>&3)
        
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        else
            case "$SELECTION" in
            "Default d"*)   menu_default_path ;;
            "Default e"*)   menu_set_default_extension ;;
            "Compression"*) menu_set_compression ;;
            Text*)          ;;
            Options*)      menu_options ;;

            "    "*)        ;;
            Edit*)          $TEXT_EDITOR $CONFIG; config_var_get_settings ;;
            Factory*) 
                whiptail --title WARNING --defaultno --yesno "Are you sure you want to reset the settings to factory defaults?" $WT_MB_HEIGHT $WT_MB_WIDTH 
                if [ $? = 0 ] ; then
                    config_var_factory_reset 
                fi ;;
            
             *)             whiptail --msgbox "Programmer error: unrecognized option" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT ;;
            esac
        fi
    done
}


menu_select_sddevice(){
    TITLE=$1
    FIELD_SEPERATOR="|"

    #get this list of sd devices and add a field seperator |    
    IFS=$'\n'
    options=($(media_list | sed 's/ / '$FIELD_SEPERATOR' /'))
    unset IFS
    
    arraylength=${#options[@]}
    if [ $arraylength = 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No media found." $WT_MB_HEIGHT  $WT_MB_WIDTH
        return 1
    fi

    IFS=$FIELD_SEPERATOR
    DEVICE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$TITLE"\
   --menu "Select media (Hide root = $HIDE_ROOT_DEVICE)" $WT_MB_HEIGHT $WT_MB_WIDTH 10 ""${options[@]}"" 3>&1 1>&2 2>&3)
 
    EXIT_CODE=$?
    unset IFS   
     
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    OUTDEV=$DEVICE_SELECTED
    INDEV=$DEVICE_SELECTED
    return 0
}


menu_get_outfile(){
    OUTFILEDEFAULT="$DEFAULT_PATH/$(date +%Y-%m-%d-newimage)"
    EXT=$DEFAULT_EXTENSION
    OUTFILE=
           
    MEDIA_OS="$(media_os  $INDEV)"       
           
  #  echo "Calculating backup estimates..."
    ESTIMATES=$(media_backup_estimate $INDEV)     
  #  echo "$ESTIMATES"     
  #  echo       
           
     while true; do   
    
        #get filename
        MSG="$MEDIA_OS \
        \n$ESTIMATES\n===== BACKUP FILENAME ===== \
        \nIf you don't include an extension '.img.$DEFAULT_EXTENSION' will be added \
        \n\nSupported extensions are: .img .zip .xz .gz \
        \n.zip is the baseline \n.img is ~2x faster but twice the size (NOT compressed) \n.xz is ~25% smaller but takes 3x-4x longer \n.gz is ~25% faster \
        \n\nRecommended to have NO SPACES in the name \
        \n\nEnter the image filename (eg: 2020-12-15-buster32)"
        NEWFILE=$(whiptail --backtitle "$BACKTITLE" --title "BACKUP '$(media_name $INDEV)'" --inputbox "$MSG" $WT_HEIGHT_TALL $WT_WIDTH_WIDE "$OUTFILEDEFAULT" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then 
            return $EXIT_CODE
        fi
    
    
        #fill out variables based on selected filename
        OUTFILEDEFAULT="$NEWFILE"
        OUTFILE="$NEWFILE"
        if [ ! -z $(file_ext "$OUTFILE") ]; then
            EXT=$(file_ext "$OUTFILE")
        else    
            EXT=$DEFAULT_EXTENSION
        fi
 
        check_outfile
        EXIT_CODE=$?
        if [ $EXIT_CODE = 0 ]; then
            break
        fi
    done
        
    # add .img.zip if no extension
    if [ ! -z "$OUTFILE" ] && [ -z "$(file_ext $OUTFILE)" ] ; then 
         echo "Adding '.img.$DEFAULT_EXTENSION'"
         OUTFILE=$OUTFILE.img.$DEFAULT_EXTENSION
         #echo "added ext '$OUTFILE'"
    fi
    
    # check and fix outfile name.....
    if [ $(file_ext "$OUTFILE") = "img" ] ; then
        OUTFILE=$(file_path_base "$OUTFILE").$(file_ext "$OUTFILE")
    else
        OUTFILE=$(file_path_base "$OUTFILE").img.$(file_ext "$OUTFILE")
    fi    
}


menu_backup(){
    INDEV=$1  #use global vars  
    OUTFILE=$2   #use global vars
    
    # get INDEV
    # Set global variables INDEV and OUTDEV
    menu_select_sddevice "BACKUP" 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then 
        return $EXIT_CODE
    fi   
    
    check_indev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    
    # get OUTFILE
    menu_get_outfile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    

    #confirm to continue
    whiptail  --backtitle "$BACKTITLE" --title "BACKUP : Create Image-file" --defaultno \
        --yesno "Backup '$(media_name $INDEV)' on '$INDEV' 
        \nto '$OUTFILE'.
        \n\nA good 8GB card with RaspiOS on a Pi4 takes about 10 minutes with zip
        \nand about 7 minutes with gz.
        \nThis will switch to the terminal screen to watch the progress ...
        \n\nCreate backup image-file now?"   $WT_HEIGHT $WT_WIDTH
    EXIT_CODE=$?       
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi


    ###########################################################
    # this next line actually does the work!!
    media_backup $INDEV "$OUTFILE" "off" "gui"
    EXIT_CODE=$?
    
    if [ $EXIT_CODE != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$DEBUG_MODE
        echo Exit_code=$EXIT_CODE
        read -n 1 -p "Press any key to continue..." 
        if [ $EXIT_CODE != 0 ] ; then   
            dialog_msg "ERROR" "There was an error $ERROR_CODE" "red"
            return $EXIT_CODE
        fi   
    fi 
    ###########################################################

    # Display results
    whiptail  --backtitle "$BACKTITLE" --title " BACKUP-DONE "  \
        --msgbox "'$(media_name $INDEV)' backed up to 
        \n'$OUTFILE' 
        \ncompressed from '$(media_size $INDEV -h)' to '$(file_size $OUTFILE -h)' in $(get_elapsed_time $TIME1 $TIME4) 
        \n\nYou can remove '$(media_name $INDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}  


menu_restore() {   
    echo "Getting list of images ready..."
    
    #GET INFILE
    if whiptail_fselect "WRITE : Select an Image-file" "$DEFAULT_PATH" "zip" "no" ; then
    INFILE=$FILE_SELECTED
    else
        return 1
    fi

    check_infile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi  


    
    # GET OUTDEV
    menu_select_sddevice "RESTORE"       # this sets global variable OUTDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi    

    check_outdev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi  
    
    

    # Confirm to continue
    if (whiptail  --backtitle "$BACKTITLE" --title "RESTORE WARNING" --defaultno \
        --yesno "Restore '$INFILE' 
        \nto '$(media_name $OUTDEV)' on '$OUTDEV' 
        \n\nALL existing data on '$(media_name $OUTDEV)' - WILL BE ERASED!  
        \nRestore now?" $WT_HEIGHT $WT_WIDTH) then
        #echo "User selected Yes, exit status was $?."
        RESULT="YES"
    else
        #echo "User selected No, exit status was $?."
        RESULT="n"
        return 1
    fi

    #Countdown 
    do_beep_if_sound
    dialog_countdown 10 "" "Overwriting '$(media_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title "RESTORE" --msgbox "Restore stopped... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
        return $EXIT_CODE
    fi    
              
   ###################################################       
    # do the restore
   ### # the third parameter turns "SAFETY" to "off".  this is because we already checked with the GUI.
   # the third parameter turns "SILENT" to "-y".  this is because we already checked with the GUI.
    
    media_restore "$INFILE" $OUTDEV -y gui
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$DEBUG_MODE
        echo Exit_code=$EXIT_CODE
        read -n 1 -p "Press any key to continue..." 
        if [ $EXIT_CODE != 0 ] ; then
            return $EXIT_CODE
        fi   
    fi 
   ###################################################
 
    #display the results
    whiptail  --backtitle "$BACKTITLE" --title " RESTORE-DONE " \
        --msgbox "'$INFILE' restored to 
        \n'$(media_name $OUTDEV)'
        \nin $(get_elapsed_time $TIME1 $TIME2)
        \n\nYou can remove '$(media_name $OUTDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}


menu_tools(){
    local SELECTION
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "TOOLS" --cancel-button "Back" --menu " Choose " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
        "INSTALL"           "Install $PRODUCTNAME into the menu" \
        "UPDATE"            "Check for updates" \
        "UNINSTALL"          "Uninstall $PRODUCTNAME" \
          "  "               "  " \
          "  "              "MEDIA TOOLS" \
        "ANALYZE"          "Media analysis" \
        "ERASE"             "Quick format media as FAT32" \
        "WIPE"              "Destructively wipe media with zeros " \
        "TEST"              "Destructively test media with zeros and ones (slow)" \
        "  "               "  " \
        "TERMINAL"          "View the terminal (for debugging)" \
        "LOG"               "View the log file" \
        3>&1 1>&2 2>&3)
        
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        else
            case "$SELECTION" in
            INSTALL)    pisafe_install  ;;
            UPDATE)     pisafe_update gui ;;
            UNINSTALL)  pisafe_uninstall ;;
            ANALYZE)    
                menu_select_sddevice "MEDIA ANALYSIS"
                if ! (( $? )); then
                  media_details $INDEV
                fi  
                ;;
            ERASE)      
                menu_select_sddevice "ERASE MEDIA"
                if ! (( $? )); then
                  media_format_fat32 $OUTDEV
                fi  
                ;;
                
            WIPE) 
                menu_select_sddevice "WIPE MEDIA"
                if ! (( $? )); then
                  media_wipe $OUTDEV
                fi  
                ;;
                
            TEST) 
                menu_select_sddevice "TEST MEDIA"
                if ! (( $? )); then
                  media_test $OUTDEV
                fi  
                ;;
        

            TERMINAL)   read -n 1 -p "Press any key to return"  ;;
            LOG)        $TEXT_EDITOR $LOG_FILE ;;
            
            HELP)
                HELP_INFO="$(pisafe_help)"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$HELP_INFO" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;
            ABOUT)
                ABOUT_INFO="$(pisafe_about)"
                whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$ABOUT_INFO" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;  
            "  ")  ;;     
            *)     whiptail --msgbox "Programmer error: unrecognized option" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT ;;
            esac 
        fi
    done
}


menu_splashscreen(){
    INTERFACE="gui"
    
    # install
    if [ -z $(which $SCRIPTNAME) ]; then
        pisafe_install
    fi    
    
    # load factory defaults
    if [ $(get_ver_to_int $SETTINGS_SCRIPT_VER) -lt $(get_ver_to_int $SCRIPTVER) ]; then
    
        whiptail --backtitle "$BACKTITLE" --title "WELCOME" --yes-button "Load Factory Defaults"\
        --yesno "Welcome to $PRODUCTNAME
        \nMany changes have been made to $PRODUCTNAME and to the settings file.
        \nIt is recommended that you load the factory defaults now.
        \nWhile best attempts have been made to make $PRODUCTNAME reliable... use at your own risk. " \
        $WT_MB_HEIGHT $WT_MB_WIDTH
    
        if [ $? = 0 ] ; then
            config_var_factory_reset 
        fi 
    fi
}


menu_gui(){
    INTERFACE="gui"
    while true
    do
        whiptail_calc_wt_size
        MENU_CHOICE=$(whiptail --clear --backtitle "$BACKTITLE" --title "MAIN MENU" --ok-button "Select" --cancel-button "Exit" --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "BACKUP"    "   Backup media (SD-cards) to an image-file" \
                "RESTORE"   "   Restore media (SD-cards) from an image-file" \
                "LIST"      "   List media and image files" \
                "  "        "   " \
                "SETTINGS"  "   Change settings" \
                "TOOLS"     "   Various tools"\
                 "  "        "   " \
                 "HELP"     "   Help"\
                 "ABOUT"    "   About $PRODUCTNAME"\
                3>&1 1>&2 2>&3)
 
                
        case $MENU_CHOICE in
            BACKUP)         menu_backup   ;;
            
            RESTORE)        menu_restore  ;;
            
            LIST)
                echo "Getting list of images ready..."
                LIST_INFO="$(do_list_info $DEFAULT_PATH)"
                whiptail --backtitle "$BACKTITLE"  --title "LIST" --scrolltext --msgbox "$LIST_INFO" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;
            
            SETTINGS)       menu_settings    ;;
            
            TOOLS)          menu_tools       ;;
            
            HELP)           dialog_msg "HELP" "$(pisafe_help)" ;;
            
            ABOUT)          dialog_msg "ABOUT" "$(pisafe_about)"  ;;      
            "  "*)          ;;
            * )             return          ;;
        esac
    done
}


menu_cli(){
INTERFACE="cli"
case $1 in
    
    backup|read)
        do_write_log $1 $2 $3
        media_backup $2 $3
        ;;
    
    restore|write)
        do_write_log $1 $2 $3 $4
        media_restore $2 $3 $4
        ;;
    
    list)
        do_list_info  ;;

    analyze)
        media_details $2  ;;


    erase|format)
        media_format_fat32 $2 $3   ;;
    
    wipe)
        media_wipe $2  ;;
        
    test)
        media_test $2 ;;
    
    install)
        pisafe_install $2 ;;
        
    update)
        pisafe_update cli yes $2
        ;;
    
    uninstall)
        pisafe_uninstall $2 ;;
    
    help|-h)
        pisafe_help  ;;
    
    -v)
        echo $SCRIPTVER  ;;
    
    gui)
        if [ $CHECK_FOR_UPDATES_ON_STARTUP = "on" ]; then 
            menu_splashscreen
        fi    
        menu_gui
        ;;
    
    "")
        menu_gui  ;;
    
    *)
      #  if [ ${SCRIPTNAME:0:6} = "pisafe" ]; then
      #      menu_splashscreen
      #      menu_gui
      #  else    
            pisafe_help
      #  fi    
        ;;
esac
}


# probably delete get_opts
get_opts(){
while getopts ":y" opt; do
  case "${opt}" in
    y) ANSWER_YES=on; echo ON;;
 #   p) parallel=off;;
 #   d) debug=on;;
   # h) pisafe_help; exit;;
 #   a) autoexpand=off ;;
 #   v) verbose=on;;
   # v)  echo $SCRIPTVER; exit;;
    *) pisafe_help; exit;;
  esac
done
shift $((OPTIND-1))
}



##########################################################

# if arg = -v, then show version and exit the script
if  [ ! -z "$1" ]  && [ $1 = "-v" ]; then
    echo $SCRIPTVER
    exit
fi

pisafe_install_tools

config_var_init_configfile
config_var_get_settings

whiptail_calc_wt_size


## check for updates if not uninstalling
if [ ! -z "$1" ] && [ ! $1 = "uninstall" ]; then
    # check for updates
    if  [ $CHECK_FOR_UPDATES_ON_STARTUP = "on" ]; then
        pisafe_update gui no
    fi
fi

menu_cli $1 $2 $3 $4
