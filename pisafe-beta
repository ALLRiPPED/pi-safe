#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021"

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room

SCRIPTNAME="${0##*/}"
SCRIPTVER="0.9.4"
PRODUCTNAME="PiSafe"
PRODUCTCOMMENT="Raspberry Pi Imaging App"
CURRENT_DIR=$(pwd)
USER=$(whoami)
CONFIG=/home/$USER/.config/pisafe/pisafe.conf
LOG_FILE=/home/$USER/PiSafe.log

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }

INDEV=
OUTDEV=
INFILE=
OUTFILE=
BACKTITLE="$PRODUCTNAME ver $SCRIPTVER. === $PRODUCTCOMMENT === "


get_opts(){
while getopts ":pdhv" opt; do
  case "${opt}" in
    p) parallel=off;;
    d) debug=on;;
    h) help;;
    a) autoexpand=off ;;
    v) verbose=on;;
    *) help;;
  esac
done
shift $((OPTIND-1))
}


set_conf_defaults(){
    set_config_var default_path $HOME/Downloads $CONFIG
    set_config_var default_extension zip $CONFIG
    set_config_var compression_level 5 $CONFIG
    set_config_var hide_root_disk on $CONFIG
    set_config_var debug_mode off $CONFIG
    set_config_var sound on $CONFIG
    set_config_var shrink_fs on $CONFIG
    set_config_var auto_expand_fs on $CONFIG
    if [ -z $(which mousepad) ]; then
        set_config_var text_editor nano $CONFIG
    else
        set_config_var text_editor mousepad $CONFIG
    fi
    set_config_var log on $CONFIG
    set_config_var safety on $CONFIG
    set_config_var large_device_read_warning 17179869184 $CONFIG
    set_config_var large_device_write_warning 17179869184 $CONFIG
}


fix_settings(){
    get_settings
    
    if [ $DEFAULT_PATH = 0 ]; then 
        set_config_var default_path $HOME/Downloads $CONFIG
    fi
    if [ $DEFAULT_EXTENSION = 0 ]; then 
        set_config_var default_extension zip $CONFIG
    fi
    if [ $COMPRESSION = 0 ]; then 
        set_config_var compression_level 5 $CONFIG
    fi
    if [ $HIDE_ROOT_DISK != "off" ] ; then 
        set_config_var hide_root_disk on $CONFIG
    fi
    if [ $DEBUG_MODE = 0 ]; then 
        set_config_var debug_mode on $CONFIG
    fi
    if [ $SOUND = 0 ]; then 
        set_config_var sound on $CONFIG
    fi
    if [ $SHRINK_FS = 0 ]; then 
        set_config_var shrink_fs on $CONFIG
    fi
    if [ $AUTO_EXPAND_FS = 0 ]; then 
        set_config_var auto_expand_fs on $CONFIG
    fi
    if [ $TEXT_EDITOR = 0 ]; then 
        set_config_var text_editor nano $CONFIG
    fi    
    if [ $SAFETY = 0 ]; then 
        set_config_var safety on $CONFIG
    fi    
    get_settings
}


get_settings(){
    DEFAULT_PATH=$(get_config_var default_path $CONFIG)
    DEFAULT_EXTENSION=$(get_config_var default_extension $CONFIG)
    COMPRESSION=$(get_config_var compression_level $CONFIG)
    HIDE_ROOT_DISK=$(get_config_var hide_root_disk $CONFIG)
    DEBUG_MODE=$(get_config_var debug_mode $CONFIG)
    SOUND=$(get_config_var sound $CONFIG)
    SHRINK_FS=$(get_config_var shrink_fs $CONFIG)
    AUTO_EXPAND_FS=$(get_config_var auto_expand_fs $CONFIG)
    TEXT_EDITOR=$(get_config_var text_editor $CONFIG)
    SAFETY=$(get_config_var safety $CONFIG)
    LOG=$(get_config_var log $CONFIG)
    
    VERIFY=off
    LARGE_DEVICE_READ_WARNING=$(get_config_var large_device_read_warning $CONFIG) 
    LARGE_DEVICE_WRITE_WARNING=$(get_config_var large_device_write_warning $CONFIG) 
    
    mkdir -p "$DEFAULT_PATH"
}


do_help() {
    echo "$PRODUCTNAME v$SCRIPTVER  - Designed for Raspberry Pi"
    echo " - Backup your SD card to an image file"
    echo " - Restore your SD card from an image file"
    echo
    echo "Usage: "
    echo "  $SCRIPTNAME [function] [device/file] [file/device]"
    echo
    echo "Function is:"
    echo "                            - startup the gui menu (this is recomended)"
    echo "  list                      - list SD-devices and image-files "
    echo "  backup [device] [file]    - backup SD-card to image-file"
    echo "  restore [file] [device]   - restore image-file to SD-card"
    echo "  install                   - install this script"
    echo "  update                    - update script from webiste"
    echo "  -v                        - display version"
    echo "  help | -h                 - help"
    echo
    echo "Notes: "
    echo " - Supports .img .zip .xz and .gz files.  Appends '.$DEFAULT_EXTENSION' if no extension is specified "
    echo " - Specifying an '.img' extension is faster, but twice the size because it is not compressed with $DEFAULT_EXTENSION."
    echo
    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Examples:"
    echo $SCRIPTNAME 
    echo $SCRIPTNAME list
    echo $SCRIPTNAME backup sda newimage
    echo $SCRIPTNAME backup /dev/sdb newimage.xz
    echo $SCRIPTNAME restore newimage.zip sda
    echo
}


do_about(){
    echo "$PRODUCTNAME was started in 2017 as 'sd' by 'RichardMidnight on github'"\
        "when he was working on a Raspberry Pi Homebridge project and needed"\
        "to make numerous restore-points.  The image writers available at the"\
        "time did not run on the pi itself and were not able to create a new image file." 
    echo
    echo "It was originally called 'sd' and only had a CLI."
    echo
    echo "Then in 2021, he added the graphical front-end to make it more usable by others"\
        "and renamed it 'PiSafe'.  PiSafe is a reference to the 'ventilated cupboards for storing"\
        "pies while protecting them from insects and vermin'. "
    echo
    echo "Use at your own risk."
    echo
    echo "I hope this is helpful to others."
    echo
}


do_init_conf(){
    if [ ! -d $(get_file_path $CONFIG) ]; then
        mkdir -p $(get_file_path $CONFIG)
    fi
    
    if [ ! -f $CONFIG ]; then
        #echo " " > $CONFIG
        touch $CONFIG
        echo "# $CONFIG" > $CONFIG
        set_conf_defaults
    fi
}


set_config_var() {
  lua - "$1" "$2" "$3" <<EOF > "$3.bak"
local key=assert(arg[1])
local value=assert(arg[2])
local fn=assert(arg[3])
local file=assert(io.open(fn))
local made_change=false
for line in file:lines() do
  if line:match("^#?%s*"..key.."=.*$") then
    line=key.."="..value
    made_change=true
  end
  print(line)
end

if not made_change then
  print(key.."="..value)
end
EOF
mv "$3.bak" "$3"
}


clear_config_var() {
  lua - "$1" "$2" <<EOF > "$2.bak"
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
for line in file:lines() do
  if line:match("^%s*"..key.."=.*$") then
    line="#"..line
  end
  print(line)
end
EOF
mv "$2.bak" "$2"
}


get_config_var() {
  lua - "$1" "$2" <<EOF
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
local found=false
for line in file:lines() do
  local val = line:match("^%s*"..key.."=(.*)$")
  if (val ~= nil) then
    print(val)
    found=true
    break
  end
end
if not found then
   print(0)
end
EOF
}


# -------------------------------------------------------------


do_write_log(){
    x=1
}


is_number() {
  case $1 in
    ''|*[!0-9]*) return 0 ;;
    *) return 1 ;;
  esac
}


do_countdown(){  
    local MAX=${1:-10}
 
    echo "Pausing for $MAX seconds... Ctrl-C to abort"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
		sleep 1
    done 
    echo ...
}


do_beep(){
    #speaker-test -t sine -f 1000 -l 1 & sleep .3 && kill -9 $!
    speaker-test -t sign -f 700 > /dev/null  & sleep .5 && kill -9 $! 
    sleep .5  # to allow the beep to end
}


do_beep_if_sound(){
    if [ $SOUND = on ] ; then
        do_beep
    fi
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


get_ver_to_int() {
	local IFS=.
	parts=($1)
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


get_file_path(){
    dirname "$*"
}


get_file_base() {
   # basename "$*"
    local fullfilename=$*
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo "$fname"
}


get_file_ext(){
	base=$(basename "$*")
	
	#look for a period in the basename.  if there is one, there is an extention
	HAS_DOT=$(echo "$base" | grep \\.)
	if [ ! -z "$HAS_DOT" ] ; then
		echo $base | sed 's#.*\.##g'
	else  
		echo ""
		return 1
	fi
}


get_file_size_kbytes() {
    local FILE=$*
    
    if [ -f "$FILE" ] ; then
        ls -s "$FILE" | cut -d' ' -f1
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_bytes_h(){
    BYTES=$1
    # currently shows 3 significant digits.
    
    [ -z "$BYTES" ] && return
    #need some error checking that it is a number
    
    k_ilo=1024;
    m_ega=$k_ilo*$k_ilo;
    g_iga=$m_ega*$k_ilo;
    t_era=$g_iga*$k_ilo;
    p_eta=$t_era*$k_ilo;
    
    LEN=${#BYTES}
    
    case $LEN in
        4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc) kb ;;
        5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc) kb ;;
        6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc) kb ;;
        
        7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc) mb ;;
        8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc) mb ;;
        9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc) mb ;;
        
        10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc) gb ;;
        11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc) gb ;;
        12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc) gb ;;
        
        13) echo $(echo "scale=2; $BYTES/($t_era)" | bc) tb ;;
        14) echo $(echo "scale=1; $BYTES/($t_era)" | bc) tb ;;
        15) echo $(echo "scale=0; $BYTES/($t_era)" | bc) tb ;;
        *)  echo $BYTES bytes;;
    esac
}

get_file_size() {
    local FILE=$*
    
    if [ -f "$FILE" ] ; then
        ls -s -h "$FILE" | cut -d' ' -f1
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}


get_sd_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE
    fi
}


get_sd_size() {
    # $1 is devicename
    # $2 is -h human readable
    if [ ! -z $2 ] && [ $2 = "-h" ]; then
        lsblk $1 -d -n -o size  2> /dev/null
        EXIT_CODE=$?
    else
        lsblk $1 -d -n -b -o size  2> /dev/null
        EXIT_CODE=$?
    fi
        
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE       
    fi
    
# an alternative way:
# echo $(( $(sudo blockdev --getsize64 /dev/sda) ))
# echo $(( $(sudo blockdev --getsize64 /dev/sda)/1024/1024 ))mb    
}


get_device_serial(){
    local DEVICE=$1
    # currently vendor + SN
    SN=$(lsblk -n -d --output vendor,model,serial "$DEVICE" | sed 's/ /_/g' )
    echo $SN
}



get_image_size() {
    local INFILE=$*
    
    case $(get_file_ext "$INFILE") in
        img)
            ls -s -h "$INFILE" | cut -d' ' -f1
        ;;
        
        zip)
            echo $(( $(zipinfo -t "$INFILE" | cut -d, -f2 | cut -d" " -f2) / 1024 / 1024 ))M
        ;;
        
        xz)
            xz -l "$INFILE" | grep -v Strms | sed 's/\s\s*/ /g' | cut -d' ' -f6,7
        ;;    
        
        gz)
            echo $(( $(pigz -l "$INFILE" | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g') /1024 / 1024 ))M
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
}


get_image_size_bytes() {
    local INFILE=$*
    
    case $(get_file_ext "$INFILE") in
        img)
            echo $((  $(ls -s "$INFILE" | cut -d' ' -f1 ) * 1024 )) 
        ;;
        
        zip)
            zipinfo -t "$INFILE" | cut -d, -f2 | cut -d" " -f2
        ;;
        
        xz)
            xz -l -v "$INFILE" | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1 | sed 's/,//g'
        ;;  
          
        gz)
            pigz -l "$INFILE" | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f2 | sed 's/?/0/g'
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
}    


get_root_disk() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    ROOT_PARTITION=$(lsblk -l | grep "/$" | cut -d' ' -f1 2> /dev/null) 
    
    if [ -z $ROOT_PARTITION ]; then
        return 1  # can't find root partition or root disk
    fi
    
    if [[ $ROOT_PARTITION =~ "p" ]]; then
        ROOT_DRIVE=$(echo $ROOT_PARTITION | cut -d'p' -f1)
    elif [[ $ROOT_PARTITION =~ "sd" ]]; then
        ROOT_DRIVE=${ROOT_PARTITION:0:3}
    else
        return 2  # can't find root disk
    fi    
    echo $ROOT_DRIVE
}


get_freespace() {
    # $1 is FILENAME
    # $2 is optionally -h for human readable
    # local LOCAL_PATH=${2:-$(pwd)}
    local FILENAME=${1:-"."}  
    local FORMAT=${2:-"-B1"}   # -B1 for bytes    -h for humanreadable
    local FREESPACE
    
    if [ -d "$FILENAME" ]; then
        FREESPACE=$(df "$FILENAME" $FORMAT --output=avail | grep -v Avail)
        EXIT_CODE=$?
    else
        FREESPACE=$(df $(dirname "$FILENAME") $FORMAT --output=avail | grep -v Avail)
        EXIT_CODE=$?
    fi
    
    #FREESPACE=$(df $(dirname "$FILENAME") $FORMAT --output=avail | grep -v Avail)
    #EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo $FREESPACE
}   


get_folder_size() {
    local FOLDER=$*
    
    if [ -d "$FOLDER" ] ; then
        sudo du -sh "$FOLDER" | cut -d'/' -f1 | sed 's/\s\s*/ /g'
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}

# ---------------------------------------------------------

get_file_ext_ok(){
    #check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
    OUTFILE_EXT=$(get_file_ext "$1")

    case $OUTFILE_EXT in
        img | zip | xz | gz |"" )
            echo true
            return 0
        ;;
        
        *)  
            echo ""
            return 1
        ;;
    esac
}


check_for_img_file(){
    # returns 0 if there is an imagefile
    # returns 1 if no imagefile

    local INFILE=$*
    local IMG
    
    echo -n "Inspecting '$INFILE' for an image file ... "
 
    case $(get_file_ext "$INFILE") in
        img)
            IMG=$INFILE
        ;;
        
        zip|gz)
            #IMG=$(zipinfo -1 "$INFILE")  
            #IMG=$(pigz -l "$INFILE" | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4-)
            IMG=$(pigz -l "$INFILE" | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4-)
        ;;
        
        xz)
            IMG=$(xz -l "$INFILE" | grep .xz | sed 's/\s\s*/ /g' | cut -d' ' -f10-)
            IMG=$(echo "$IMG" | sed 's/.xz/.img/g')
         ;;   
         
         #gz)
         #   IMG=$(pigz -l "$INFILE" | grep .img | sed 's/\s\s*/ /g'  | cut -d' ' -f4-)
         #;;
         
         *)
            IMG=
        ;;
    esac
    
    
    if [ ! -z $(get_file_ext "$IMG") ] && [ $(get_file_ext "$IMG") = "img" ]; then
        echo "$IMG" [OK]
        return 0
    else
        echo "ERROR: No image found in '$INFILE' '$(get_file_ext $IMG)' "
        return 1
    fi    
}

# -----------------------------------------------

do_list_info() {
        DIR=${1:-$PWD}
        echo "~~~ CURRENT SYSTEM ~~~"
        echo "Root disk = /dev/$(get_root_disk)"
        echo "Size      = $(get_sd_size /dev/$(get_root_disk) -h )"
        echo "FreeSpace = $(get_freespace . -h)"
        echo "TrashSize = $(get_folder_size /home/pi/.local/share/Trash)"
        echo "RootTrash = $(get_folder_size /root/.local/share/Trash)"
        echo
        echo "~~~ PiSafe LOCKED DEVICES ~~~"
        echo $(cat $CONFIG | grep "device")
        echo
        echo
        echo "~~~ SD-CARD DEVICES ~~~  (Hide root disk = $HIDE_ROOT_DISK)"
        echo "$(get_sd_devices)"
        echo   
        echo "~~~ IMAGE FILES in '$DIR' ~~~"
        SAVED_PWD=$PWD
        #echo $OLD_DIR
        #echo $DEFAULT_PATH
        cd $DIR
        ls -1 -s -h -w1 *.img *.zip *.xz *.gz 2> /dev/null | sed 's/ /     /'
        #ls -1 -s -h -w1 $DEFAULT_PATH/*.img $DEFAULT_PATH/*.zip $DEFAULT_PATH/*.xz $DEFAULT_PATH/*.gz 2> /dev/null | sed 's/ /     /'
        cd $SAVED_PWD
}    


msgbox(){
   whiptail --msgbox "$*" $WT_MB_HEIGHT $WT_MB_WIDTH
}


get_sd_devices() {
    local DEVICES= 
    if [ $(get_config_var hide_root_disk $CONFIG) = "off" ]; then
        ROOT_DISK=$(get_root_disk)      
        if [ ${ROOT_DISK:0:2} != "sd" ]; then
            ROOT_DISK="/dev/$(get_root_disk)"
        else
            ROOT_DISK=
        fi
        #lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? /dev/$(get_root_disk)
        # DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? /dev/$(get_root_disk) 2> /dev/null  )   
        DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? $ROOT_DISK 2> /dev/null  )  
        EXIT_CODE=$?
    else
        DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd?  2> /dev/null | grep -v $(get_root_disk))   
        EXIT_CODE=$?
    fi
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "${DEVICES[@]}"
  }

# --------------------------------------

get_tools() {   
    #echo -n Checking to see if required tools are installed ...
    
    if [ ! -f /usr/local/bin/pishrink.sh ] || [ ! -f /usr/bin/pv ] || [ ! -f /usr/bin/xz ] || [ ! -f /usr/bin/zip ] || [ ! -f /usr/bin/pigz ]  || [ ! -f /usr/bin/whiptail ] ; then
       
        read  -p "Install needed tools:  Zip, PiShrink, pv, xz, and gzip?" -n 1 -r RESULT
        echo

        if [ $RESULT = "y" ]; then
        
            # Install PiShrink if needed
            if [ ! -f /usr/local/bin/pishrink.sh ]; then
                echo_white Installing pishrink...
                wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
                chmod +x pishrink.sh
                sudo mv pishrink.sh /usr/local/bin
                echo pishrink installed.
            fi

             #get zip if needed
            if [ ! -f /usr/bin/zip ]; then
                echo_white Installing zip...
                sudo apt install zip -y
            fi
            
            # get xz if needed
            if [ ! -f /usr/bin/xz ]; then
                echo_white Installing xz-utils...
                sudo apt install xz-utils -y
            fi
            
            # get gzip if needed
            if [ ! -f /usr/bin/pigz ]; then
                echo_white Installing pigz...
                sudo apt install pigz -y
            fi
            
            # get pv if needed
            if [ ! -f /usr/bin/pv ]; then
                echo_white Installing pv...
                sudo apt install pv -y
            fi
            
            echo_white DONE installing tools. 
            
        else
            echo
            echo_red   WARNING.  Not all the needed tools are installed.
        fi
    fi
}    


do_install() {   
    echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    read  -p "Install $SCRIPTVER to /usr/local/bin [y,N]?" -n 1 -r RESULT
    echo
    
    if [ $RESULT = "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    else
        MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
        echo_or_msgbox "ERROR" "$MSG"
    fi
}


do_update() {
    INTERFACE=$1
    
    echo "This ver '$SCRIPTVER'"
    
    # this should not be needed.  the parameter should be passed.
    if [ -z $INTERFACE ]; then
        INTERFACE="gui"
    fi
      
    local SERVER_VER=
    rm $SCRIPTNAME.tmp
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/$SCRIPTNAME -O $SCRIPTNAME.tmp 2> /dev/null 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ];  then
        echo "ERROR: Can't connect to server..."
        return $EXIT_CODE
    fi    

    if [ -f $SCRIPTNAME.tmp ]; then
        SERVER_VER=$(bash $SCRIPTNAME.tmp -v)
    else
        return 1
    fi

    if [ $(get_ver_to_int $SERVER_VER) -gt $(get_ver_to_int $SCRIPTVER) ]; then
        read -p "Ver $SCRIPTVER.  Newer Version '$SERVER_VER' available.  Update [y,N]?"  -n 1 -r RESULT
        echo
        if [ $RESULT = "y" ]; then 
            sudo mv $SCRIPTNAME.tmp /usr/local/bin/$SCRIPTNAME
            sudo chmod +x /usr/local/bin/$SCRIPTNAME
            echo "$($SCRIPTNAME -v) installed. Press any key to exit... "
            read -n 1
            exit 0
        fi
    else    
        echo "Server version is '$SERVER_VER' You are up to date.  "
        if [ $INTERFACE = "gui" ]; then
            read -p "Press any key to continue..." -n 1 -r RESULT
        fi
    fi
}


do_backup(){
    local INDEV=$1
    local OUTFILE=$2
  #  local OUTFILE_BASE=$(get_file_base $OUTFILE)
   # local OUTFILE_EXT=$(get_file_ext $OUTFILE)
    
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Backup...
    echo "IN-DEV='$INDEV'"
    echo "OUT-FILE='$OUTFILE'"
    echo  "Compression set to level $COMPRESSION of 9"
        
    
    # check INDEV
    if [ -z $INDEV ] ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV' can't be blank"
        return 1
    fi 
    
    # add '/dev/' if missing
    if [ "${INDEV:0:5}" != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        INDEV="/dev/"$INDEV
        echo "IN-DEV='$INDEV'"
    fi
    
    # confirm INDEV exists
    if  [ ! -e $INDEV ]  ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV' not found"
        return 1
    fi 
    
    # warning if INDEV is root disk
    if [ $INDEV = /dev/$(get_root_disk) ]; then
        echo
        echo_red "WARNING: SD-card is root disk '/dev/$(get_root_disk)'."
        #return 1
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(get_sd_size $INDEV) -gt 16000000000 ]; then
        MESG=" '$INDEV' is larger than 16GB.  \
         \nUse a smaller SD card if you can, it will copy faster.\
         \nA good 8gb card in a Raspberry Pi 4 takes about 10 minutes \n"
         echo
        echo_red "WARNING... $MESG"   
    fi
    
    
    
    # Stop if SD-card is bigger than freespace on OUTFILE
    if [ $(get_sd_size $INDEV) -gt $(get_freespace "$OUTFILE") ]; then
        echo
        echo_red   "ERROR: Not enough free space on '$(get_file_path $OUTFILE)'"
        return 1
    fi
    
    # Warning if SD-card * 1.5 is bigger than freespace
        SPACENEEDED=$(( $(get_sd_size $INDEV) + $(( $(get_sd_size $INDEV) / 2 )) ))
        if [ $SPACENEEDED -gt $(get_freespace "$OUTFILE") ]; then
        echo
        echo_red   "WARNING: Might not be enough free space on '$(get_file_path $OUTFILE)'"
    fi
    
    
    # check OUTFILE
    if [ -z "$OUTFILE" ] ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE' can't be blank"
        return 2
    fi  
    
   # if [ -z $OUTFILE_EXT ]; then
   if [ -z $(get_file_ext "$OUTFILE") ]; then
        #echo "No extension specified.  Adding '.zip'"
        #OUTFILE=$OUTFILE.zip
        echo "No extension specified.  Adding '$DEFAULT_EXTENSION'"
        OUTFILE=$OUTFILE.$DEFAULT_EXTENSION
        
        #OUTFILE_EXT=$(get_file_ext $OUTFILE)
        echo "OUT-FILE='$OUTFILE'" 
    fi

  #  check_for_supported_file_extention
  if [ -z $(get_file_ext_ok "$OUTFILE") ]; then
        echo
        echo_red "ERROR: Unsupported file extension '$(get_file_ext $OUTFILE)'"
        return $EXIT_CODE 
    fi

    if  [ -f "$OUTFILE" ]  ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE' exists"
        return 2
    fi 

    if  [ -f "$(get_file_base $OUTFILE)".img ]  ; then
        echo
        echo_red "ERROR: OUT-FILE '$(get_file_base $OUTFILE).img' exists"
        return 2
    fi 

    
    
    # Final check before writing data
    if [ -z $INDEV ] || [ ! -e $INDEV ] ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV'.  Can't be blank.  Must exist."
        return 1
    fi 
    
    if [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE'. Cant be blank. Can't exist. "
        return 2
    fi  

    #do_beep_if_sound
    #echo_red "WARNING starting in 10 seconds ... Ctrl-C to abort"
    #do_countdown 10

    #################################################
    # this section writes the data
    #################################################
    OUTFILE_BASE=$(get_file_path "$OUTFILE")/$(get_file_base "$OUTFILE")

    TIME1=$(date +%s)
    echo_white "Step 1 of 3 - Reading  '$INDEV' to '$OUTFILE_BASE.img' ... "
    date
    echo $(get_sd_size $INDEV -h) to read
    sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img status=progress conv=fsync 
    #sudo pv -s 7000000000 "$INFILE" | sudo dd bs=4M of="$OUTFILE_BASE".img conv=fsync 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    sleep 5s
    echo Done reading SD card
    echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
    TIME2=$(date +%s)  
    echo_white Step 1 took $(get_elapsed_time $TIME1 $TIME2)
    echo
   
    echo_white Step 2 of 3 - Shrinking filesystem with PiShrink ...
    PI_SHRINK_OPTS=
    if [ $AUTO_EXPAND_FS = "off" ] ; then 
        PI_SHRINK_OPTS="-s"
    fi
    if [ $SHRINK_FS != "off" ]; then
        sudo pishrink.sh $PI_SHRINK_OPTS "$OUTFILE_BASE".img
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            echo Continuing without shrinking file system
            #return $EXIT_CODE
        fi
    else
        echo "Filesystem not shrunk.  Setting is 'off'."
    fi
    echo Done shrinking filesystem
    echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
    TIME3=$(date +%s)
    echo_white Step 2 took $(get_elapsed_time $TIME2 $TIME3)
    
    echo
    echo_white "Step 3 of 3 - Compressing '$OUTFILE_BASE.img' to '$OUTFILE' ... "
    echo Compression set to level $COMPRESSION of 9
    date
    
   
    case $(get_file_ext "$OUTFILE") in
        img)
            echo not compressing .img file ...
        ;;
        
        zip)
            local FILESIZE_M=$(( $(get_file_size_kbytes "$OUTFILE_BASE".img) / 1024))
            local DOTSIZE=$(( $FILESIZE_M / 50 ))
            echo Each dot represents=$DOTSIZE MB
            echo -n "                      $(get_file_path $OUTFILE)/$(get_file_base $OUTFILE).img"
            echo ".........20........40........60........80........100%"
            sudo zip -dbds $DOTSIZE -m -$COMPRESSION "$OUTFILE" "$OUTFILE_BASE".img
            EXIT_CODE=$?

            ##sudo pv "$OUTFILE_BASE".img | sudo pigz -$COMPRESSION -K > "$OUTFILE"
            ##EXIT_CODE=$? 
            ##sleep 1
            ##if [ -f "$OUTFILE" ] ; then
             ##   sudo rm -f "$OUTFILE_BASE".img 
            ##fi
            
        ;;
        
        xz)
            sudo xz -z -v -T0 -$COMPRESSION "$OUTFILE_BASE".img
            EXIT_CODE=$?     
            sudo mv "$OUTFILE_BASE".img.xz "$OUTFILE"  
        ;;
        
        gz)
            echo Sorry, no progress bar.  Please wait...
            sudo pigz -v -$COMPRESSION "$OUTFILE_BASE".img
            EXIT_CODE=$?        
            sudo mv "$OUTFILE_BASE".img.gz "$OUTFILE"
            
            ##sudo pv "$OUTFILE_BASE".img | sudo pigz -$COMPRESSION > "$OUTFILE"
            ##EXIT_CODE=$? 
            ##sudo rm -f "$OUTFILE_BASE".img 
        ;;
        
        *)
            echo
            echo_red ERROR... unsupported file extension \'$(get_file_ext "$OUTFILE")\'.
            return 1
        ;;
    esac
    
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "Done compressing '$OUTFILE_BASE.img' to '$OUTFILE' "
    echo_white $(ls -s -h "$OUTFILE")
    TIME4=$(date +%s)
    echo_white  Step 3 took $(get_elapsed_time $TIME3 $TIME4)
    
    
    # check if "$OUTFILE" was created
    if [ ! -f "$OUTFILE" ]; then
        echo
        echo_red "ERROR: creating '$OUTFILE'"
        return 1
    fi    
    
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        return $EXIT_CODE
    else
        do_beep_if_sound
        echo_white "Backup done. '$INDEV' backed up to '$OUTFILE' in $(get_elapsed_time $TIME1 $TIME4)." 
    fi
}


do_restore(){
    local INFILE=$1
    local OUTDEV=$2
    local SAFETY=${3:-on}   # this lets us bypass some of the safety prompts
    local INTERFACE${4:-CLI}  #CLI or GUI
    #   local LOCAL_PATH=${2:-$(pwd)}
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Restore...
    echo "IN-FILE='$INFILE'"
    echo "OUT-DEV='$OUTDEV'"
    echo "Safety='$SAFETY'"
    
    
    #check INFILE
    if [ -z "$INFILE" ] ; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank"
        return 1
    fi 
    
    if  [ ! -f "$INFILE" ]  ; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' not found "
        return 1
    fi 
    
    check_for_img_file "$INFILE"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
      #  return $EXIT_CODE
      x=1
    fi
    
    
    
    # Stop if OUTDEV is blank
    if [ -z $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank"
        return 1
    fi
    
    # Add '/dev/' if missing
    if [ ${OUTDEV:0:5} != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        OUTDEV="/dev/"$OUTDEV
        echo "OUT-DEV='$OUTDEV'"
    fi
    
    # Stop if OUTDEV is not found
    if  [ ! -e $OUTDEV ]  ; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' not found"
        return 2
    fi 
    
    # Stop if restore to root disk.
    if [ $OUTDEV = /dev/$(get_root_disk) ]; then
        echo_red "ERROR: Restore to root disk '/dev/$(get_root_disk)' not allowed"
        return 1
    fi
    
    
    # Warning if device is big
    if [ ! $SAFETY_OFF = "true" ]; then
        if [ $(get_sd_size $OUTDEV) -gt 16000000000 ]; then
            echo
            echo_red "WARNING... SD-card '$(get_sd_name $OUTDEV)' is larger than 16GB... 
            \nAre you sure it is the right device?"
            read -p "You must type 'BIG' to continue:"  -r RESULT
            if [ -z $RESULT ] || [ $RESULT != "BIG" ]; then
                echo Press any key to exit...
                return 1
            fi
        fi
    fi
    
    
    # Stop if image is bigger than device
    echo -n "Checking that Image file will fit on '$OUTDEV' ..."
    if [ $(get_image_size_bytes "$INFILE") -gt $(get_sd_size "$OUTDEV") ]; then
        echo
        echo_red ERROR... Image file is larger than SD-card.
        echo "Image size =$(get_image_size $INFILE)"
        echo "Device size=$(get_sd_size $OUTDEV -h)"
        return 1
    else
        echo [OK]
    fi
    
    #stop if drive is pisafe_locked
  #  $(get_config_var safety $CONFIG)
  VENDOR=$(lsblk -n -d --output vendor /dev/sda)
  SERIAL=$(lsblk -n -d --output serial /dev/sda)
  echo Device Vendor and Serial_number=$VENDOR $SERIAL
  #if [ $(get_config_var device_$VENDOR$SERIAL $CONFIG) = "locked" ]; then
  #  do_beep_if_sound
  #  echo Drive $OUTDEV serial number $VENDOR$SERIAL is $PRODUCTNAME locked.  exiting.
  #  return 1
  #fi
    


    # Final check before writing data
    if [ -z "$INFILE" ] || [ ! -e "$INFILE" ]; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank. must exist."
        return 1
    fi 
    
    if [ -z $OUTDEV ] || [ ! -e $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank.  must exist."
        return 1
    fi
    
    
    
    if [ $SAFETY != "off" ]; then
        echo
        echo "Write '$INFILE' to '$OUTDEV' '$(get_sd_name $OUTDEV)' ?"
        echo_red WARNING... All existing data on \'$OUTDEV\' - will be erased!
        do_beep_if_sound
        read  -p "You must type 'YES' to continue:" -r RESULT
        echo
    
        if [ -z $RESULT ] || [ $RESULT != "YES" ]; then
            echo "You did not answer 'YES'"
            return 1
        fi
        
        do_beep_if_sound
        echo_red "WARNING '$OUTDEV' '$(get_sd_name $OUTDEV)' "
        echo_red "Will be overwritten starting in 10 seconds ... Ctrl-C to abort"
        do_countdown 10
    fi
    
    #################################################
    # this section writes the data
    #################################################
    
    echo Unmounting SD-card $OUTDEV ...
    umount $OUTDEV?  2> /dev/null
    
    local INFILEEXT=$(get_file_ext "$INFILE")
    
    echo_white "Erasing MBR, signature, and partition table from '$OUTDEV'..."
	sudo dd if=/dev/zero of=$OUTDEV bs=512 count=1
    
    echo        
    echo_white "Writing '$INFILE' to '$OUTDEV' ... "    
    date
    TIME1=$(date +%s)
    echo $(get_image_size "$INFILE") to write
    
    case $INFILEEXT in
        img)
            sudo dd if="$INFILE" of=$OUTDEV bs=4M conv=fsync status=progress
            (sudo pv -n "$INFILE" | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --gauge "Writing '$(get_file_base "$INFILE")' to '$(get_sd_name $OUTDEV)' ..." 10 70 0
            EXIT_CODE=$?
        ;;
        
        zip)
            RESTORE_BYTES=$(get_image_size_bytes "$INFILE")
            echo $RESTORE_BYTES
            #unzip -p "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            #sudo unzip -p "$INFILE" | pv -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M conv=fsync 
            (unzip -p "$INFILE" | pv -n -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --gauge "Writing '$(get_file_base "$INFILE")' \nto '$(get_sd_name $OUTDEV)' ..." 10 70 0
            
            #if [ $INTERFACE = "GUI" ] && [ $DEBUG_MODE != "on" ]; then
            #    (sudo pv -n "$INFILE" | sudo pigz -d -k -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "Writing..." --gauge "Writing '$INFILE' \n\nto '$(get_sd_name $OUTDEV)' ..." 10 70 0
            #    EXIT_CODE=$?
            #else
            #    sudo pv "$INFILE" | pigz -k -d -c | sudo dd of=$OUTDEV bs=4M conv=fsync 
            #    EXIT_CODE=$?
            #fi
        ;;
        
        xz)
            #xz -v -d -c "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            (sudo pv -n "$INFILE" | xz -d -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --gauge "Writing '$(get_file_base "$INFILE")' to '$(get_sd_name $OUTDEV)' ..." 10 70 0
            EXIT_CODE=$?
        ;;

        gz)
            #pigz -v -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            ##pigz -v -k -c -d "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            #sudo pv "$OUTFILE_BASE".img | sudo pigz -$COMPRESSION > "$OUTFILE"
            #sudo pv "$INFILE" | pigz -k -d -c | sudo dd of=$OUTDEV bs=4M conv=fsync 
            (sudo pv -n "$INFILE" | sudo pigz -d -k -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --gauge "Writing to $OUTDEV, please wait..." 10 70 0
            EXIT_CODE=$?
            EXIT_CODE=$?
        ;;

        *)
            echo
            echo_red ERROR.  Unsupported file extension. 
            return  1 
        ;;

    esac        
    TIME2=$(date +%s)
    echo
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        return $EXIT_CODE
    else
        do_beep_if_sound
        echo_white "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
    fi
}


cli_menu(){
case $1 in
    
    backup|read)
        do_backup $2 $3
    ;;
    
    restore|write)
        do_restore $2 $3
    ;;
    
    list)
        do_list_info
    ;;
    
    install)
        do_install
    ;;
        
    update)
        do_update
    ;;
    
    help|-h)
        do_help
    ;;
    
    -v)
        echo $SCRIPTVER
    ;;
    
    gui)
        gui_menu
    ;;
    
    *)
        if [ ${SCRIPTNAME:0:6} = "pisafe" ]; then
            gui_menu
        else    
            do_help
        fi    
    ;;
esac
}




########################################
###  WHIPTAIL GUI SECTION ##############
########################################


whiptail_calc_wt_size() {
  # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
  # output from tput. However in this case, tput detects neither stdout or 
  # stderr is a tty and so only gives default 80, 24 values

  WT_HEIGHT=20
  WT_HEIGHT_TALL=$(($(tput lines)-7))
  WT_WIDTH=$(tput cols)

  if [ -z "$WT_WIDTH" ] || [ "$WT_WIDTH" -lt 60 ]; then
    WT_WIDTH=80
  fi
  if [ "$WT_WIDTH" -gt 178 ]; then
    WT_WIDTH=80
  fi
  
  WT_WIDTH=80
  WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
  
  WT_MB_HEIGHT=18
  WT_MB_WIDTH=70
  
  # use for pasting
  # $WT_HEIGHT  $WT_WIDTH
  # $WT_MB_HEIGHT  $WT_MB_WIDTH
}


whiptail_countdown(){  
    local MAX=${1:-10}
    local TITLE=${2:-"COUNTDOWN... press any key to abort"}
    MSG=$3
    # return code 2 if aborted. 

    #sleep 1
    for ((i=$MAX; i>=1; i--)) ; do
		TERM=vt220 whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --infobox  \
        "$MSG 
        \nin $i seconds" 10 100
		#sleep .75
        read -t 1 -N 1 INPUT
        if [ ! -z $INPUT ]; then
            return 2
        fi 
    done 
}


gui_update(){
    do_update "gui"
}


gui_do_install(){
    do_install
    
    # create the desktop file    

        echo "\
[Desktop Entry]
Type=Application
Terminal=true
Version=1.0
Name=$PRODUCTNAME
Comment=$PRODUCTCOMMENT
#Icon=rpi-imager
Icon=media-removable
Exec=lxterminal --geometry=110x40 -e $SCRIPTNAME
Categories=Utility
StartupNotify=false" > "$PRODUCTNAME.desktop"   

        sudo mv "$PRODUCTNAME.desktop" "/usr/share/applications"

        if [ -f "/usr/local/bin/$SCRIPTNAME" ]; then 
            MSG="$PRODUCTNAME $SCRIPTVER installed.            
            \nSelect it from the 'accessories' menu.
            \n\nOr you can execute it from any directory by typing '$SCRIPTNAME'."
            whiptail --backtitle "$BACKTITLE" --title "INSTALLED" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        else
            MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
            whiptail --backtitle "$BACKTITLE" --title "ERROR" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        fi
}


gui_set_compression(){
    CHOICE=$(whiptail --title "SETTINGS" --radiolist \
            "Choose compression level (your milage may vary)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "1" "Fastest time (slightly faster)" off \
            "2" "" off \
            "3" "" off \
            "4" "" off \
            "5" "(default)" on \
            "6" "" off \
            "7" "" off \
            "8" "" off \
            "9" "Smallest file (MUCH slower)" off   3>&1 1>&2 2>&3 )
           
            #echo $CHOICE
            if [ ! -z $CHOICE ]; then
                COMPRESSION=$CHOICE
                set_config_var compression_level $CHOICE $CONFIG
            fi
}


do_factory_reset(){
   # echo " " > $CONFIG

    set_conf_defaults
    get_settings
}
    
    
gui_set_default_path(){
    MSG="Enter new default path   '$DEFAULT_PATH'"
    TEMP_PATH="$DEFAULT_PATH"
    while true; do
        NEWPATH=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$TEMP_PATH" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then 
            return $EXIT_CODE
        fi
        
        if [ ! -z $NEWPATH ]; then
        
            if [ -d $NEWPATH ]; then
                #DEFAULT_PATH=$NEWPATH
                DEFAULT_PATH=$(echo "$NEWPATH" | sed 's/[/\t]*$//')
                set_config_var default_path $DEFAULT_PATH $CONFIG
                return 0
            else
                whiptail --title ERROR --msgbox "ERROR Directory '$NEWPATH' does not exist" $WT_MB_HEIGHT $WT_MB_WIDTH
                TEMP_PATH="$NEWPATH"
            fi
        
        fi
    done
}


gui_set_default_extention(){
     CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --radiolist \
            "Choose default extension (your milage may vary)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "zip" "Default" on \
            "xz" "~25% smaller, 3x-4x more time" off \
            "gz" "Same as zip" off  \
            "img" "Twice the size, half the time (No compression)" off 3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        DEFAULT_EXTENSION=$CHOICE
        set_config_var default_extension $CHOICE $CONFIG  
    fi
}


gui_set_hide_root_disk(){
    CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --radiolist \
            "Hide Root Disk" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "on" "Hide the root disk (default)" on \
            "off" "Don't hide the root disk " off   3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        HIDE_ROOT_DISK=$CHOICE
        set_config_var hide_root_disk $CHOICE $CONFIG
    fi
}


gui_set_shrink_fs(){
    CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --radiolist \
            "Shrink File System" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "on" "Shrink the file system on backup (default)" on \
            "off" "Don's shrink the filesystem on backup" off   3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        SHRINK_FS=$CHOICE
        set_config_var shrink_fs $CHOICE $CONFIG
    fi
}


gui_set_debug_mode(){
    CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --radiolist \
            "Debug Mode" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "on" "Show critical terminal screens" off \
            "off" "Hide most terminal screens (default)" on   3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        DEBUG_MODE=$CHOICE
        set_config_var debug_mode $CHOICE $CONFIG
    fi
}


gui_set_sound(){
    CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --radiolist \
            "Sound" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "on" "Sound on (default)" on \
            "off" "Sound off" off   3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        SOUND=$CHOICE
        set_config_var sound $CHOICE $CONFIG
    fi
}


gui_set_auto_expand_fs(){
    CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --radiolist \
            "Auto-unshrink filesystem" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "on" "Create a BACKUP that auto-unshrinks on first boot (default)" on \
            "off" "Create a Backup that will NOT auto-unshrink"  off   3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        AUTO_EXPAND_FS=$CHOICE
        set_config_var auto_expand_fs $CHOICE $CONFIG
    fi
}


gui_settings(){
    while true; do
        
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --menu " " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT  \
        "Default directory   " "$DEFAULT_PATH" \
        "Shrink filesystem  " "$SHRINK_FS" \
        "Auto unshrink filesystem" "$AUTO_EXPAND_FS" \
        "Default extension   " "$DEFAULT_EXTENSION" \
        "Compression         " "$COMPRESSION of 9" \
        "Hide root disk   "    "$HIDE_ROOT_DISK" \
        "Sound               " "$SOUND" \
        "Debug mode          " "$DEBUG_MODE" \
        "Text editor"        "$TEXT_EDITOR" \
        "                    " "      " \
        "Edit config         " "Edit the settings file manually (pisafe.conf)" \
        "Factory defaults    " "Reset settings to factory defaults" \
        3>&1 1>&2 2>&3)
        
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        else
            case "$SELECTION" in
            "Default d"*)   gui_set_default_path ;;
            "Shrink"*)      gui_set_shrink_fs ;;
            "Auto "*)       gui_set_auto_expand_fs ;;
            "Default e"*)   gui_set_default_extention ;;
            "Compression"*) gui_set_compression ;;
            Hide*)          gui_set_hide_root_disk ;;
            Sound*)         gui_set_sound ;;
            Debug*)         gui_set_debug_mode ;;
            View*)          read -n 1 -p "Press any key to return"   ;;
            Update*)        gui_update  ;;
            Text*)          ;;
            "    "*)        ;;
            Edit*)          $TEXT_EDITOR $CONFIG; get_settings ;;
            Factory*) 
                whiptail --title WARNING --defaultno --yesno "Are you sure you want to reset the settings to factory defaults?" $WT_MB_HEIGHT $WT_MB_WIDTH 
                if [ $? = 0 ] ; then
                    do_factory_reset 
                fi ;;
            
             *)             whiptail --msgbox "Programmer error: unrecognized option" 20 60 1 ;;
#         esac || whiptail --msgbox "There was an error running option $SELECTION" 20 60 1
            esac
        fi
    done
}



function whiptail_fselect()
# maybe call something like dialog's fselect
#
#  Arguments
#     1  Dialog title
#     2  Source path to list files and directories
#     3  File mask (by default *)
#     4  "yes" to allow go back in the file system.
#
#  Returns
#     0  if a file was selected and loads the FILE_SELECTED variable 
#        with the selected file.
#     1  if the user cancels.
#
#if whiptail_fselect "Please, select a file" /home/user ; then
#        echo "File Selected: \"$FILE_SELECTED\"."
#else
#        echo "Cancelled!"
#fi
# ----------------------------------------------------------------------
{
    # note: does not handle spaces in file names!!!
    local TITLE=${1:-$MSG_INFO_TITLE}
    local LOCAL_PATH=${2:-$(pwd)}
    local FILE_MASK=${3:-"*"}
    #local FILE_MASK='( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" )'
    local ALLOW_BACK=${4:-no}
    local FILES=()

    [ "$ALLOW_BACK" != "no" ] && FILES+=(".." "..")

    IFS=$'\t\n'

    # First add folders      
    for DIR in $(find $LOCAL_PATH -maxdepth 1 -mindepth 1 -name "[!.]*" -type d -printf "%f\t" | sort 2> /dev/null)
    do
        FILES+=($DIR  "     folder")
    done


    # Then add the files
    for FILE in $(find $LOCAL_PATH -maxdepth 1 \
                                    \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" \) \
                                    -name "[!.]*" \
                                    -type f \
                                    -printf "%f\t     %k\n" | sort  2> /dev/null)                                
    do
           FILES+=($FILE)
    done
	unset IFS


    # convert filesizes from kb to mb
    num='^[0-9]+$'
    arraylength=${#FILES[@]}
    
    if [ $arraylength = 0 ]; then
        FILES=(no files)
    fi
    
    for (( i=0; i<${arraylength}; i++ )); do
		arrayelement=$(echo "${FILES[$i]}" | sed 's/ *//g')
		if [[ "$arrayelement" =~ $num ]] ; then  
            FILES[$i]=$(echo "    " $(( $arrayelement / 1024 ))mb)			  
		fi
    done
 
 

    # let user select file
    while true
    do
        FILE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$LOCAL_PATH" \
                                --menu "Choose a file" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT "${FILES[@]}"  3>&1 1>&2 2>&3)

        #exit if bad whiptail statement
        FSX=${FILE_SELECTED:0:3}
        if [ ! -z $FSX ] && [ $FSX = "Box" ]; then
            echo "ERROR in whiptail in gui_select_dr_file.  Maybe a space in a filename?"
			echo "${FILES[@]}"
            exit 1
        fi
        
        if [ -z "$FILE_SELECTED" ]; then
            return 1
        else
            if [ "$FILE_SELECTED" = ".." ] && [ "$ALLOW_BACK" != "no" ]; then
                return 0

            elif [ -d "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                if gui_select_dr_file "$TITLE" "$LOCAL_PATH/$FILE_SELECTED" "$FILE_MASK" "yes" ; then
                    if [ "$FILE_SELECTED" != ".." ]; then
                        return 0
                    fi
                else
                    return 1
                fi

            elif [ -f "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                FILE_SELECTED="$LOCAL_PATH/$FILE_SELECTED"
                return 0
            fi
        fi
    done
}


gui_get_indev(){
    # for backup
    
    # Set global variables INDEV and OUTDEV
    gui_select_sddevice "BACKUP" 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then 
        return $EXIT_CODE
    fi    
    
    # Warning if INDEV is root disk
    if [ $INDEV = /dev/$(get_root_disk) ]; then
        whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "SD-card is your root disk." $WT_MB_HEIGHT $WT_MB_WIDTH  
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(get_sd_size $INDEV) -gt 16000000000 ]; then
        MESG=" '$(get_sd_name $INDEV)' is larger than 16GB.  \
         \n\nUse a smaller SD card if you can.  \
         \nIt will be faster because the entire SD card must be read before it can be compressed.\
         \n\nA good 8gb card in a Raspberry Pi 4 takes about 10 minutes"
        whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "$MESG" $WT_MB_HEIGHT $WT_MB_WIDTH   
    fi
    
    # Warning if SD-card is bigger than freespace
    if [ $(get_sd_size $INDEV) -gt $(get_freespace "$DEFAULT_PATH") ]; then
        whiptail --backtitle "$BACKTITLE" --title "ERROR" \
        --msgbox "Not enough free space on '$DEFAULT_PATH' 
         \n\n'$(get_sd_name  $INDEV)' is $(get_sd_size $INDEV -h)
         \nfreespace on '$DEFAULT_PATH' is $(get_freespace "$DEFAULT_PATH" -h)
         \n\nBe sure to specify a different drive" $WT_MB_HEIGHT $WT_MB_WIDTH 
        #return 1
    fi
    
    # Warning if one and a half times the SD-card is bigger than freespace
    SPACENEEDED=$(( $(get_sd_size $INDEV) + $(( $(get_sd_size $INDEV) / 2 )) ))
    if [ $SPACENEEDED -gt $(get_freespace "$DEFAULT_PATH") ]; then
        whiptail --backtitle "$BACKTITLE" --title "WARNING" \
            --msgbox "Might not be enough free space on '$DEFAULT_PATH'
            \n\n'$(get_sd_name $INDEV)' is $(get_sd_size $INDEV -h)mb
            \nfreespace on '$DEFAULT_PATH' is $(get_freespace "$DEFAULT_PATH" -h)
            \nThere is $(get_folder_size /home/pi/.local/share/Trash) in the Trash" $WT_MB_HEIGHT $WT_MB_WIDTH   
    fi
    
    # maybe check and see if it looks like a raspbian disk?
}


gui_get_outfile(){
    # for backup
    
    OUTFILEDEFAULT="$DEFAULT_PATH/$(date +%Y-%m-%d-newimage)"
           
    while [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] || [ -f "$(get_file_base $OUTFILE).img" ] || [ -z "$(get_file_ext_ok $OUTFILE)" ] || [ ! -d  "$(get_file_path $OUTFILE)" ]  ; do  
        
        # Add Zip if no extension
        if [ ! -z "$OUTFILE" ] && [ -z "$(get_file_ext $OUTFILE)" ] ; then 
             OUTFILE=$OUTFILE.$DEFAULT_EXTENSION
        fi
        
        # Message if OUTFILE exists
        if [ -f "$OUTFILE" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "File '$OUTFILE' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        # Message if OUTFILE_BASE.img exists
        if [ -f "$(get_file_base $OUTFILE).img" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "File '$(get_file_base $OUTFILE).img' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        # Message if unsupported ext
        if [ -z "$(get_file_ext_ok $OUTFILE)" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "Unsupported extension '$(get_file_ext $OUTFILE)' " $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        # Message if path does not exist
        if [ ! -d  "$(get_file_path $OUTFILE)" ] ; then
            whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "Directory does not exist '$(get_file_path $OUTFILE)' " $WT_MB_HEIGHT $WT_MB_WIDTH 
        fi
        
        
        #get filename
        MSG="Enter the filename (eg 2020-12-15-buster32) 
        \nSupported extensions are: .img .zip .xz .gz 
        \nIf you don't include an extension '.$DEFAULT_EXTENSION' will be added 
        \n.img files are shrunk but NOT compressed
        \n.xz is ~25% smaller but takes 3x-4x longer
        \nRecomended to have NO SPACES in the name "
        NEWFILE=$(whiptail --backtitle "$BACKTITLE" --title "BACKUP : Enter Filename" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$OUTFILEDEFAULT" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then 
            return $EXIT_CODE
        fi
        
        #fill out variables based on selected filename
        OUTFILEDEFAULT=$NEWFILE
        OUTFILE=$NEWFILE
        
        # add .zip if no extension
        if [ ! -z "$OUTFILE" ] && [ -z "$(get_file_ext $OUTFILE)" ] ; then 
             OUTFILE=$OUTFILE.$DEFAULT_EXTENSION
        fi
      done     
}


gui_get_infile(){
    # for restore
    
    if whiptail_fselect "WRITE : Select an Image-file" "$DEFAULT_PATH" "zip" "no" ; then
    INFILE=$FILE_SELECTED
    else
        return 1
    fi
     
    check_for_img_file "$INFILE"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No image file found in '$INFILE'"  $WT_MB_HEIGHT $WT_MB_WIDTH
    fi 
}


gui_get_outdev(){
    # for restore

    gui_select_sddevice "RESTORE"       # this sets global variable OUTDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi    
    
    #stop if outdev is piSave-locked
    if [ $(get_config_var device_$(get_device_serial $OUTDEV) $CONFIG) = "locked" ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Device '$(get_device_serial $OUTDEV)' 
        \nis locked by PiSafe in the config file" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
    
    # Stop if outdev is the root disk
    if [ $OUTDEV = /dev/$(get_root_disk) ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Restore to root disk not allowed" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
    
    # Warning if device is large
    if [ $(get_sd_size $OUTDEV) -gt $LARGE_DEVICE_WRITE_WARNING ]; then
        if (whiptail  --backtitle "$BACKTITLE" --title " RESTORE WARNING " --defaultno \
            --yesno "'$(get_sd_name $OUTDEV)' 
            \nis larger than $(get_bytes_h $LARGE_DEVICE_WRITE_WARNING)... 
            \n\nAre you sure it is the right device?" $WT_HEIGHT $WT_WIDTH) then
            RESULT="YES"
        else
            RESULT="n"
            return 1
        fi
    fi
     
    # Stop if imagefile is larger than device
    if [ $(get_image_size_bytes "$INFILE") -gt $(get_sd_size $OUTDEV) ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Not enough room
        \nThe image in '$INFILE' is ' $(get_image_size "$INFILE")' 
        \nand '$OUTDEV' is only '$(get_sd_size $OUTDEV -h)'" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
}


gui_do_backup(){
    INDEV=$1  #use global vars  
    OUTFILE=$2   #use global vars
    
    #get global variable INDEV
    gui_get_indev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    # get global variable OUTFILE
    gui_get_outfile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    #confirm to continue
    whiptail  --backtitle "$BACKTITLE" --title "BACKUP : Create Image-file" --defaultno \
        --yesno "Backup '$(get_sd_name $INDEV)' on '$INDEV' 
        \nto '$OUTFILE'.
        \n\nA good 8GB card of RaspiOS on a Pi4 takes about 10 minutes.
        \nThis will switch to the terminal screen to watch the progress ...
        \nLast chance before creating image-file.
        \n\nAre you sure you want to continue?"   $WT_HEIGHT $WT_WIDTH
    EXIT_CODE=$?       
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi


    ###########################################################
    # this next line actually does the work!!
    do_backup $INDEV "$OUTFILE" "gui"
    EXIT_CODE=$?
    
    if [ $EXIT_CODE != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$DEBUG_MODE
        echo Exit_code=$EXIT_CODE
        read -n 1 -p "Press any key to continue..." 
        if [ $EXIT_CODE != 0 ] ; then
# does this need a whiptail msgbox saying there was an error?        
            return $EXIT_CODE
        fi   
    fi 
    ###########################################################

    # Display results
    whiptail  --backtitle "$BACKTITLE" --title " BACKUP-DONE "  \
        --msgbox "'$(get_sd_name $INDEV)' backed up to 
        \n'$OUTFILE' 
        \ncompressed from '$(get_sd_size $INDEV -h)' to '$(get_file_size $OUTFILE)' in $(get_elapsed_time $TIME1 $TIME4) 
        \n\nYou can remove '$(get_sd_name $INDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}  


gui_do_restore() {   
    # get global variable INFILE
    gui_get_infile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    # get global variable OUTDEV
    gui_get_outdev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi

    # Confirm to continue
    #do_beep_if_sound
    if (whiptail  --backtitle "$BACKTITLE" --title "RESTORE - WARNING" --defaultno \
        --yesno "Restore '$INFILE' 
        \nto SD card '$(get_sd_name $OUTDEV)' on '$OUTDEV' 
        \n\nALL existing data on '$OUTDEV' - WILL BE ERASED!  
        \nAre you sure you want to continue?" $WT_HEIGHT $WT_WIDTH) then
        #echo "User selected Yes, exit status was $?."
        RESULT="YES"
    else
        #echo "User selected No, exit status was $?."
        RESULT="n"
        return 1
    fi

    #Countdown before continuing
    do_beep_if_sound
    whiptail_countdown 10 "" "Overwriting '$(get_sd_name $OUTDEV)' in "
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE-ABORTED " --msgbox "Key Pressed.  \n\nRestore Aborted. " $WT_MB_HEIGHT $WT_MB_WIDTH
        return $EXIT_CODE
    fi    
              
   ###################################################       
    # do the restore
    # the third parameter turns "SAFETY" to "off".  this is because we already checked with the GUI.
    
    do_restore "$INFILE" $OUTDEV off GUI
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$DEBUG_MODE
        echo Exit_code=$EXIT_CODE
        read -n 1 -p "Press any key to continue..." 
        if [ $EXIT_CODE != 0 ] ; then
            return $EXIT_CODE
        fi   
    fi 
   ###################################################
 
    #display the results
    whiptail  --backtitle "$BACKTITLE" --title " RESTORE-DONE " \
        --msgbox "'$INFILE' restored to 
        \n'$(get_sd_name $OUTDEV)'
        \nin $(get_elapsed_time $TIME1 $TIME2)
        \n\nYou can remove '$(get_sd_name $OUTDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}


gui_select_sddevice(){
    TITLE=$1
    FIELD_SEPERATOR="|"

    #get this list of sd devices and add a field seperator |    
    IFS=$'\n'
    #options=($(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ ./ | /'))
    options=($(get_sd_devices | sed 's/ ./ '$FIELD_SEPERATOR' /'))
    unset IFS
    
    arraylength=${#options[@]}
    if [ $arraylength = 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No SD cards found." $WT_MB_HEIGHT  $WT_WIDTH
        return 1
    fi

    IFS=$FIELD_SEPERATOR
    DEVICE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$TITLE"\
     --menu "Choose an SD card (Hide root disk = $HIDE_ROOT_DISK)" 30 80 10 ""${options[@]}"" 3>&1 1>&2 2>&3)
    EXIT_CODE=$?
    unset IFS   
     
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    OUTDEV=/dev/$DEVICE_SELECTED
    INDEV=/dev/$DEVICE_SELECTED
    return 0
}


gui_tools_retired(){
    local SELECTION
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "TOOLS" --menu " Choose " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
        "INSTALL"           "Install $PRODUCTNAME into the menu" \
        "UPDATE"            "Check for updates" \
        "VIEW TERMINAL   "  "View terminal screen for debugging" \
        "HELP"              "Help" \
        "ABOUT"             "ABOUT $PRODUCTNAME" \
        3>&1 1>&2 2>&3)
        
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        else
            case "$SELECTION" in
            INSTALL)    gui_do_install  ;;
            UPDATE)    gui_update  ;;

            VIEW*)      read -n 1 -p "Press any key to return"  ;;
            HELP)
                INFO=$(do_help)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
                ;;
            ABOUT)
                INFO=$(do_about)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
                ;;   
            *)           whiptail --msgbox "Programmer error: unrecognized option" 20 60 1 ;;
            esac 
        fi
    done
}


gui_menu(){
    whiptail_calc_wt_size
    INTERFACE="GUI"
    while true
    do
        MENU_CHOICE=$(whiptail \
                --clear \
                --backtitle "$BACKTITLE" \
                --title "MAIN MENU" \
                --ok-button "Select" \
                --cancel-button "Exit" \
                --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "BACKUP"    "   Backup an SD-card to an image-file" \
                "RESTORE"   "   Restore an SD-card from an image-file" \
                "LIST"      "   List info" \
                                "  "        "   " \
                "SETTINGS"  "   Change settings" \
                "INSTALL"   "   Install $PRODUCTNAME into the menu" \
                "UPDATE"    "   Check for updates" \
                "VIEW TERMINAL" "   View the terminal (for debugging)" \
                "HELP"      "   Help" \
                "ABOUT"     "   About $PRODUCTNAME" \
                3>&1 1>&2 2>&3)
                
        #echo $MENU_CHOICE
        case $MENU_CHOICE in
            BACKUP)         gui_do_backup   ;;
            
            RESTORE)        gui_do_restore  ;;
            
            LIST)
                INFO=$(do_list_info $DEFAULT_PATH)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "LIST" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
                ;;
            
            SETTINGS)       gui_settings    ;;
            
            INSTALL)        gui_do_install     ;;
            
            UPDATE)         do_update       ;;
            
            VIEW*)          read -n 1 -p "Press any key to return to $PRODUCTNAME"   ;;
            
            HELP)
                INFO=$(do_help)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
                ;;
            
            ABOUT)
                INFO=$(do_about)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH
                ;;   
            
            TOOLS)          gui_tools       ;;
            
            "  "*)                          ;;
            
            *)              return          ;;
        esac
    done
}


# if arg = -v, then show version and exit the script
if  [ ! -z "$1" ]  && [ $1 = "-v" ]; then
    echo $SCRIPTVER
    exit
fi


#get_bytes_h 200
#get_bytes_h 20000
##get_bytes_h 120000003
#get_bytes_h 7400000000
#get_bytes_h 24000003000000
#exit


do_init_conf
get_settings
fix_settings
get_tools
whiptail_calc_wt_size


cli_menu $1 $2 $3
