#!/bin/bash

COPYRIGHT="By Richard Reed 2018 - 2021"

# references
# https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
# https://www.instructables.com/id/How-to-BackUp-and-Shrink-Your-Raspberry-Pi-Image/
# https://github.com/Drewsif/PiShrink

#echo empty the /root/.local/share/Trash folders to free up room

SCRIPTNAME="${0##*/}"
SCRIPTVER="0.9.12"
PRODUCTNAME="PiSafe"
PRODUCTCOMMENT="Raspberry Pi Imaging App"
CURRENT_DIR=$(pwd)
USER=$(whoami)
CONFIG=/home/$USER/.config/pisafe/pisafe.conf
LOG_FILE=/home/$USER/PiSafe.log
REQUIRED_TOOLS="lua pv bc whiptail zip pigz "
REQUIRED_TOOLS_SPECIAL_INSTALL="pishrink.sh xz"
INTERFACE="CLI"

WHITE='\033[1;37m'
RED='\033[1;31m'
NC='\033[0m' 		# No Color, standard text
echo_white()        { (echo -e "${WHITE}$*${NC}") }
echo_red()          { (echo -e "${RED}$*${NC}") }

INDEV=
OUTDEV=
INFILE=
OUTFILE=
BACKTITLE="$PRODUCTNAME ver $SCRIPTVER   === $PRODUCTCOMMENT === "


get_opts(){
while getopts ":pdhv" opt; do
  case "${opt}" in
    p) parallel=off;;
    d) debug=on;;
    h) help;;
    a) autoexpand=off ;;
    v) verbose=on;;
    *) help;;
  esac
done
shift $((OPTIND-1))
}


do_help() {
    echo "$PRODUCTNAME v$SCRIPTVER  - Designed for Raspberry Pi"
    echo " - Backup your SD card to an image file"
    echo " - Restore your SD card from an image file"
    echo
    echo "Usage: "
    echo "  $SCRIPTNAME [function] [device/file] [file/device]"
    echo
    echo "Function is:"
    echo "                            - startup the gui menu (this is recomended)"
    echo "  list                      - list SD-devices and image-files "
    echo "  backup [device] [file]    - backup SD-card to image-file"
    echo "  restore [file] [device]   - restore image-file to SD-card"
    echo "  install                   - install this script"
    echo "  update                    - update script from webiste"
    echo "  -v                        - display version"
    echo "  help | -h                 - help"
    echo
    echo "Notes: "
    echo " - Supports .img .zip .xz and .gz files.  Appends '.$DEFAULT_EXTENSION' if no extension is specified "
    echo " - Specifying an '.img' extension is faster, but twice the size because it is not compressed with $DEFAULT_EXTENSION."
    echo
    #echo It will run dd, then pishrink, then compress to create a smallimage file of the SD card
    echo
    echo "Examples:"
    echo $SCRIPTNAME 
    echo $SCRIPTNAME list
    echo $SCRIPTNAME backup sda newimage
    echo $SCRIPTNAME backup /dev/sdb newimage.xz
    echo $SCRIPTNAME restore newimage.zip sda
    echo
}


do_about(){
    echo "$PRODUCTNAME was started in 2017 as 'sd' by 'RichardMidnight on github'"\
        "when he was working on a Raspberry Pi Homebridge project and needed"\
        "to make numerous restore-points.  The image writers available at the"\
        "time did not run on the pi itself and were not able to create a new image file." 
    echo
    echo "It was originally called 'sd' and only had a CLI."
    echo
    echo "Then in 2021, he added the menu front-end to make it more usable by others"\
        "and renamed it 'PiSafe'.  PiSafe is a reference to the 'ventilated cupboards for storing"\
        "pies while protecting them from insects and vermin'. "
    echo
    echo "It may work on many debian distros, but that is not been tested."
    echo
    echo "Use at your own risk."
    echo
    echo "I hope this is helpful to others."
    echo
}

#  Settings #########################################


do_factory_reset(){
   # echo " " > $CONFIG

    set_conf_defaults
    get_settings
}


do_init_conf(){
    if [ ! -d $(get_file_path $CONFIG) ]; then
        mkdir -p $(get_file_path $CONFIG)
    fi
    
    if [ ! -f $CONFIG ]; then
        #echo " " > $CONFIG
        touch $CONFIG
        echo "# $CONFIG" > $CONFIG
        set_conf_defaults
    fi
}


set_conf_defaults(){
    set_config_var settings_script_ver $SCRIPTVER $CONFIG
    set_config_var default_path $HOME/Downloads $CONFIG
    set_config_var hide_root_device on $CONFIG
    set_config_var hide_mmc_device on $CONFIG
    set_config_var check_for_updates_on_startup on $CONFIG

#backup settings
    set_config_var shrink_fs on $CONFIG
    set_config_var auto_expand_fs on $CONFIG
    set_config_var default_extension zip $CONFIG
    set_config_var compression_level 1 $CONFIG
    set_config_var parallel_compression on $CONFIG
    set_config_var large_device_read_warning 17179869184 $CONFIG
    
#restore settings
    set_config_var large_device_write_warning 17179869184 $CONFIG
    set_config_var safety on $CONFIG    

#other    
    set_config_var debug_mode off $CONFIG
    set_config_var sound on $CONFIG
    set_config_var log on $CONFIG
    
    if [ -z $(which mousepad) ]; then
        set_config_var text_editor nano $CONFIG
    else
        set_config_var text_editor mousepad $CONFIG
    fi
}


get_settings(){
    SETTINGS_SCRIPT_VER=$(get_config_var settings_script_ver $CONFIG)
    DEFAULT_PATH=$(get_config_var default_path $CONFIG)
    DEFAULT_EXTENSION=$(get_config_var default_extension $CONFIG)
    COMPRESSION=$(get_config_var compression_level $CONFIG)
    HIDE_ROOT_DEVICE=$(get_config_var hide_root_device $CONFIG)
    CHECK_FOR_UPDATES_ON_STARTUP=$(get_config_var check_for_updates_on_startup $CONFIG)
    
    HIDE_MMC_DEVICE=$(get_config_var hide_mmc_device $CONFIG)
    
    DEBUG_MODE=$(get_config_var debug_mode $CONFIG)
    SOUND=$(get_config_var sound $CONFIG)
    SHRINK_FS=$(get_config_var shrink_fs $CONFIG)
    AUTO_EXPAND_FS=$(get_config_var auto_expand_fs $CONFIG)
    TEXT_EDITOR=$(get_config_var text_editor $CONFIG)
    SAFETY=$(get_config_var safety $CONFIG)
    LOG=$(get_config_var log $CONFIG)
    
    VERIFY=off
    LARGE_DEVICE_READ_WARNING=$(get_config_var large_device_read_warning $CONFIG) 
    LARGE_DEVICE_WRITE_WARNING=$(get_config_var large_device_write_warning $CONFIG) 
    
    mkdir -p "$DEFAULT_PATH"
}


set_config_var() {
  lua - "$1" "$2" "$3" <<EOF > "$3.bak"
local key=assert(arg[1])
local value=assert(arg[2])
local fn=assert(arg[3])
local file=assert(io.open(fn))
local made_change=false
for line in file:lines() do
  if line:match("^#?%s*"..key.."=.*$") then
    line=key.."="..value
    made_change=true
  end
  print(line)
end

if not made_change then
  print(key.."="..value)
end
EOF
mv "$3.bak" "$3"
}


clear_config_var() {
  lua - "$1" "$2" <<EOF > "$2.bak"
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
for line in file:lines() do
  if line:match("^%s*"..key.."=.*$") then
    line="#"..line
  end
  print(line)
end
EOF
mv "$2.bak" "$2"
}


get_config_var() {
  lua - "$1" "$2" <<EOF
local key=assert(arg[1])
local fn=assert(arg[2])
local file=assert(io.open(fn))
local found=false
for line in file:lines() do
  local val = line:match("^%s*"..key.."=(.*)$")
  if (val ~= nil) then
    print(val)
    found=true
    break
  end
end
if not found then
   print(0)
end
EOF
}


# -------------------------------------------------------------


echo_if_cli (){
    local MSG=$1
    local COLOR=$2
    if [ $INTERFACE = "CLI" ]; then
        case $COLOR in
            white) echo_white $MSG ;;
            red)    echo_red $MSG ;;
            *) echo $MSG ;;
        esac
    fi
}


do_write_log(){
    INFO=$*
    if [ $LOG = "on" ]; then
        touch $LOG_FILE
        echo "$(date "+%Y-%m-%d %H:%M"), $INFO" >> $LOG_FILE
    fi
}


msgbox(){
   whiptail --msgbox "$*" $WT_MB_HEIGHT $WT_MB_WIDTH
}


is_number() {
  case $1 in
    ''|*[!0-9]*) return 0 ;;
    *) return 1 ;;
  esac
}


do_countdown(){  
    local MAX=${1:-10}
 
    echo "Pausing for $MAX seconds... Ctrl-C to abort"
	echo -n $MAX
    sleep 1
    for number in $(seq 1 $MAX) ; do
		echo -n ".$(($MAX-$number))"
		sleep 1
    done 
    echo ...
}


do_beep(){
    #speaker-test -t sine -f 1000 -l 1 & sleep .3 && kill -9 $!
    speaker-test -t sign -f 700 > /dev/null  & sleep .5 && kill -9 $! 
    sleep .5  # to allow the beep to end
}


do_beep_if_sound(){
    if [ $SOUND = on ] ; then
        do_beep
    fi
}


get_elapsed_time() {
    # paramaters are in seconds
    local BEG=$1
    local END=$2
    
    echo $(( $(( $END-$BEG ))/60)) min $(( $(( $END-$BEG ))%60 )) sec 
}


get_ver_to_int() {
	local IFS=.
	parts=($1)
	let val=1000000*parts[0]+1000*parts[1]+parts[2]
	echo $val
    unset IFS
}


get_bytes_h(){
    BYTES=$1
    # currently shows 3 significant digits.
    
    NUM='^[0-9]+$'
    if ! [[ "$BYTES" =~ $NUM ]] ; then   # not a number
        #echo $BYTES    
        return 1
    fi
    
    [ -z "$BYTES" ] && return
    #need some error checking that it is a number
    
    k_ilo=1024;
    m_ega=$k_ilo*$k_ilo;
    g_iga=$m_ega*$k_ilo;
    t_era=$g_iga*$k_ilo;
    p_eta=$t_era*$k_ilo;
    
    LEN=${#BYTES}
    
    case $LEN in
        4) echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
        5) echo $(echo "scale=1; $BYTES/($k_ilo)" | bc)kb ;;
        6) echo $(echo "scale=0; $BYTES/($k_ilo)" | bc)kb ;;
        
        7) echo $(echo "scale=2; $BYTES/($m_ega)" | bc)mb ;;
        8) echo $(echo "scale=1; $BYTES/($m_ega)" | bc)mb ;;
        9) echo $(echo "scale=0; $BYTES/($m_ega)" | bc)mb ;;
        
        10) echo $(echo "scale=2; $BYTES/($g_iga)" | bc)gb ;;
        11) echo $(echo "scale=1; $BYTES/($g_iga)" | bc)gb ;;
        12) echo $(echo "scale=0; $BYTES/($g_iga)" | bc)gb ;;
        
        13) echo $(echo "scale=2; $BYTES/($t_era)" | bc)tb ;;
        14) echo $(echo "scale=1; $BYTES/($t_era)" | bc)tb ;;
        15) echo $(echo "scale=0; $BYTES/($t_era)" | bc)tb ;;
        *)  echo $BYTES ;;
    esac
}


get_file_device(){
    #echo $1
    MOUNT_POINT=$(df -a "$1" | sed 's/  */ /g' | grep -v Mounted | cut -d ' ' -f 6  )
    #echo $MOUNT_POINT
    BLK_DEV=$(lsblk -n -l -p -o PKNAME,MOUNTPOINT,NAME | sed 's/  */ /g' | grep " $MOUNT_POINT " | cut -d " " -f 1)
    echo $BLK_DEV
}


get_file_path(){
    dirname "$*"
}


get_file_base() {
   # basename "$*"
    local fullfilename=$*
    
    filename=$(basename "$fullfilename")
    fname="${filename%.*}"
    echo "$fname"
}


get_file_path_base(){
    #echo $(get_file_path "$*")/$(get_file_base "$*")
    echo "$*" | cut -d. -f1
}


get_file_ext(){
	base=$(basename "$*")
	
	#look for a period in the basename.  if there is one, there is an extention
	HAS_DOT=$(echo "$base" | grep \\.)
	if [ ! -z "$HAS_DOT" ] ; then
		echo $base | sed 's#.*\.##g'
	else  
		echo ""
		return 1
	fi
}


get_file_size() {
    local FILE=$1
    local HUMAN=${2:-"no"}
    # $2 can be -h
    
    if [ -f "$FILE" ] ; then
        SIZE_BYTES="$(($(ls -s "$FILE" | cut -d' ' -f1) * 1024))"
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
        if [ $HUMAN = "-h" ]; then
            echo $(get_bytes_h $SIZE_BYTES)
        else
            echo $SIZE_BYTES
        fi
    else
        echo 0
    fi
}


get_sd_name(){
   lsblk -d -n -l -o NAME,VENDOR,MODEL,SIZE $1  2> /dev/null
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE
    fi
}


get_sd_size() {
    # $1 is devicename
    local DEV=$1
   local HUMAN=${2:-"no"}
   
     # add '/dev/' if missing
    if [ "${DEV:0:5}" != "/dev/" ]; then
        #echo "Device prefix not specified.  Adding '/dev/'"
        DEV="/dev/"$DEV
        #echo "IN-DEV='$INDEV'"
    fi
   
    SIZE_BYTES=$(lsblk $DEV -d -n -b -o size  2> /dev/null)
    EXIT_CODE=$?
        
    if [ $EXIT_CODE != 0 ]; then
        echo 0
        return $EXIT_CODE       
    fi
    
    if [ $HUMAN = "-h" ]; then
        echo $(get_bytes_h $SIZE_BYTES)
    else
        echo $SIZE_BYTES
    fi
    
    
# an alternative way:
# echo $(( $(sudo blockdev --getsize64 /dev/sda) ))
# echo $(( $(sudo blockdev --getsize64 /dev/sda)/1024/1024 ))mb    
}


get_device_serial(){
    local DEVICE=$1
    # currently vendor + SN
    SN=$(lsblk -n -d --output vendor,model,serial "$DEVICE" | sed 's/ /_/g' )
    echo $SN
}


get_image_size() {
    local INFILE="$1"
    local HUMAN=${2:-"no"}
    
    check_for_img_file "$INFILE" > /dev/null
    if [ $? != 0 ] ; then
        # image file not found
        echo 0
        return 1
    fi
    
    case $(get_file_ext "$INFILE") in
        img)
            SIZE_BYTES=$(echo $((  $(ls -s "$INFILE" | cut -d' ' -f1 ) * 1024 )) )
        ;;
        
        zip)
            SIZE_BYTES=$(zipinfo -t "$INFILE" 2> /dev/null | grep "%" | cut -d, -f2 | cut -d" " -f2  )
        ;;
        
        xz)
            SIZE_BYTES=$(xz -l -v "$INFILE" 2> /dev/null | grep Uncompressed | sed 's/\s\s*/ /g' | cut -d'(' -f 2 | cut -d ' ' -f1 | sed 's/,//g')
        ;;  
          
        gz)
            #SIZE_BYTES=$(pigz -l "$INFILE" 2> /dev/null | grep -v compressed | sed 's/\s\s*/ /g' | cut -d' ' -f 2 | sed 's/?/0/g')
            SIZE_BYTES=$(pigz -l "$INFILE" 2> /dev/null | grep -v compressed | sed 's/\s\s*/ /g' | sed -e 's/^[ \t]*//' | cut -d' ' -f 2 | sed 's/?/0/g')
            # | sed -e 's/^[ \t]*//'
        ;;
        
        *)
            echo 0
            return 1
        ;;
    esac
    
    if [ -z $SIZE_BYTES ] ; then
        echo 0 
        return 0
    fi
    
    
    if [ $HUMAN = "-h" ]; then
        echo $(get_bytes_h $SIZE_BYTES)
    else
        echo $SIZE_BYTES
    fi
}    


get_root_device() {
    local ROOT_PARTITION
    local ROOT_DRIVE
    
    ROOT_PARTITION=$(lsblk -l | grep "/$" | cut -d' ' -f1 2> /dev/null) 
    
    if [ -z $ROOT_PARTITION ]; then
        return 1  # can't find root partition or root device
    fi
    
    if [[ $ROOT_PARTITION =~ "p" ]]; then
        ROOT_DRIVE=$(echo $ROOT_PARTITION | cut -d'p' -f1)
    elif [[ $ROOT_PARTITION =~ "sd" ]]; then
        ROOT_DRIVE=${ROOT_PARTITION:0:3}
    else
        return 2  # can't find root device
    fi    
    echo $ROOT_DRIVE
}


get_freespace() {
    local FILENAME=${1:-"."}  
    local FORMAT=${2:-"-B1"}   # -B1 for bytes    -h for humanreadable
    local FREESPACE
    
    if [ -d "$FILENAME" ]; then
        FREESPACE=$(df "$FILENAME" $FORMAT --output=avail | grep -v Avail)
        EXIT_CODE=$?
    else
        FREESPACE=$(df $(dirname "$FILENAME") $FORMAT --output=avail | grep -v Avail)
        EXIT_CODE=$?
    fi

    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo $FREESPACE
}   


get_folder_size() {
    local FOLDER=$*
    # returns hunam readable
    
    if [ -d "$FOLDER" ] ; then
        sudo du -sh "$FOLDER" | cut -d'/' -f1 | sed 's/\s\s*/ /g'
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        fi
    else
        echo 0
    fi
}

# ---------------------------------------------------------

get_file_ext_ok(){
    #check_for_supported_file_extention(){
    #returns 0 if good, 1 if bad
    OUTFILE_EXT=$(get_file_ext "$1")

    case $OUTFILE_EXT in
        img | zip | xz | gz |"" )
            echo true
            return 0
        ;;
        
        *)  
            echo ""
            return 1
        ;;
    esac
}


check_for_img_file(){
    # returns 0 if there is an imagefile
    # returns 1 if no imagefile

    local INFILE="$*"
    local IMG
    
    if [ ! -f "$INFILE" ] ; then
        echo_if_cli "ERROR '$INFILE' not found"
        return 1
    fi
    
    echo -n "Inspecting '$INFILE' for an image file ... "
 
    case $(get_file_ext "$INFILE") in
        img)
            IMG=$INFILE
        ;;
        
        zip)
            IMG=$(zipinfo -1 "$INFILE" 2> /dev/null | grep .img | cut -d " " -f 11)  
        ;;
        
        xz)
            IMG=$(xz -l "$INFILE" 2> /dev/null | grep .img | sed 's/\s\s*/ /g' | cut -d' ' -f10-)
  
            #IMG=$(xz -l "$INFILE" | grep .xz | sed 's/\s\s*/ /g' | cut -d' ' -f10-)
            #IMG=$(echo "$IMG" | sed 's/.xz/.img/g')
         ;;   
         
         gz)
            IMG=$(pigz -l "$INFILE" 2> /dev/null | grep .img | sed 's/\s\s*/ /g' | cut -d " " -f4-)
         ;;
         
         *)
            IMG=
        ;;
    esac
    
    if [ ! -z "$IMG" ] ; then
        echo "$IMG" [OK]
        return 0
    else
        echo "ERROR: No image found in '$INFILE'"
        return 1
    fi    
}

# -----------------------------------------------


do_list_image_files(){
    FILES="FILE_NAME FILE_SIZE (IMAGE_SIZE) \n"
    CONFIG=/home/$USER/.config/pisafe/pisafe.conf
    IFS=$'\t\n'
    
    for FILE in $(ls *.img *.zip *.xz *.gz 2>/dev/null) ; do
        FILE_NS=$(echo "$FILE" | sed 's/ /_/g')
        FILES="$FILES $FILE_NS  $(get_file_size "$FILE" -h)  ($(get_image_size "$FILE" -h)) \n "
        #FILES="$FILES $FILE_NS  $(get_file_size "$FILE" -h)   \n "
    done

    printf $FILES | column  -t
    #printf $FILES
    unset IFS
}


do_list_info() {
        DIR=${1:-$PWD}
        echo "~~~ CURRENT SYSTEM ~~~"
        echo "Root device = /dev/$(get_root_device)"
        echo "Size      = $(get_sd_size /dev/$(get_root_device) -h )"
        echo "FreeSpace = $(get_freespace . -h)"
        echo "TrashSize = $(get_folder_size /home/pi/.local/share/Trash)"
        echo "RootTrash = $(get_folder_size /root/.local/share/Trash)"
        echo
        #echo "~~~ PiSafe LOCKED DEVICES ~~~"
        #echo "$(cat $CONFIG | grep "device_lock")"
        #echo
        echo
        echo "~~~ SD-CARD DEVICES ~~~  (hide root device = $HIDE_ROOT_DEVICE) (hide mmc = $HIDE_MMC_DEVICE)"
        echo "$(get_sd_devices)"
        echo   
        echo
        echo "~~~ IMAGE FILES in '$DIR' ~~~"
        SAVED_PWD=$PWD
        #echo $OLD_DIR
        #echo $DEFAULT_PATH
        cd $DIR
        #ls -1 -s -h -w1 *.img *.zip *.xz *.gz 2> /dev/null | sed 's/ /     /'
        #ls -1 -s -h -w1 $DEFAULT_PATH/*.img $DEFAULT_PATH/*.zip $DEFAULT_PATH/*.xz $DEFAULT_PATH/*.gz 2> /dev/null | sed 's/ /     /'
  
        do_list_image_files
        cd $SAVED_PWD
}    


get_sd_devices_old() {
    local DEVICES= 
    MMC_FILTER=
    BOOT_FILTER=
    if [ $(get_config_var hide_root_device $CONFIG) = "off" ]; then
        ROOT_DEVICE=$(get_root_device)      
        if [ ${ROOT_DEVICE:0:2} != "sd" ]; then
            ROOT_DEVICE="/dev/$(get_root_device)"
        else
            ROOT_DEVICE=
        fi
        #lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? /dev/$(get_root_device)
        # DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? /dev/$(get_root_device) 2> /dev/null  )   
        DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd?  $ROOT_DEVICE 2> /dev/null  )  
        EXIT_CODE=$?
    else
        #DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? 2> /dev/null | grep -v $(get_root_device))   
        DEVICES=$(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? /dev/mmcblk? 2> /dev/null )  
        EXIT_CODE=$?
    fi

    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "${DEVICES[@]}"
  }


get_sd_devices() {
    local DEVICES= 
    MMC_FILTER="aspodiausdfpoiasdf"
    BOOT_FILTER="aspodiausdfpoiasdf"
    if [ $(get_config_var hide_root_device $CONFIG) = "on" ]; then
        ROOT_DEVICE=$(get_root_device)   
        BOOT_FILTER=$ROOT_DEVICE
    fi       
    if [ $(get_config_var hide_mmc_device $CONFIG) = "on" ]; then
        MMC_FILTER="mmcblk"
    fi        
     
    DEVICES=$(lsblk -d -p -n -o NAME,VENDOR,MODEL,SIZE 2> /dev/null | grep -v $BOOT_FILTER | grep -v $MMC_FILTER)  
    EXIT_CODE=$?

    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "${DEVICES[@]}"
  }

# --------------------------------------


get_tools() {   
    
    TOOL_MISSING=false
    TOOLS=$(echo $REQUIRED_TOOLS $REQUIRED_TOOLS_SPECIAL_INSTALL)
    
    for TOOL in $TOOLS ; do
        if [ ! $(which $TOOL) ]; then
            TOOL_MISSING=true
        fi
    done
    
    if [ $TOOL_MISSING = "true" ]; then
        echo "Install required tools y/n ... $REQUIRED_TOOLS $REQUIRED_TOOLS_SPECIAL_INSTALL"
        read -n 1 -r RESULT
        echo
        if [ $RESULT != "y" ]; then
            echo
            echo_red   WARNING.  Not all the needed tools are installed.
            return 1
        fi

        for TOOL in $REQUIRED_TOOLS ; do
            if [ ! $(which $TOOL) ]; then
                echo_white Installing $TOOL ...
                sudo apt install -y $TOOL
            fi
        done
        
        # special installs ...
        
        # Install PiShrink if needed
        if [ -z $(which pishrink.sh) ]; then
            echo_white Installing pishrink...
            wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
            chmod +x pishrink.sh
            sudo mv pishrink.sh /usr/local/bin
            echo pishrink installed.
        fi

        # Install xz if needed
        if [ -z $(which xz) ]; then
            echo_white Installing xz-utils...
            sudo apt install xz-utils -y
        fi
    fi
}    


do_install() {   
    echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    read  -p "Install $SCRIPTVER to /usr/local/bin [y,N]?" -n 1 -r RESULT
    echo
    
    if [ $RESULT = "y" ]; then
        sudo cp --backup=numbered $SCRIPTNAME /usr/local/bin/$SCRIPTNAME
        sudo chmod +x /usr/local/bin/$SCRIPTNAME
        echo Installed ver=$(/usr/local/bin/$SCRIPTNAME -v)
    else
        MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
        echo_or_msgbox "ERROR" "$MSG"
    fi
}


do_update() {
    INTERFACE=${1:-"CLI"}
    SUMMARY=${2:-"yes"}
    
    echo_if_cli "This ver '$SCRIPTVER'"
      
    local SERVER_VER=
    rm $SCRIPTNAME.tmp
    wget https://raw.githubusercontent.com/RichardMidnight/pi-safe/main/$SCRIPTNAME -O $SCRIPTNAME.tmp 2> /dev/null 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ];  then
        echo_if_cli "ERROR: Can't connect to server..."
        return $EXIT_CODE
    fi    

    if [ -f $SCRIPTNAME.tmp ]; then
        SERVER_VER=$(bash $SCRIPTNAME.tmp -v)
    else
        return 1
    fi

    if [ $(get_ver_to_int $SERVER_VER) -gt $(get_ver_to_int $SCRIPTVER) ]; then
        
        if [ $INTERFACE = "CLI" ]; then
            read -p "Ver $SCRIPTVER.  Newer Version '$SERVER_VER' available.  Update [y,N]?"  -n 1 -r RESULT
            echo
        else
            whiptail --backtitle "$BACKTITLE" --title "UPDATE" --yesno "Update from '$SCRIPTVER'  to '$SERVER_VER'  ?" $WT_MB_HEIGHT $WT_MB_WIDTH
            if [$? = 0 ]; then RESULT=y; fi
            echo $?
        fi    
        
        if [ $RESULT = "y" ]; then 
            sudo mv $SCRIPTNAME.tmp /usr/local/bin/$SCRIPTNAME
            sudo chmod +x /usr/local/bin/$SCRIPTNAME
            echo "$($SCRIPTNAME -v) installed. Press any key to exit... "
            read -n 1
            exit 0
        fi
        
        
    else  
     
        if [ $INTERFACE = "CLI" ]; then
            echo_if_cli "Server version is '$SERVER_VER' You are up to date.  "
            if [ $INTERFACE = "GUI" ]; then
                read -p "Press any key to continue..." -n 1 -r RESULT
            fi
        else
            if [ $SUMMARY = "yes" ]; then
                whiptail --backtitle "$BACKTITLE" --title "UPDATE" --msgbox "$PRODUCTNAME is up to date.  Server ver '$SERVER_VER' " $WT_MB_HEIGHT $WT_MB_WIDTH
            fi
        fi
        
    fi
}


do_backup(){
    #echo 1 - sudo dd bs=4M if=/dev/$INDEV of=$OUTFILE.img status=progress conv=fsync 
    #echo 2 - sudo pishrink.sh $OUTFILE.img
    #echo 3 - zip -db -dd -m $OUTFILE.zip $OUTFILE.img
    
    local INDEV=$1
    OUTFILE=$2
    local SAFETY=${3:-on}   # off lets us bypass some of the safety prompts
    local INTERFACE${4:-CLI}  #CLI or GUI
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Backup...
    echo "IN-DEV='$INDEV'"
    echo "OUT-FILE='$OUTFILE'"
    echo  "Compression set to level $COMPRESSION of 9"
    do_write_log "Starting $PRODUCTNAME $SCRIPTVER Backup, '$INDEV' $(get_sd_size $INDEV -h), '$OUTFILE', Compression=$COMPRESSION"
        
    
    # check INDEV
    if [ -z $INDEV ] ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV' can't be blank"
        return 1
    fi 
    
    # add '/dev/' if missing
    if [ "${INDEV:0:5}" != "/dev/" ]; then
        echo "Device prefix not specified.  Adding '/dev/'"
        INDEV="/dev/"$INDEV
        echo "IN-DEV='$INDEV'"
    fi
    
    # confirm INDEV exists
    if  [ ! -e $INDEV ]  ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV' not found"
        return 1
    fi 
    
    # warning if INDEV is root device
    if [ $INDEV = /dev/$(get_root_device) ]; then
        echo
        echo_red "WARNING: SD-card is root device '/dev/$(get_root_device)'."
        #return 1
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(get_sd_size $INDEV) -gt 16000000000 ]; then
        MESG=" '$INDEV' is larger than 16GB.  \
         \nUse a smaller SD card if you can, it will copy faster.\
         \nA good 8gb card with RaspiOS in a Raspberry Pi 4 takes about 10 minutes \n"
         echo
        echo_red "WARNING... $MESG"   
    fi
    
    
    
    # Stop if SD-card is bigger than freespace on OUTFILE
    if [ $(get_sd_size $INDEV) -gt $(get_freespace "$OUTFILE") ]; then
        echo
        echo_red   "ERROR: Not enough free space on '$(get_file_path $OUTFILE)'"
        return 1
    fi
    
    # Warning if SD-card * 1.5 is bigger than freespace
        SPACENEEDED=$(( $(get_sd_size $INDEV) + $(( $(get_sd_size $INDEV) / 2 )) ))
        if [ $SPACENEEDED -gt $(get_freespace "$OUTFILE") ]; then
        echo
        echo_red   "WARNING: Might not be enough free space on '$(get_file_path $OUTFILE)'"
    fi
    
    
    # check OUTFILE
    if [ -z "$OUTFILE" ] ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE' can't be blank"
        return 2
    fi  
    
    # add ext if missing
    if [ -z $(get_file_ext "$OUTFILE") ]; then
        echo "No extension specified.  Adding '.img.$DEFAULT_EXTENSION'"
        OUTFILE=$OUTFILE.img.$DEFAULT_EXTENSION
        
        #OUTFILE_EXT=$(get_file_ext $OUTFILE)
        echo "OUT-FILE='$OUTFILE'" 
    fi

  #  check_for_supported_file_extention
    if [ -z $(get_file_ext_ok "$OUTFILE") ]; then
        echo
        echo_red "ERROR: Unsupported file extension '$(get_file_ext $OUTFILE)'"
        return $EXIT_CODE 
    fi

    if  [ -f "$OUTFILE" ]  ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE' exists"
        return 2
    fi 

    if  [ -f "$(get_file_base $OUTFILE)".img ]  ; then
        echo
        echo "$OUTFILE"
        echo "$(get_file_base $OUTFILE)"
        echo_red "ERROR x: OUT-FILE '$(get_file_base $OUTFILE).img' exists"
        return 2
    fi 

    
    
    # Final check before writing data
    if [ -z $INDEV ] || [ ! -e $INDEV ] ; then
        echo
        echo_red "ERROR: IN-DEV '$INDEV'.  Can't be blank.  Must exist."
        return 1
    fi 
    
    if [ -z "$OUTFILE" ] || [ -f "$OUTFILE" ] ; then
        echo
        echo_red "ERROR: OUT-FILE '$OUTFILE'. Cant be blank. Can't exist. "
        return 2
    fi  

    #do_beep_if_sound
    #echo_red "WARNING starting in 10 seconds ... Ctrl-C to abort"
    #do_countdown 10

    #################################################
    # this section writes the data
    #################################################
    #OUTFILE_BASE=$(get_file_path "$OUTFILE")/$(get_file_base "$OUTFILE")
    OUTFILE_BASE=$(get_file_path_base "$OUTFILE" )

    TIME1=$(date +%s)
    echo_white "Step 1 of 3 - Reading  '$INDEV' to '$OUTFILE_BASE.img' ... "
    date
    echo $(get_sd_size $INDEV -h) to read
    #sudo dd bs=4M if=$INDEV of="$OUTFILE_BASE".img status=progress conv=fsync 
    sudo pv $INDEV | dd bs=4M of="$OUTFILE_BASE".img conv=fsync 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    sleep 5s
    echo Done reading SD card
    echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
    TIME2=$(date +%s)  
    echo_white Step 1 took $(get_elapsed_time $TIME1 $TIME2)
    echo
   
    echo_white Step 2 of 3 - Shrinking filesystem with PiShrink ...
    PI_SHRINK_OPTS=
    if [ $AUTO_EXPAND_FS = "off" ] ; then 
        PI_SHRINK_OPTS="-s"
    fi
    if [ $SHRINK_FS != "off" ]; then
        sudo pishrink.sh $PI_SHRINK_OPTS "$OUTFILE_BASE".img
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            echo Continuing without shrinking file system
            #return $EXIT_CODE
        fi
    else
        echo "Filesystem not shrunk.  Setting is 'off'."
    fi
    echo Done shrinking filesystem
    echo_white \'$(ls -s -h "$OUTFILE_BASE".img)\'
    TIME3=$(date +%s)
    echo_white Step 2 took $(get_elapsed_time $TIME2 $TIME3)
    
    echo
    echo_white "Step 3 of 3 - Compressing '$OUTFILE_BASE.img' to '$OUTFILE' ... "
    date
    echo Compression set to level $COMPRESSION of 9
    echo "$(get_file_size $OUTFILE_BASE.img -h) to compress."
    
   
    case $(get_file_ext "$OUTFILE") in
        img)
            echo Not compressing .img file ...
        ;;
        
        zip)
            local FILESIZE_M=$(( $(get_file_size "$OUTFILE_BASE".img)/1024/1024 ))
            local DOTSIZE=$(( $FILESIZE_M / 50 ))
            echo Each dot=$DOTSIZE MB
            echo -n "                      $OUTFILE_BASE.img"
            echo ".........20........40........60........80........100%"
            zip -dbds $DOTSIZE -m -$COMPRESSION "$OUTFILE" "$OUTFILE_BASE".img
            EXIT_CODE=$?
            
            #With progress bar... loses .img in the image
            #sudo pv "$OUTFILE_BASE".img | sudo zip -$COMPRESSION  > "$OUTFILE"
            #EXIT_CODE=$? 
            #sudo rm -f "$OUTFILE_BASE".img 
        ;;
        
        xz)
            #sudo xz -z -v -T0 -$COMPRESSION "$OUTFILE_BASE".img
            #EXIT_CODE=$?     
            ##OUTFILE="$OUTFILE_BASE".img.xz
            ##sudo mv "$OUTFILE_BASE".img.xz "$OUTFILE"  
            
            # With progress bar
            pv "$OUTFILE_BASE".img | xz -z -c -T0 -$COMPRESSION > "$OUTFILE"
            EXIT_CODE=$? 
            rm -f "$OUTFILE_BASE".img
        ;;
        
        gz)
            #echo $(get_file_size "$OUTFILE_BASE".img -h) to compress.  Sorry, gz has no progress bar.   Please wait...
            #sudo pigz -v -$COMPRESSION "$OUTFILE_BASE".img
            #EXIT_CODE=$?        
            #sudo mv "$OUTFILE_BASE".img.gz "$OUTFILE"
            #OUTFILE="$OUTFILE_BASE".img.gz

            # With progress bar
            pv "$OUTFILE_BASE".img | pigz -$COMPRESSION > "$OUTFILE"
            EXIT_CODE=$? 
            rm -f "$OUTFILE_BASE".img
            
            #Imprecise progress bar on backside
               #echo $(echo "scale=2; $BYTES/($k_ilo)" | bc)kb ;;
            #SIZE=$(get_file_size "$OUTFILE_BASE".img)
            #echo $(get_bytes_h $SIZE) to compress. This gz progress bar is imprecise.
            #HALF_SIZE=$(echo "$SIZE/2" | bc )
            #pigz -c -$COMPRESSION "$OUTFILE_BASE".img | pv -s $HALF_SIZE > "$OUTFILE"
            #EXIT_CODE=$? 
            #rm -f "$OUTFILE_BASE".img
        ;;
        
        *)
            echo
            echo_red ERROR... unsupported file extension \'$(get_file_ext "$OUTFILE")\'.
            return 1
        ;;
    esac
    
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    echo "Done compressing '$OUTFILE_BASE.img' to '$OUTFILE' "
    echo_white $(ls -s -h "$OUTFILE")
    TIME4=$(date +%s)
    echo_white  Step 3 took $(get_elapsed_time $TIME3 $TIME4)
    
    
    # check if "$OUTFILE" was created
    if [ ! -f "$OUTFILE" ]; then
        echo
        echo_red "ERROR: creating '$OUTFILE'"
        return 1
    fi    
    
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        do_write_log "FAILED $PRODUCTNAME $SCRIPTVER Backup, IN-DEV='$INDEV',  OUT-FILE='$OUTFILE', Compression set to level $COMPRESSION"
        return $EXIT_CODE
    else
        do_beep_if_sound
        echo_white "Backup done. '$INDEV' backed up to '$OUTFILE' in $(get_elapsed_time $TIME1 $TIME4)." 
        do_write_log "Finished $PRODUCTNAME $SCRIPTVER Backup,  $(get_sd_size $INDEV -h) to  $(get_file_size "$OUTFILE" -h) in $(get_elapsed_time $TIME1 $TIME4) " 
   
    fi
}


do_restore(){
    local INFILE=$1
    local OUTDEV=$2
    local SAFETY=${3:-on}   # this lets us bypass some of the safety prompts
    local INTERFACE${4:-CLI}  #CLI or GUI
    #   local LOCAL_PATH=${2:-$(pwd)}
    
    echo_white Starting $PRODUCTNAME $SCRIPTVER Restore...
    echo "IN-FILE='$INFILE'"
    echo "OUT-DEV='$OUTDEV'"
    echo "Safety='$SAFETY'"
    do_write_log "Starting $PRODUCTNAME $SCRIPTVER Restore, '$INFILE', '$OUTDEV'"
 
    
    
    #check INFILE
    if [ -z "$INFILE" ] ; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank"
        return 1
    fi 
    
    if  [ ! -f "$INFILE" ]  ; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' not found "
        return 1
    fi 
    
    check_for_img_file "$INFILE"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
      return $EXIT_CODE
    fi
    
    
    
    # Stop if OUTDEV is blank
    if [ -z $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank"
        return 1
    fi
    
    # Add '/dev/' if missing
    if [ ${OUTDEV:0:5} != "/dev/" ]; then
        echo_if_cli "Device prefix not specified.  Adding '/dev/'"
        OUTDEV="/dev/"$OUTDEV
        echo_if_cli "OUT-DEV='$OUTDEV'"
    fi
    
    # Stop if OUTDEV is not found
    if  [ ! -e $OUTDEV ]  ; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' not found"
        return 2
    fi 
    
    # Stop if restore to root device.
    if [ $OUTDEV = /dev/$(get_root_device) ]; then
        echo_red "ERROR: Restore to root device '/dev/$(get_root_device)' not allowed"
        return 1
    fi
    
    # Stop of INFILE is on OUTDEV
    
    
    
    # Warning if device is big
    if [ ! $SAFETY_OFF = "true" ]; then
        if [ $(get_sd_size $OUTDEV) -gt 16000000000 ]; then
            echo
            echo_red "WARNING... SD-card '$(get_sd_name $OUTDEV)' is larger than 16GB... 
            \nAre you sure it is the right device?"
            read -p "You must type 'BIG' to continue:"  -r RESULT
            if [ -z $RESULT ] || [ $RESULT != "BIG" ]; then
                echo Press any key to exit...
                return 1
            fi
        fi
    fi
    
    
    # Stop if image is bigger than device
    echo -n "Checking that Image file will fit on '$OUTDEV' ..."
    if [ $(get_image_size "$INFILE") -gt $(get_sd_size "$OUTDEV") ]; then
        echo
        echo_red ERROR... Image file is larger than SD-card.
        echo "Image size =$(get_image_size $INFILE -h)"
        echo "Device size=$(get_sd_size $OUTDEV -h)"
        return 1
    else
        echo [OK]
    fi
    
    #stop if drive is pisafe_locked
  #  $(get_config_var safety $CONFIG)
  VENDOR=$(lsblk -n -d --output vendor /dev/sda)
  SERIAL=$(lsblk -n -d --output serial /dev/sda)
  #echo Device Vendor and Serial_number=$VENDOR $SERIAL
  #if [ $(get_config_var device_$VENDOR$SERIAL $CONFIG) = "locked" ]; then
  #  do_beep_if_sound
  #  echo Drive $OUTDEV serial number $VENDOR$SERIAL is $PRODUCTNAME locked.  exiting.
  #  return 1
  #fi
    


    # Final check before writing data
    # quit if INFILE is not a file
    if [ -z "$INFILE" ] || [ ! -e "$INFILE" ]; then
        echo
        echo_red "ERROR: IN-FILE '$INFILE' cannot be blank. must exist."
        return 1
    fi 
    
    #quit if OUTDEV is not a device
    if [ -z $OUTDEV ] || [ ! -e $OUTDEV ]; then
        echo
        echo_red "ERROR: OUT-DEV '$OUTDEV' cannot be blank.  must exist."
        return 1
    fi
    
    
    
    if [ $SAFETY != "off" ]; then
        echo
        echo "Write '$INFILE' to '$OUTDEV' '$(get_sd_name $OUTDEV)' ?"
        echo_red WARNING... All existing data on \'$OUTDEV\' - will be erased!
        do_beep_if_sound
        read  -p "You must type 'YES' to continue:" -r RESULT
        echo
    
        if [ -z $RESULT ] || [ $RESULT != "YES" ]; then
            echo "You did not answer 'YES'"
            return 1
        fi
        
        do_beep_if_sound
        echo_red "WARNING '$OUTDEV' '$(get_sd_name $OUTDEV)' "
        echo_red "Will be overwritten starting in 10 seconds ... Ctrl-C to abort"
        do_countdown 10
    fi
    
    #################################################
    # this section writes the data
    #################################################
    
    echo_if_cli Unmounting SD-card $OUTDEV ...
    umount $OUTDEV?  2> /dev/null
    
    local INFILEEXT=$(get_file_ext "$INFILE")
    
    echo_if_cli "Erasing MBR, signature, and partition table from '$OUTDEV'..." "white"
	sudo dd if=/dev/zero of=$OUTDEV bs=512 count=1 > /dev/null
    
    echo        
    echo_white "Writing '$INFILE' to '$OUTDEV' ... "    
    date
    TIME1=$(date +%s)
    echo_if_cli "$(get_image_size "$INFILE" -h) to write"
    
    case $INFILEEXT in
        img)
            if [ $INTERFACE = "CLI" ]; then
                sudo dd if="$INFILE" of=$OUTDEV bs=4M conv=fsync status=progress
                EXIT_CODE=$?
            else
                (sudo pv -n "$INFILE" | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(get_sd_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                EXIT_CODE=$?
            fi
        ;;
        
        zip)
            RESTORE_BYTES=$(get_image_size "$INFILE")
            #echo $RESTORE_BYTES
             if [ $INTERFACE = "CLI" ]; then
                 unzip -p "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 EXIT_CODE=$?
            else
                (unzip -p "$INFILE" | pv -n -s $RESTORE_BYTES | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(get_sd_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                 EXIT_CODE=$?
            fi
            
            #if [ $INTERFACE = "GUI" ] && [ $DEBUG_MODE != "on" ]; then
            #    (sudo pv -n "$INFILE" | sudo pigz -d -k -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "Writing..." --gauge "Writing '$INFILE' \n\nto '$(get_sd_name $OUTDEV)' ..." 10 70 0
            #    EXIT_CODE=$?
            #else
            #    sudo pv "$INFILE" | pigz -k -d -c | sudo dd of=$OUTDEV bs=4M conv=fsync 
            #    EXIT_CODE=$?
            #fi
        ;;
        
        xz)
            if [ $INTERFACE = "CLI" ]; then
                 xz -v -d -c "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                 EXIT_CODE=$?
            else
                (sudo pv -n "$INFILE" | xz -d -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(get_sd_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                EXIT_CODE=$?
            fi
        ;;

        gz)
            if [ $INTERFACE = "CLI" ]; then
                pigz -v -d $INFILE | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
                EXIT_CODE=$?
            ##pigz -v -k -c -d "$INFILE" | sudo dd of=$OUTDEV bs=4M conv=fsync status=progress
            #sudo pv "$OUTFILE_BASE".img | sudo pigz -$COMPRESSION > "$OUTFILE"
            #sudo pv "$INFILE" | pigz -k -d -c | sudo dd of=$OUTDEV bs=4M conv=fsync 
            else
                (sudo pv -n "$INFILE" | sudo pigz -d -k -c | sudo dd of=$OUTDEV bs=4M) 2>&1 | whiptail --backtitle "$BACKTITLE" --title "RESTORE" \
                --gauge "\nWriting '$INFILE' \n\nto '$(get_sd_name $OUTDEV)' ..." $WT_HEIGHT $WT_WIDTH 0
                EXIT_CODE=$?
            fi    
        ;;

        *)
            echo
            echo_red ERROR.  Unsupported file extension. 
            return  1 
        ;;

    esac        
    TIME2=$(date +%s)
    echo
    
    if [ $EXIT_CODE != 0 ]; then
        echo
        echo_red  "ERROR. $EXIT_CODE"
        do_write_log "Restore failed $EXIT_CODE"
        return $EXIT_CODE
    else
        do_beep_if_sound
        echo_white "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
        do_write_log "Restore done. '$INFILE' written to '$OUTDEV' in $(get_elapsed_time $TIME1 $TIME2)."
    fi
}


cli_menu(){
case $1 in
    
    backup|read)
        do_write_log $1 $2 $3
        do_backup $2 $3
    ;;
    
    restore|write)
        do_write_log $1 $2 $3
        do_restore $2 $3
    ;;
    
    list)
        do_list_info
    ;;
    
    install)
        do_install
    ;;
        
    update)
        do_update CLI
    ;;
    
    help|-h)
        do_help
    ;;
    
    -v)
        echo $SCRIPTVER
    ;;
    
    gui)
        gui_splash_screen
        gui_menu
    ;;
    
    *)
        if [ ${SCRIPTNAME:0:6} = "pisafe" ]; then
            gui_splash_screen
            gui_menu
        else    
            do_help
        fi    
    ;;
esac
}




########################################
###  WHIPTAIL GUI SECTION ##############
########################################


whiptail_calc_wt_size() {
  # NOTE: it's tempting to redirect stderr to /dev/null, so supress error 
  # output from tput. However in this case, tput detects neither stdout or 
  # stderr is a tty and so only gives default 80, 24 values

  WT_HEIGHT=20
  WT_WIDTH=80
  WT_HEIGHT_TALL=$(($(tput lines)-10))
  WT_WIDTH_WIDE=$(($(tput cols)-7))
  
  #WT_HEIGHT=$(($(tput lines)-10))
  #WT_WIDTH=$(tput cols)
  #WT_WIDTH=$(($(tput cols)-10))


  if [ -z "$WT_WIDTH" ] || [ "$WT_WIDTH" -lt 60 ]; then
    WT_WIDTH=80
  fi
  if [ "$WT_WIDTH" -gt 178 ]; then
    WT_WIDTH=80
  fi
  
  #WT_WIDTH=$(($WT_WIDTH-7))
  WT_MENU_HEIGHT=$(($WT_HEIGHT-7))
  WT_MENU_HEIGHT_TALL=$(($WT_HEIGHT_TALL-7))
  
  #WT_MB_HEIGHT=18
  #WT_MB_WIDTH=70
  
    WT_MB_HEIGHT=$WT_HEIGHT
    WT_MB_WIDTH=$WT_WIDTH
  
  # use for pasting
  # $WT_HEIGHT  $WT_WIDTH
  # $WT_MB_HEIGHT  $WT_MB_WIDTH
}


function whiptail_fselect()
# maybe call something like dialog's fselect
#
#  Arguments
#     1  Dialog title
#     2  Source path to list files and directories
#     3  File mask (by default *)
#     4  "yes" to allow go back in the file system.
#
#  Returns
#     0  if a file was selected and loads the FILE_SELECTED variable 
#        with the selected file.
#     1  if the user cancels.
#
#if whiptail_fselect "Please, select a file" /home/user ; then
#        echo "File Selected: \"$FILE_SELECTED\"."
#else
#        echo "Cancelled!"
#fi
# ----------------------------------------------------------------------
{
    # note: does not handle spaces in file names!!!
    local TITLE=${1:-$MSG_INFO_TITLE}
    local LOCAL_PATH=${2:-$(pwd)}
    local FILE_MASK=${3:-"*"}
    #local FILE_MASK='( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" )'
    local ALLOW_BACK=${4:-no}
    local FILES=()

    [ "$ALLOW_BACK" != "no" ] && FILES+=(".." "..")

    IFS=$'\t\n'

    FILES=("FILENAME" "     SIZE   (IMAGESIZE)")

    # First add folders      
    for DIR in $(find $LOCAL_PATH -maxdepth 1 -mindepth 1 -name "[!.]*" -type d -printf "%f\t" | sort 2> /dev/null)
    do
        FILES+=($DIR  "     folder")
    done


    # Then add the files
 #   for FILE in $(find $LOCAL_PATH -maxdepth 1 \
 #                                   \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" \) \
 #                                   -name "[!.]*" \
 #                                   -type f \
 #                                   -printf "%f\t     %s\n" | sort  2> /dev/null)                  
                                    
    for FILE in $(find $LOCAL_PATH -maxdepth 1 \
                                     \( -name "*.img" -o -name "*.zip" -o -name "*.xz" -o -name "*.gz" \) \
                                    -type f \
                                    -printf "%f\t     %s\n" | sort  2> /dev/null)                                                            
    #-printf "%f\t     %s\n" | sort  2> /dev/null)       
    do
        FILES+=($FILE)
        
        #FI=$(echo $LOCAL_PATH/$FILE | cut -d ' ' -f1)
        #IMAGE_SIZE=$(get_image_size "$FI")
        #FILES+=($FILE $IMAGE_SIZE)
    done
	unset IFS


    # convert filesizes to human readable
    num='^[0-9]+$'
    arraylength=${#FILES[@]}
    
    if [ $arraylength = 0 ]; then
        FILES=(no files)
    fi
    
    for (( i=0; i<${arraylength}; i++ )); do
		arrayelement=$(echo "${FILES[$i]}" | sed 's/ *//g')
		if [[ "$arrayelement" =~ $num ]] ; then  
            #FILES[$i]=$(echo "    " $(get_bytes_h $arrayelement -h))
            #FILES[$i]=$(echo "    " $(get_bytes_h $arrayelement -h)\("$PREVIOUS_ELEMENT"\)) 
            FILES[$i]=$(echo "    " $(get_bytes_h $arrayelement -h) \($(get_image_size "$LOCAL_PATH/$PREVIOUS_ELEMENT" -h)\)) 
            
		else
            PREVIOUS_ELEMENT=$(echo "${FILES[$i]}")
        fi
    done
 
 

    # let user select file
    while true
    do
        FILE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$LOCAL_PATH" \
                                --menu "Choose a file" $WT_HEIGHT_TALL $WT_WIDTH_WIDE $WT_MENU_HEIGHT_TALL "${FILES[@]}"  3>&1 1>&2 2>&3)

        #exit if bad whiptail statement
        FSX=${FILE_SELECTED:0:3}
        if [ ! -z $FSX ] && [ $FSX = "Box" ]; then
            echo "ERROR in whiptail in whiptail_fselect.  Maybe a space in a filename?"
			echo "${FILES[@]}"
            exit 1
        fi
        
        if [ -z "$FILE_SELECTED" ]; then
            return 1
        else
            if [ "$FILE_SELECTED" = ".." ] && [ "$ALLOW_BACK" != "no" ]; then
                return 0

            elif [ -d "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                if whiptail_fselect "$TITLE" "$LOCAL_PATH/$FILE_SELECTED" "$FILE_MASK" "yes" ; then
                    if [ "$FILE_SELECTED" != ".." ]; then
                        return 0
                    fi
                else
                    return 1
                fi

            elif [ -f "$LOCAL_PATH/$FILE_SELECTED" ] ; then
                FILE_SELECTED="$LOCAL_PATH/$FILE_SELECTED"
                return 0
            fi
        fi
    done
}


whiptail_countdown(){  
    local MAX=${1:-10}
    local TITLE=${2:-"COUNTDOWN... press any key to abort"}
    MSG=${3:-"Countdown for $MAX seconds.\n\n"}
    #MSG="Countdown for $MAX seconds.\n\n"
    # return code 2 if aborted. 

    for ((i=$MAX; i>=0; i--)) ; do
		TERM=vt220 whiptail --backtitle "$BACKTITLE"  --title "$TITLE" --infobox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
		#sleep .75
        read -t 1 -N 1 INPUT
        if [ ! -z $INPUT ]; then
            return 2
        fi 
        MSG=$(echo "$MSG.$i")
    done 
}


gui_update(){
    do_update "gui"
}


gui_do_install(){
    do_install
    
    # create the desktop file    

        echo "\
[Desktop Entry]
Type=Application
Terminal=true
Version=1.0
Name=$PRODUCTNAME
Comment=$PRODUCTCOMMENT
#Icon=rpi-imager
Icon=media-removable
Exec=lxterminal --geometry=110x40 -e $SCRIPTNAME
Categories=Utility
StartupNotify=false" > "$PRODUCTNAME.desktop"   

        sudo mv "$PRODUCTNAME.desktop" "/usr/share/applications"

        if [ -f "/usr/local/bin/$SCRIPTNAME" ]; then 
            MSG="$PRODUCTNAME $SCRIPTVER installed.            
            \nSelect it from the 'accessories' menu.
            \n\nOr you can execute it from any directory by typing '$SCRIPTNAME'."
            whiptail --backtitle "$BACKTITLE" --title "INSTALLED" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        else
            MSG="$PRODUCTNAME not installed.  '/usr/local/bin/$SCRIPTNAME' not found. "
            whiptail --backtitle "$BACKTITLE" --title "ERROR" --msgbox "$MSG" $WT_MB_HEIGHT $WT_MB_WIDTH
        fi
}


gui_set_compression(){
    CHOICE=$(whiptail --title "SETTINGS-COMPRESSION" --radiolist \
            "Choose compression level (your milage may vary)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "1" "Fastest time (default)" on \
            "2" "" off \
            "3" "" off \
            "4" "" off \
            "5" "" off \
            "6" "" off \
            "7" "" off \
            "8" "" off \
            "9" "Smallest file (MUCH slower)" off   3>&1 1>&2 2>&3 )
           
            #echo $CHOICE
            if [ ! -z $CHOICE ]; then
                COMPRESSION=$CHOICE
                set_config_var compression_level $CHOICE $CONFIG
            fi
}

    
gui_set_default_path(){
    MSG="Enter new default path   '$DEFAULT_PATH'"
    TEMP_PATH="$DEFAULT_PATH"
    while true; do
        NEWPATH=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$TEMP_PATH" 3>&1 1>&2 2>&3)
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then 
            return $EXIT_CODE
        fi
        
        if [ ! -z $NEWPATH ]; then
        
            if [ -d $NEWPATH ]; then
                #DEFAULT_PATH=$NEWPATH
                DEFAULT_PATH=$(echo "$NEWPATH" | sed 's/[/\t]*$//')
                set_config_var default_path $DEFAULT_PATH $CONFIG
                return 0
            else
                whiptail --title ERROR --msgbox "ERROR Directory '$NEWPATH' does not exist" $WT_MB_HEIGHT $WT_MB_WIDTH
                TEMP_PATH="$NEWPATH"
            fi
        
        fi
    done
}


gui_set_default_extention(){
     CHOICE=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS-EXTENSION" --radiolist \
            "Choose default extension (compression format)" $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
            "zip" "Default" on \
            "xz" "~25% smaller, 3x-4x more time" off \
            "gz" "~25% faster, same size as zip" off  \
            "img" "Twice the size, half the time (No compression)" off 3>&1 1>&2 2>&3 )
    
    echo $CHOICE
    if [ ! -z $CHOICE ]; then
        DEFAULT_EXTENSION=$CHOICE
        set_config_var default_extension $CHOICE $CONFIG  
    fi
}


gui_settings_options(){
   # while true; do
    ON=$(whiptail --title "SETTINGS-OPTIONS" --checklist "Enable options" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT \
"shrink_fs" "Shrink filesystem on backup" "$SHRINK_FS" \
"auto_expand_fs" "Create backup that Auto-unshrinks" "$AUTO_EXPAND_FS" \
"hide_root_device" "Hide root device (CAUTION)" "$HIDE_ROOT_DEVICE" \
"hide_mmc_device" "Hide internal sd card (CAUTION)" "$HIDE_MMC_DEVICE" \
"check_for_updates_on_startup" "" "$CHECK_FOR_UPDATES_ON_STARTUP" \
"sound" " " "$SOUND" \
"log"   "log activity" "$LOG" \
"debug_mode" " " "$DEBUG_MODE" \
 3>&1 1>&2 2>&3) 
    
    if [ $? != 0 ] ; then
        return
    fi
    
    # dump the quotes in the string.
    ON=$(echo $ON | sed 's/"//g')
    
    # set all to off
    set_config_var shrink_fs off $CONFIG
    set_config_var auto_expand_fs off $CONFIG
    set_config_var hide_root_device off $CONFIG
    set_config_var hide_mmc_device off $CONFIG
    set_config_var sound off $CONFIG
    set_config_var log off $CONFIG
    set_config_var debug_mode off $CONFIG
    set_config_var check_for_updates_on_startup off $CONFIG
    
    for SELECTED in $ON; do
        #echo "set_config_var $SELECTED on $CONFIG"
        set_config_var $SELECTED on $CONFIG
    done
    get_settings
    
   # done
    }


gui_settings(){
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "SETTINGS" --menu " " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT  \
        "Default directory   " "$DEFAULT_PATH" \
        "Default extension   " "$DEFAULT_EXTENSION" \
        "Compression         " "$COMPRESSION of 9" \
        "Text editor"        "$TEXT_EDITOR" \
        "Options"          "Several options to turn on/off " \
        "                    " "      " \
        "Edit config         " "Edit the settings file manually (pisafe.conf)" \
        "Factory defaults    " "Reset settings to factory defaults" \
        3>&1 1>&2 2>&3)
        
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        else
            case "$SELECTION" in
            "Default d"*)   gui_set_default_path ;;
          #  "Shrink"*)      gui_set_shrink_fs ;;
          #  "Auto "*)       gui_set_auto_expand_fs ;;
            "Default e"*)   gui_set_default_extention ;;
            "Compression"*) gui_set_compression ;;
          #  Hide*)          gui_set_hide_root_device ;;
          #  Sound*)         gui_set_sound ;;
          #  Debug*)         gui_set_debug_mode ;;
            Options*)      gui_settings_options ;;
            View*)          read -n 1 -p "Press any key to return"   ;;
            Update*)        gui_update  ;;
            Text*)          ;;
            "    "*)        ;;
            Edit*)          $TEXT_EDITOR $CONFIG; get_settings ;;
            Factory*) 
                whiptail --title WARNING --defaultno --yesno "Are you sure you want to reset the settings to factory defaults?" $WT_MB_HEIGHT $WT_MB_WIDTH 
                if [ $? = 0 ] ; then
                    do_factory_reset 
                fi ;;
            
             *)             whiptail --msgbox "Programmer error: unrecognized option" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT ;;
#         esac || whiptail --msgbox "There was an error running option $SELECTION" 20 60 1
            esac
        fi
    done
}


gui_get_indev(){
    # for backup
    
    # Set global variables INDEV and OUTDEV
    gui_select_sddevice "BACKUP" 
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] ; then 
        return $EXIT_CODE
    fi    
    
    # Warning if INDEV is root device
    if [ $INDEV = /dev/$(get_root_device) ]; then
        whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "SD-card is your root device." $WT_MB_HEIGHT $WT_MB_WIDTH  
    fi
    
    # Warning if SD-card is bigger than 16GB
    if [ $(get_sd_size $INDEV) -gt 16000000000 ]; then
        MESG=" '$(get_sd_name $INDEV)' is larger than 16GB.  \
         \n\nUse a smaller SD card if you can.  \
         \nIt will be faster because the entire SD card must be read before it can be compressed.\
         \n\nA good 8gb card with RaspiOS in a Raspberry Pi 4 takes about 10 minutes"
        whiptail --backtitle "$BACKTITLE" --title "WARNING" --msgbox "$MESG" $WT_MB_HEIGHT $WT_MB_WIDTH   
    fi
    
    # Warning if SD-card is bigger than freespace
    if [ $(get_sd_size $INDEV) -gt $(get_freespace "$DEFAULT_PATH") ]; then
        whiptail --backtitle "$BACKTITLE" --title "ERROR" \
        --msgbox "Not enough free space on '$DEFAULT_PATH' 
         \n\n'$(get_sd_name  $INDEV)' is $(get_sd_size $INDEV -h)
         \nfreespace on '$DEFAULT_PATH' is $(get_freespace "$DEFAULT_PATH" -h)
         \n\nBe sure to specify a different drive" $WT_MB_HEIGHT $WT_MB_WIDTH 
        #return 1
    fi
    
    # Warning if one and a half times the SD-card is bigger than freespace
    SPACENEEDED=$(( $(get_sd_size $INDEV) + $(( $(get_sd_size $INDEV) / 2 )) ))
    if [ $SPACENEEDED -gt $(get_freespace "$DEFAULT_PATH") ]; then
        whiptail --backtitle "$BACKTITLE" --title "WARNING" \
            --msgbox "Might not be enough free space on '$DEFAULT_PATH'
            \n\n'$(get_sd_name $INDEV)' is $(get_sd_size $INDEV -h)mb
            \nfreespace on '$DEFAULT_PATH' is $(get_freespace "$DEFAULT_PATH" -h)
            \nThere is $(get_folder_size /home/pi/.local/share/Trash) in the Trash" $WT_MB_HEIGHT $WT_MB_WIDTH   
    fi
    
    # maybe check and see if it looks like a raspbian device?
}


gui_get_outfile(){
    # for backup
    
    OUTFILEDEFAULT="$DEFAULT_PATH/$(date +%Y-%m-%d-newimage)"
    EXT=$DEFAULT_EXTENSION
    OUTFILE=
           
    while [ -z "$OUTFILE" ] || \
          [ ! -d  "$(get_file_path $OUTFILE)" ] || \
          [ -f "$OUTFILE" ] || \
          [ -f "$(get_file_path_base $OUTFILE).img" ] || \
          [ -f "$(get_file_path_base $OUTFILE).img.$EXT" ] || \
          [ -z "$(get_file_ext_ok $OUTFILE)" ]   ; do    
        
      
            # No message if outfile is blank
        
            # Message if path does not exist
            if [ ! -d  "$(get_file_path $OUTFILE)" ] ; then      
                whiptail --backtitle "$BACKTITLE" --title ERROR_1 --msgbox "Directory does not exist '$(get_file_path $OUTFILE)' " $WT_MB_HEIGHT $WT_MB_WIDTH 
            fi
        
            # Message if OUTFILE exists
            if [ -f "$OUTFILE" ] ; then    
                whiptail --backtitle "$BACKTITLE" --title ERROR_2 --msgbox "File '$OUTFILE' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
            fi
        
            # Message if OUTFILE_BASE.img exists
            if [ -f "$(get_file_path_base $OUTFILE).img" ] && [ ! -z "$OUTFILE" ]  ; then
                whiptail --backtitle "$BACKTITLE" --title ERROR_3 --msgbox "File '$(get_file_path_base $OUTFILE).img' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
            fi
        
            # Message if OUTFILE_BASE.img.ext exists
            if [ -f "$(get_file_path_base $OUTFILE).img.$EXT" ] ; then
                whiptail --backtitle "$BACKTITLE" --title ERROR_4 --msgbox "File '$(get_file_path_base $OUTFILE).img.$EXT' exists" $WT_MB_HEIGHT $WT_MB_WIDTH 
            fi
        
            # Message if unsupported ext
            if [ -z "$(get_file_ext_ok $OUTFILE)" ] ; then
                whiptail --backtitle "$BACKTITLE" --title ERROR_5 --msgbox "Unsupported extension '$(get_file_ext $OUTFILE)' " $WT_MB_HEIGHT $WT_MB_WIDTH 
            fi
        

        
            #get filename
            MSG="Enter the image filename (eg: 2020-12-15-buster32) 
            \nIf you don't include an extension '.img.$DEFAULT_EXTENSION' will be added 
            \nSupported extensions are: .img .zip .xz .gz 
            \n.zip is the baseline \n.img is ~2x faster but twice the size (NOT compressed) \n.xz is ~25% smaller but takes 3x-4x longer \n.gz is ~25% faster
            \nRecomended to have NO SPACES in the name "
            NEWFILE=$(whiptail --backtitle "$BACKTITLE" --title "BACKUP : Enter Filename" --inputbox "$MSG" $WT_HEIGHT $WT_WIDTH "$OUTFILEDEFAULT" 3>&1 1>&2 2>&3)
            EXIT_CODE=$?
            if [ $EXIT_CODE != 0 ]; then 
                return $EXIT_CODE
            fi
        
            #fill out variables based on selected filename
            OUTFILEDEFAULT="$NEWFILE"
            OUTFILE="$NEWFILE"
            if [ ! -z $(get_file_ext "$OUTFILE") ]; then
                EXT=$(get_file_ext "$OUTFILE")
            else    
                EXT=$DEFAULT_EXTENSION
            fi
        
        done
        
        
        # add .img.zip if no extension
        if [ ! -z "$OUTFILE" ] && [ -z "$(get_file_ext $OUTFILE)" ] ; then 
             echo "Adding '.img.$DEFAULT_EXTENSION'"
             OUTFILE=$OUTFILE.img.$DEFAULT_EXTENSION
             #echo "added ext '$OUTFILE'"
        fi
        
        # check and fix outfile name.....
        OUTFILE=$(get_file_path_base "$OUTFILE").img.$(get_file_ext "$OUTFILE")
        #echo "OUTFILE='$OUTFILE'"
}


gui_get_infile(){
    # for restore
    
    if whiptail_fselect "WRITE : Select an Image-file" "$DEFAULT_PATH" "zip" "no" ; then
    INFILE=$FILE_SELECTED
    else
        return 1
    fi
     
    check_for_img_file "$INFILE"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No image file found in '$INFILE'"  $WT_MENU_HEIGHT $WT_WIDTH_WIDE
        return 1
    fi 
}


gui_get_outdev(){
    # for restore

    gui_select_sddevice "RESTORE"       # this sets global variable OUTDEV
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi    
    
    #stop if outdev is piSave-locked
    if [ $(get_config_var device_lock_$(get_device_serial $OUTDEV) $CONFIG) = "on" ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Device '$(get_device_serial $OUTDEV)' 
        \nis locked by PiSafe in the config file" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
    
    # Stop if outdev is the root device
    if [ $OUTDEV = /dev/$(get_root_device) ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Restore to root device not allowed" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
    
    #stop if INFILE is on OUTDEV
    if [ "$(get_file_device "$INFILE")" = $OUTDEV ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Restore to same device as '$INFILE' not allowed" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
    
    
    # Warning if device is large
    if [ $(get_sd_size $OUTDEV) -gt $LARGE_DEVICE_WRITE_WARNING ]; then
        if (whiptail  --backtitle "$BACKTITLE" --title " RESTORE WARNING " --defaultno \
            --yesno "'$(get_sd_name $OUTDEV)' 
            \nis larger than $(get_bytes_h $LARGE_DEVICE_WRITE_WARNING)... 
            \n\nAre you sure it is the right device?" $WT_HEIGHT $WT_WIDTH) then
            RESULT="YES"
        else
            RESULT="n"
            return 1
        fi
    fi
     
    # Stop if imagefile is larger than device
    if [ $(get_image_size "$INFILE") -gt $(get_sd_size $OUTDEV) ]; then
        whiptail --backtitle "$BACKTITLE" --title " RESTORE ABORTED " \
        --msgbox "Not enough room
        \nThe image in '$INFILE' is ' $(get_image_size "$INFILE" -h)' 
        \nand '$OUTDEV' is only '$(get_sd_size $OUTDEV -h)'" $WT_HEIGHT $WT_WIDTH
        return 1
    fi
}


gui_do_backup(){
    INDEV=$1  #use global vars  
    OUTFILE=$2   #use global vars
    
    #get global variable INDEV
    gui_get_indev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    # get global variable OUTFILE
    gui_get_outfile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    #confirm to continue
    whiptail  --backtitle "$BACKTITLE" --title "BACKUP : Create Image-file" --defaultno \
        --yesno "Backup '$(get_sd_name $INDEV)' on '$INDEV' 
        \nto '$OUTFILE'.
        \n\nA good 8GB card with RaspiOS on a Pi4 takes about 10 minutes.
        \nThis will switch to the terminal screen to watch the progress ...
        \n\nCreate backup file now?"   $WT_HEIGHT $WT_WIDTH
    EXIT_CODE=$?       
    if [ $EXIT_CODE != 0 ] ; then
        return $EXIT_CODE
    fi


    ###########################################################
    # this next line actually does the work!!
    do_backup $INDEV "$OUTFILE" "on" "gui"
    EXIT_CODE=$?
    
    if [ $EXIT_CODE != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$DEBUG_MODE
        echo Exit_code=$EXIT_CODE
        read -n 1 -p "Press any key to continue..." 
        if [ $EXIT_CODE != 0 ] ; then
# does this need a whiptail msgbox saying there was an error?        
            return $EXIT_CODE
        fi   
    fi 
    ###########################################################

    # Display results
    whiptail  --backtitle "$BACKTITLE" --title " BACKUP-DONE "  \
        --msgbox "'$(get_sd_name $INDEV)' backed up to 
        \n'$OUTFILE' 
        \ncompressed from '$(get_sd_size $INDEV -h)' to '$(get_file_size $OUTFILE -h)' in $(get_elapsed_time $TIME1 $TIME4) 
        \n\nYou can remove '$(get_sd_name $INDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}  


gui_do_restore() {   
    # get global variable INFILE
    gui_get_infile
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    # get global variable OUTDEV
    gui_get_outdev
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi

    # Confirm to continue
    #do_beep_if_sound
    if (whiptail  --backtitle "$BACKTITLE" --title "RESTORE" --defaultno \
        --yesno "Restore '$INFILE' 
        \nto '$(get_sd_name $OUTDEV)' on '$OUTDEV' 
        \n\nALL existing data on '$(get_sd_name $OUTDEV)' - WILL BE ERASED!  
        \nRestore now?" $WT_HEIGHT $WT_WIDTH) then
        #echo "User selected Yes, exit status was $?."
        RESULT="YES"
    else
        #echo "User selected No, exit status was $?."
        RESULT="n"
        return 1
    fi

    #Countdown before continuing
    do_beep_if_sound
    whiptail_countdown 10 "" "Overwriting '$(get_sd_name $OUTDEV)' in 10 seconds...\n\n"
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title "RESTORE" --msgbox "Restore Aborted... \n\n a key was pressed. " $WT_MB_HEIGHT $WT_MB_WIDTH
        return $EXIT_CODE
    fi    
              
   ###################################################       
    # do the restore
    # the third parameter turns "SAFETY" to "off".  this is because we already checked with the GUI.
    
    do_restore "$INFILE" $OUTDEV off GUI
    EXIT_CODE=$?
    if [ $EXIT_CODE != 0 ] || [ $DEBUG_MODE = "on" ]; then
        echo Debug_mode=$DEBUG_MODE
        echo Exit_code=$EXIT_CODE
        read -n 1 -p "Press any key to continue..." 
        if [ $EXIT_CODE != 0 ] ; then
            return $EXIT_CODE
        fi   
    fi 
   ###################################################
 
    #display the results
    whiptail  --backtitle "$BACKTITLE" --title " RESTORE-DONE " \
        --msgbox "'$INFILE' restored to 
        \n'$(get_sd_name $OUTDEV)'
        \nin $(get_elapsed_time $TIME1 $TIME2)
        \n\nYou can remove '$(get_sd_name $OUTDEV)' now. " $WT_MB_HEIGHT $WT_WIDTH
}


gui_select_sddevice(){
    TITLE=$1
    FIELD_SEPERATOR="|"

    #get this list of sd devices and add a field seperator |    
    IFS=$'\n'
    #options=($(lsblk -d -n -o NAME,VENDOR,MODEL,SIZE /dev/sd? | sed 's/ ./ | /'))
    options=($(get_sd_devices | sed 's/ ./ '$FIELD_SEPERATOR' /'))
    unset IFS
    
    arraylength=${#options[@]}
    if [ $arraylength = 0 ]; then
        whiptail --backtitle "$BACKTITLE" --title ERROR --msgbox "No SD cards found." $WT_MB_HEIGHT  $WT_MB_WIDTH
        return 1
    fi

    IFS=$FIELD_SEPERATOR
    DEVICE_SELECTED=$(whiptail --clear --backtitle "$BACKTITLE" --title "$TITLE"\
     --menu "Choose an SD card (Hide root device = $HIDE_ROOT_DEVICE)" $WT_MB_HEIGHT $WT_MB_WIDTH 10 ""${options[@]}"" 3>&1 1>&2 2>&3)
    EXIT_CODE=$?
    unset IFS   
     
    if [ $EXIT_CODE != 0 ]; then
        return $EXIT_CODE
    fi
    
    OUTDEV=$DEVICE_SELECTED
    INDEV=$DEVICE_SELECTED
    return 0
}


gui_tools(){
    local SELECTION
    while true; do
        SELECTION=$(whiptail --backtitle "$BACKTITLE" --title "TOOLS" --menu " Choose " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
        "INSTALL"           "Install $PRODUCTNAME into the menu" \
        "UPDATE"            "Check for updates" \
        "VIEW TERMINAL"     "View the terminal (for debugging)" \
        "HELP"              "Help" \
        "ABOUT"             "ABOUT $PRODUCTNAME" \
        3>&1 1>&2 2>&3)
        
        EXIT_CODE=$?
        if [ $EXIT_CODE != 0 ]; then
            return $EXIT_CODE
        else
            case "$SELECTION" in
            INSTALL)   gui_do_install  ;;
            UPDATE)    gui_update  ;;

            VIEW*)      read -n 1 -p "Press any key to return"  ;;
            HELP)
                INFO=$(do_help)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$result" $WT_HEIGHT  $WT_WIDTH
                ;;
            ABOUT)
                INFO=$(do_about)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$result" $WT_HEIGHT  $WT_WIDTH
                ;;   
            *)           whiptail --msgbox "Programmer error: unrecognized option" $WT_HEIGHT  $WT_WIDTH  $WT_MENU_HEIGHT ;;
            esac 
        fi
    done
}


gui_menu(){
    whiptail_calc_wt_size
    INTERFACE="GUI"
    while true
    do
        MENU_CHOICE=$(whiptail \
                --clear \
                --backtitle "$BACKTITLE" \
                --title "MAIN MENU" \
                --ok-button "Select" \
                --cancel-button "Exit" \
                --menu "    " $WT_HEIGHT $WT_WIDTH $WT_MENU_HEIGHT \
                "BACKUP"    "   Backup an SD-card to an image-file" \
                "RESTORE"   "   Restore an SD-card from an image-file" \
                "LIST"      "   List info" \
                                "  "        "   " \
                "SETTINGS"  "   Change settings" \
                "TOOLS"     "   Various tools"\
                "INSTALL"   "   Install $PRODUCTNAME into the menu" \
                3>&1 1>&2 2>&3)
                
        #echo $MENU_CHOICE
        case $MENU_CHOICE in
            BACKUP)         gui_do_backup   ;;
            
            RESTORE)        gui_do_restore  ;;
            
            LIST)
                INFO=$(do_list_info $DEFAULT_PATH)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "LIST" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;
            
            SETTINGS)       gui_settings    ;;
            
            INSTALL)        gui_do_install     ;;
            
            UPDATE)         do_update       ;;
            
            VIEW*)          read -n 1 -p "Press any key to return to $PRODUCTNAME"   ;;
            
            HELP)
                INFO=$(do_help)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "HELP" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;
            
            ABOUT)
                INFO=$(do_about)
                result="$INFO"
                whiptail --backtitle "$BACKTITLE"  --title "ABOUT" --scrolltext --msgbox "$result" $WT_HEIGHT_TALL  $WT_WIDTH_WIDE
                ;;   
            
            TOOLS)          gui_tools       ;;
            
            "  "*)                          ;;
            
            * )             return          ;;
        esac
    done
}


gui_splash_screen(){
    
   # echo $SETTINGS_SCRIPT_VER
   # echo $SCRIPTVER
   # echo $(get_ver_to_int $SETTINGS_SCRIPT_VER)
   # exit
    
    if [ $(get_ver_to_int $SETTINGS_SCRIPT_VER) -lt $(get_ver_to_int $SCRIPTVER) ]; then
    
        whiptail --backtitle "$BACKTITLE" --title "WELCOME" --yes-button "Load Factory Defaults"\
        --yesno "Welcome to $PRODUCTNAME
        \nMany changes have been made to $PRODUCTNAME and to the settings file.
        \nIt is recomended that you load the factory defaults now.
        \nWhile best attempts have been made to make $PRODUCTNAME reliable... use at your own risk. " \
        $WT_MB_HEIGHT $WT_MB_WIDTH
    
    
    if [ $? = 0 ] ; then
        do_factory_reset 
    fi 
    
    
    fi
}



# if arg = -v, then show version and exit the script
if  [ ! -z "$1" ]  && [ $1 = "-v" ]; then
    echo $SCRIPTVER
    exit
fi

test(){
echo file_base
get_file_base /media/pi/blue_2T/linux/raspberrypios/2020-08-20-raspios-buster-armhf.zip
get_file_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz
get_file_base $(get_file_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz)
echo file_path
get_file_path /media/pi/blue_2T/linux/raspberrypios/2020-08-20-raspios-buster-armhf.zip
get_file_path /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz
get_file_path $(get_file_path_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz)
echo path_base
get_file_path_base /media/pi/blue_2T/linux/raspberrypios/2020-08-20-raspios-buster-armhf.zip
get_file_path_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz
get_file_path_base $(get_file_path_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz)
get_file_path_base $(get_file_path_base $(get_file_path_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz))
echo ext
get_file_ext /media/pi/blue_2T/linux/raspberrypios/2020-08-20-raspios-buster-armhf.zip
get_file_ext /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz
get_file_ext $(get_file_path_base /media/pi/blue_2T/linux/raspberrypios/TwisterOSv1-9-2.img.xz)
get_file_ext /media/pi/blue_2T/linux/raspberrypios/2020-08-20-raspios-buster-armhf


exit
}




test2(){
    check_for_img_file /home/pi/Downloads/2021-03-06-newimage.img.zip
    echo $?
    check_for_img_file /home/pi/Downloads/2021-03-06-newimage.img.xz
      echo $?
    check_for_img_file /home/pi/Downloads/2021-03-06-newimage.img.gz
      echo $?

  check_for_img_file /home/pi/Downloads/2021-03-06-newimage2.gz
    echo $?
  check_for_img_file /home/pi/Downloads/fake-image-file.zip
    echo $?
exit    
}


#test2


get_tools
do_init_conf
get_settings
whiptail_calc_wt_size

if [ $CHECK_FOR_UPDATES_ON_STARTUP = "on" ]; then
    do_update GUI no
fi


cli_menu $1 $2 $3
